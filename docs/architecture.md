# Zest Circuit Architecture

## Single-Source SPICE Generation

### Overview

The Zest circuit architecture follows the **single-source SPICE generation** principle, where the authoritative representation of any circuit is the SPICE netlist string generated by `compile_to_spice()`. Every simulation backend must accept this string as input, and no other path should build a PySpice circuit object directly.

### Core Principles

1. **Canonical Representation**: The SPICE string generated by `CircuitRoot.compile_to_spice()` is the only canonical representation of the circuit.

2. **Backend Abstraction**: All simulation backends implement the `SimulatorBackend` interface and consume SPICE netlist strings.

3. **Pure Compilation**: The `compile_to_spice()` method is side-effect-free and thread-safe. It does not mutate any component's `.name` field or internal circuit state.

4. **Component Responsibility**: Every `Component` subclass must implement `to_spice(mapper, *, forced_name=None)` as the only way to convert to SPICE format.

5. **Consistent Node Naming**: The `NodeMapper` class provides deterministic, consistent node names (N1, N2, N3, etc.) with special handling for ground ("gnd") and user-defined pin aliases.

### Architecture Components

#### SimulatorBackend (Abstract Interface)

```python
class SimulatorBackend(ABC):
    @abstractmethod
    def run(self, netlist: str, analyses: list[str], **kwargs):
        """Run simulation analyses on a SPICE netlist."""
        pass
```

#### PySpiceBackend (Concrete Implementation)

The `PySpiceBackend` class implements the backend interface using PySpice's `SpiceParser` to parse SPICE netlists and run simulations. This backend:

- Parses the netlist string using `PySpice.Spice.Parser.SpiceParser`
- Supports operating point, DC sweep, AC, and transient analyses
- Handles simulation parameters like temperature, frequency ranges, etc.
- Returns `SimulatedCircuit` objects with analysis results

#### Circuit Simulation Methods

The `CircuitRoot` class provides simulation methods that use the backend architecture:

```python
def simulate_operating_point(self, backend=None, temperature=25, add_current_probes=False):
    if backend is None:
        backend = PySpiceBackend()
    
    netlist = self.compile_to_spice()
    return backend.run(netlist, analyses=["op"], temperature=temperature, circuit=self)
```

#### NodeMapper

The `NodeMapper` class handles deterministic node name generation:

- **Ground**: Always returns "gnd" for ground connections
- **Pin Aliases**: Uses user-defined pin names for subcircuit pins
- **Generated Names**: Uses N1, N2, N3, etc. for internal nodes
- **Connectivity-Aware**: Terminals connected together share the same node name

#### Component to_spice() Methods

Every component implements `to_spice(mapper, *, forced_name=None)`:

```python
def to_spice(self, mapper, *, forced_name=None):
    """Convert to SPICE format using NodeMapper."""
    pos_node = mapper.name_for(self.pos)
    neg_node = mapper.name_for(self.neg)
    return f"{forced_name or self.name} {pos_node} {neg_node} DC {self.voltage}"
```

### SPICE Netlist Structure

The `compile_to_spice()` method generates complete SPICE netlists with:

1. **Header**: Circuit name and comments
2. **Includes**: `.INCLUDE` statements for external model files
3. **Models**: Embedded model definitions
4. **Subcircuits**: `.SUBCKT` definitions for reusable blocks
5. **Components**: Main circuit component lines
6. **Initial Conditions**: `.NODESET` directives if specified
7. **Footer**: `.end` statement

### Migration from PySpice Builder API

The architecture migration eliminated the PySpice builder approach:

#### Before (PySpice Builder - REMOVED)
```python
# OLD - No longer used
pyspice_circuit.V(name, pos_node, neg_node, voltage@u_V)
pyspice_circuit.R(name, n1_node, n2_node, resistance@u_Î©)
```

#### After (Single-Source SPICE)
```python
# NEW - Only approach
netlist = circuit.compile_to_spice()
backend = PySpiceBackend()
result = backend.run(netlist, analyses=["op"], circuit=circuit)
```

### Benefits

1. **Backend Flexibility**: Easy to add new simulation engines (ngspice, Xyce, etc.)
2. **Consistency**: Single representation eliminates synchronization issues
3. **Debugging**: SPICE netlists can be inspected and debugged directly
4. **Compatibility**: Standard SPICE format works with any SPICE-compatible simulator
5. **Thread Safety**: Pure compilation functions enable parallel circuit generation
6. **Future-Proof**: Support for parsing SPICE back into circuit graphs

### Legacy Compatibility

The `CircuitSimulator` class is maintained for backward compatibility but internally uses the new backend architecture. It is marked as deprecated, and users should transition to the new `circuit.simulate_*()` methods.

### Testing

The architecture includes comprehensive tests:

- **Golden Tests**: Verify exact SPICE netlist generation
- **Backend Tests**: Ensure simulation backends work correctly
- **Integration Tests**: Validate end-to-end circuit simulation
- **Compatibility Tests**: Ensure legacy code continues to work

### Future Enhancements

This architecture enables future capabilities:

1. **Multiple Backends**: Support for different SPICE engines
2. **Distributed Simulation**: Parallel execution across multiple cores/machines
3. **SPICE Parsing**: Import existing SPICE netlists into Zest circuits
4. **Optimization**: Circuit optimization through netlist manipulation
5. **Verification**: Formal verification of circuit properties

---

*This architecture represents a fundamental shift from the PySpice builder approach to a clean, backend-agnostic design that prioritizes consistency, flexibility, and maintainability.* 