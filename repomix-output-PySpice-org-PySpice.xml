This file is a merged representation of a subset of the PySpice codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: PySpice/, examples/
- Files matching these patterns are excluded: **/*.svg, **/*.pdf, **/m4/*, **/c-examples/*, examples/libraries/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
examples/
  .travis/
    travis.py
  advanced-usages/
    index.rst
    internal-device-parameters.py
  analyses/
    analyses.py
    pole_zero_analysis.py
    test_pole_zero.cir
  basic-usages/
    index.rst
    netlist-manipulations.py
    raw-spice.py
    subcircuit.py
    unit.py
  data-analysis/
    fft.py
  diode/
    m4/
      diode-characteristic-curve-circuit-ac.m4
      diode-characteristic-curve-circuit-pulse.m4
      diode-characteristic-curve-circuit.m4
      full-wave-rectification.m4
      half-wave-rectification.m4
      voltage-multiplier-circuit.m4
      zener-diode-characteristic-curve-circuit.m4
    tex/
      diode.tex
    diode-characteristic-curve.py
    diode-recovery-time.py
    index.rst
    rectification.py
    ring-modulator.py
    RingModulator.py
    voltage-multiplier.py
    zener-characteristic-curve.py
  electricity/
    three-phase.py
  filter/
    m4/
      low-pass-rc-filter.m4
      low-pass-rlc-filter.m4
      pass-band-rlc-filter.m4
    low-pass-rc-filter.py
    rlc-filter.py
  fundamental-laws/
    m4/
      current-divider.m4
      millman-theorem-with-current-source.m4
      millman-theorem.m4
      thevenin-norton-theorem.m4
      voltage-divider.m4
    index.rst
    millman-theorem.py
    thevenin-norton-theorem.py
    voltage-current-divider.py
  libraries/
    diode/
      general-purpose/
        BAV21.lib
        BAV21.lib@xyce
      schottky/
        1N5822.lib
      switching/
        1N4148.lib
      zener/
        1N5919B.lib
    mosfet/
      irf150.lib
    operational-amplifier/
      LMV981.MOD
    transistor/
      2N2222A.lib
      ptm_65nm_nmos_bulk.mod
      ptm_65nm_pmos_bulk.mod
  ngspice-shared/
    external-source.py
    index.rst
    ngspice-interpreter.py
  operational-amplifier/
    astable.py
    operational-amplifier.py
    OperationalAmplifier-api-brainstorming.py
    OperationalAmplifier.py
  passive/
    m4/
      capacitor_and_inductor.m4
    capacitor-inductor.py
  power-supplies/
    m4/
      capacitive-half-wave-rectification-post-zener-circuit.m4
      capacitive-half-wave-rectification-pre-zener-circuit.m4
    capacitive-half-wave-rectification-post-zener.py
    capacitive-half-wave-rectification-pre-zener.py
    hp54501a-cem.py
    HP54501A.py
  pyterate-templates/
    document.jinja2
  relay/
    relay.py
  resistor/
    m4/
      resistor-bridge.m4
      voltage-divider.m4
    resistor-bridge.py
    voltage-divider.py
  spice-examples/
    ac-coupled-amplifier.cir
    ac-coupled-transistor-amplifier.cir
    astable.cir
    diode-ac.cir
    diode.cir
    low-pass-rc-filter.cir
    operational-amplifier-model-1.cir
    operational-amplifier-model-2.cir
    resistor-bridge.cir
    small-signal-amplifier-with-diodes.cir
    small-signal-amplifier.cir
    transform-less-power-supply.cir
    transistor.cir
    transistor2.cir
    voltage-divider.cir
  spice-parser/
    kicad-pyspice-example/
      kicad-pyspice-example-cache.lib
      kicad-pyspice-example-rescue.lib
      kicad-pyspice-example.cir
      kicad-pyspice-example.pro
      kicad-pyspice-example.sch
    kicad-spice-example/
      netlist/
        kicad-spice-example.default.cir
        kicad-spice-example.number-node.cir
        kicad-spice-example.using-X.cir
      spice/
        components.cir
        example.cir
        LMV981.MOD
        run.sh
      kicad-spice-example-cache.lib
      kicad-spice-example-rescue.lib
      kicad-spice-example.pro
      kicad-spice-example.sch
      README.txt
    bootstrap-example.py
    index.rst
    kicad-example.py
  switched-power-supplies/
    buck-converter.py
  transformer/
    transformer-example.py
    Transformer.py
  transistor/
    m4/
      ac-coupled-amplifier.m4
      transistor.m4
    ac-coupled-amplifier.py
    nmos-transistor.py
    transistor.py
  transmission-lines/
    time-delay.py
  index.rst
  run-examples
  Settings.py
PySpice/
  Config/
    ConfigInstall.py
    logging.yml
  DeviceLibrary/
    __init__.py
  Doc/
    ExampleTools.py
  Logging/
    Logging.py
  Math/
    __init__.py
    Calculus.py
  Physics/
    MaterialProperties.py
    PhysicalConstants.py
    Resistor.py
    SemiConductor.py
  Plot/
    BodeDiagram.py
  Probe/
    Plot.py
    WaveForm.py
  Scripts/
    cir2py.py
    pyspice_post_installation.py
  Spice/
    Expression/
      __init__.py
      Ast.py
      Parser.py
    NgSpice/
      __init__.py
      api.h
      RawFile.py
      Server.py
      Shared.py
      Simulation.py
      SimulationType.py
    Xyce/
      RawFile.py
      Server.py
      Simulation.py
    __init__.py
    BasicElement.py
    ElementParameter.py
    HighLevelElement.py
    Library.py
    Netlist.py
    Parser_jmgc.py
    Parser.py
    RawFile.py
    Simulation.py
  Tools/
    EnumFactory.py
    File.py
    Path.py
    StringTools.py
  Unit/
    __init__.py
    SiUnits.py
    Unit.py
  __init__.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="examples/.travis/travis.py">
# Travis test
#skip#
raise NameError('Failure')
</file>

<file path="examples/advanced-usages/index.rst">
=================
 Advanced Usages
=================

This section contains examples showing advanced usages.
</file>

<file path="examples/advanced-usages/internal-device-parameters.py">
#r# ============================
#r#  Internal Device Parameters
#r# ============================
#r# This example show how to access internal device parameters.
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit, SubCircuit, SubCircuitFactory
from PySpice.Unit import *
####################################################################################################
class Level2(SubCircuitFactory):
    NAME = 'level2'
    NODES = ('d4', 'g4', 'v4')
    def __init__(self):
        super().__init__()
        self.M(1, 'd4', 'g4', 'v4', 'v4', model='NMOS', w=1e-5, l=3.5e-7)
class Level1(SubCircuitFactory):
    NAME = 'level1'
    NODES = ('d3', 'g3', 'v3')
    def __init__(self):
        super().__init__()
        self.X('mos2', 'level2', 'd3', 'g3', 'v3')
        self.subcircuit(Level2())
circuit = Circuit('Transistor output characteristics')
circuit.V('dd', 'd1', circuit.gnd, 2)
circuit.V('ss', 'vsss', circuit.gnd, 0)
circuit.V('sig', 'g1', 'vsss', 0)
circuit.X('mos1', 'level1', 'd1', 'g1', 'vsss')
if True:
    circuit.subcircuit(Level1())
else:
    subcircuit_level2 = SubCircuit('level2', 'd4', 'g4', 'v4')
    subcircuit_level2.M(1, 'd4', 'g4', 'v4', 'v4', model='NMOS', w=1e-5, l=3.5e-7)
    subcircuit_level1 = SubCircuit('level1', 'd3', 'g3', 'v3')
    subcircuit_level1.X('mos2', 'level2', 'd3', 'g3', 'v3')
    subcircuit_level1.subcircuit(subcircuit_level2)
    circuit.subcircuit(subcircuit_level1)
circuit.model('NMOS', 'NMOS', LEVEL=8)
print(str(circuit))
####################################################################################################
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
# Fixme: python return code is not 0 on Windows if the following line is executed
#        but any error is reported
## analysis = simulator.dc(Vdd=slice(0, 5, .1)) # Fixme: ,Vsig=slice(1, 5, 1)
#r# To be completed ...
####################################################################################################
#?# vdd d1 0 2.0
#?# vss vsss 0 0
#?# vsig g1 vsss 0
#?# xmos1 d1 g1 vsss level1
#?# .subckt level1 d3 g3 v3
#?# xmos2 d3 g3 v3 level2
#?# .ends
#?# .subckt level2 d4 g4 v4
#?# m1 d4 g4 v4 v4 nmos w=1e-5 l=3.5e -007
#?# .ends
#?# .dc vdd 0 5 0.1 vsig 0 5 1
#?# .control
#?# save all @m.xmos1.xmos2.m1[vdsat]
#?# run
#?# plot vss#branch $ current measured at the top level
#?# plot @m.xmos1.xmos2.m1[vdsat]
#?# .endc
#?# .MODEL NMOS NMOS LEVEL=8
#?# +VERSION=3.2.4 TNOM=27 TOX=7.4E-9
#?# .end
</file>

<file path="examples/analyses/analyses.py">
#! /usr/bin/env python3
#skip#
# Program to test pole-zero, noise, and distortion function of ngspice, PySpice
import argparse
####################################################################################################
import numpy as np
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
####################################################################################################
from PySpice.Spice.Netlist import Circuit
# This program implements the PySpice equivalent of the following circuit,
# which is run using the shell command
# $ ngspice -b file.ckt
FILE_CKT = """
.title test circuit
.model qbc847b npn (BF=324.4 BR=8.29 CJC=3.347e-12 CJE=1.244e-11 CJS=0 EG=1.11 FC=0.979 IKF=0.109 IKR=0.09 IRB=5e-06 IS=1.822e-14 ISC=9.982e-12 ISE=2.894e-16 ITF=0.3131 MJC=0.391 MJE=0.3656 MJS=0.333 NC=1.763 NE=1.4 NF=0.9932 NR=0.9931 PTF=0 RB=10 RBM=5 RC=0.7014 RE=0.649 TF=4.908e-10 TR=9e-08 VAF=82 VAR=17.9 VJC=0.5463 VJE=0.7579 VJS=0.75 VTF=2.927 XCJC=0.6193 XTB=0 XTF=9.51 XTI=3)
R1 3 2 2200k
Q1 3 2 0 qbc847b
R3 1 3 1k
C1 4 2 100e-9
C2 3 5 1e-6
C4 1 3 10e-9
R5 5 0 10k
Vpwr 1 0 dc 6
Vin 4 0 dc 0 ac .001 distof1 1 distof2 0.1
.control
op 27
print all
ac dec 10 10 1e5
print V(5)
pz 4 0 5 0 vol pz
print all
noise v(5,0) Vin dec 10 10 1e5 1
print all
disto dec 10 10 1e5
print V(5)
disto dec 10 10 1e5 0.9
print V(5)
"""
class NodeNames:
    """ Allow setting of nodes with appropriate names. """
    def __init__(self, *args):
        for arg in args:
            setattr(self, arg, arg)
# npn gp signal transistor
def set_model_qbc847b(circuit):
    model = 'qbc847b'
    circuit.model(
        model, 'npn', IS=1.822E-14, NF=0.9932, ISE=2.894E-16, NE=1.4, BF=324.4,
        IKF=0.109, VAF=82, NR=0.9931, ISC=9.982E-12, NC=1.763, BR=8.29, IKR=0.09, VAR=17.9,
        RB=10, IRB=5E-06, RBM=5, RE=0.649, RC=0.7014, XTB=0, EG=1.11, XTI=3, CJE=1.244E-11,
        VJE=0.7579, MJE=0.3656, TF=4.908E-10, XTF=9.51, VTF=2.927, ITF=0.3131, PTF=0, CJC=3.347E-12,
        VJC=0.5463, MJC=0.391, XCJC=0.6193, TR=9E-08, CJS=0, VJS=0.75, MJS=0.333, FC=0.979,
    )
    return model
def simple_bjt_amp():
    circuit = Circuit('test circuit')
    model_npn = set_model_qbc847b(circuit)
    n = NodeNames('n1', 'n2', 'n3', 'n4', 'n5')
    gnd = 0
    circuit.R('1', n.n3, n.n2, 2.2e6)
    circuit.Q('1', n.n3, n.n2, gnd, model=model_npn)
    circuit.R('3', n.n1, n.n3, 1e3)
    circuit.C('1', n.n4, n.n2, 100e-9)
    circuit.C('2', n.n3, n.n5, 1e-6)
    circuit.C('4', n.n1, n.n3, 10e-9)
    circuit.R('5', n.n5, gnd, 10e3)
    circuit.V('pwr', n.n1, gnd, 6)
    circuit.V('in', n.n4, gnd, 'dc 0 ac 1 distof1 1 distof2 0.1')
    return circuit, n
def dump_circuit():
    circuit, n = simple_bjt_amp()
    print(circuit)
def do_dc_analysis():
    circuit, n = simple_bjt_amp()
    simulator = circuit.simulator(temperature=25, nominal_temperature=25)
    analysis = simulator.operating_point()
    print("Collector voltage: ", np.array(analysis[n.n3])[0])
    print("base voltage: ", np.array(analysis[n.n2])[0])
def do_ac_analysis():
    circuit, n = simple_bjt_amp()
    simulator = circuit.simulator(temperature=25, nominal_temperature=25)
    analysis = simulator.ac(start_frequency=10, stop_frequency=1e6, number_of_points=100, variation='dec')
    gain = np.array(analysis[n.n5])
    figure = plt.figure(1, (20, 10))
    axe = plt.subplot(211)
    axe.grid(True)
    axe.set_xlabel("Frequency [Hz]")
    axe.set_ylabel("dB gain.")
    axe.semilogx(analysis.frequency, 20*np.log10(np.abs(gain)))
    axe = plt.subplot(212)
    axe.grid(True)
    axe.set_xlabel("Frequency [Hz]")
    axe.set_ylabel("Phase.")
    axe.semilogx(analysis.frequency, np.arctan2(gain.imag, gain.real))
    plt.show()
def do_pz_analysis():
    circuit, n = simple_bjt_amp()
    com = 0
    simulator = circuit.simulator(temperature=25, nominal_temperature=25)
    analysis = simulator.polezero(n.n4, com, n.n5, com, 'vol', 'pz')
    print("Poles")
    for n in analysis.nodes:
        if not n.startswith('pole'):
            continue
        pole = np.array(analysis[n])
        print(pole)
    print("Zeros")
    for n in analysis.nodes:
        if not n.startswith('zero'):
            continue
        zero = np.array(analysis[n])
        print(zero)
def do_noise_analysis():
    circuit, n = simple_bjt_amp()
    com = 0
    simulator = circuit.simulator(temperature=25, nominal_temperature=25)
    analysis = simulator.noise(output_node=n.n5, ref_node=com, src='Vin', variation='dec', points=10, start_frequency=100, stop_frequency=1e5, points_per_summary=1)
    print("Total noise (Vrms) at circuit output:", np.array(analysis.nodes['onoise_total'])[0])
    print("Total noise (Vrms) as if at circuit input:", np.array(analysis.nodes['inoise_total'])[0])
def do_distortion_analysis(f2overf1):
    circuit, n = simple_bjt_amp()
    com = 0
    simulator = circuit.simulator(temperature=25, nominal_temperature=25)
    analysis = simulator.distortion(variation='dec', points=10, start_frequency=100, stop_frequency=1e4, f2overf1=f2overf1)
    output = np.array(analysis[n.n5])
    analysis_ac = simulator.ac(start_frequency=100, stop_frequency=1e4, number_of_points=10, variation='dec')
    gain = np.array(analysis_ac[n.n5])
    print("output", output)
    print("gain", gain)
    figure = plt.figure(1, (20, 10))
    axe = plt.subplot(211)
    axe.grid(True)
    axe.set_xlabel("Frequency [Hz]")
    if f2overf1:
        axe.set_ylabel("Harmonic Magnitude.")
    else:
        axe.set_ylabel("Spectral Magnitude.")
    harmonics = output/gain
    axe.semilogx(analysis.frequency, np.abs(harmonics))
    axe = plt.subplot(212)
    axe.grid(True)
    axe.set_xlabel("Frequency [Hz]")
    axe.set_ylabel("Phase.")
    axe.semilogx(analysis.frequency, np.arctan2(harmonics.imag, harmonics.real))
    plt.show()
if __name__ == '__main__':
    logger = Logging.setup_logging()
    parser = argparse.ArgumentParser("Test pyspice pole-zero, noise, distortion analysis")
    parser.add_argument('-dcir', action='store_true', dest='dump_circuit', help='dump_circuit.')
    parser.add_argument('-ac', action='store_true', dest='do_ac', help='Output AC analysis.')
    parser.add_argument('-dc', action='store_true', dest='do_dc', help='Output DC bias points.')
    parser.add_argument('-pz', action='store_true', dest='do_pz', help='Output poles and zeros.')
    parser.add_argument('-n', action='store_true', dest='do_noise', help='Output noise analysis.')
    parser.add_argument('-dh', action='store_true', dest='do_distoh', help='Output harmonic distortion analysis.')
    parser.add_argument('-ds', action='store_true', dest='do_distos', help='Output spectral distortion analysis.')
    args = parser.parse_args()
    if args.dump_circuit:
        dump_circuit()
    if args.do_ac:
        do_ac_analysis()
    if args.do_dc:
        do_dc_analysis()
    if args.do_pz:
        do_pz_analysis()
    if args.do_noise:
        do_noise_analysis()
    if args.do_distoh:
        do_distortion_analysis(None)
    if args.do_distos:
        do_distortion_analysis(0.9)
</file>

<file path="examples/analyses/pole_zero_analysis.py">
#! /usr/bin/env python3
#skip#
####################################################################################################
# Program to test pole-zero function of ngspice, PySpice
import argparse
####################################################################################################
import math
import numpy as np
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
####################################################################################################
from PySpice.Spice.Netlist import Circuit, SubCircuit
class NodeNames:
    """Allow setting of nodes with appropriate names."""
    def __init__(self, *args):
        for arg in args:
            setattr(self, arg, arg)
def test_simple():
    circuit = Circuit('pole-zero test circuit')
    n = NodeNames('input', 'output')
    com = 0
    circuit.R('1', n.input, n.output, 1e4)
    circuit.C('1', n.input, n.output, 1e-6)
    circuit.R('2', n.output, com, 1000)
    circuit.C('2', n.output, com, 1e-6)
    circuit.L('1', n.output, com, 1e-3)
    print("circuit",circuit)
    simulator = circuit.simulator(temperature=25, nominal_temperature=25)
    analysis = simulator.polezero(n.input,com, n.output,com, 'vol', 'pz')
    print("Poles")
    for n in analysis.nodes:
        if not n.startswith('pole'): continue
        pole = np.array(analysis[n])
        print(pole)
    print("Zeros")
    for n in analysis.nodes:
        if not n.startswith('zero'): continue
        zero = np.array(analysis[n])
        print(zero)
if __name__ == '__main__':
    logger = Logging.setup_logging()
    parser = argparse.ArgumentParser("Test pyspice pole-zero function")
    parser.add_argument('-ts', action='store_true', dest='t_simple', help='Test simple rlc network.')
    args=parser.parse_args()
    if args.t_simple: test_simple()
</file>

<file path="examples/analyses/test_pole_zero.cir">
.title Pole Zero Test
R1 1 2 10000
C1 1 2 1e-6
R2 2 0 1000
C2 2 0 1e-6
L1 2 0 1e-3
*
*.options noacct
.control
pz  1 0 2 0 vol pz
print all
</file>

<file path="examples/basic-usages/index.rst">
==============
 Basic Usages
==============

This section contains examples showing basic usages.

.. end
</file>

<file path="examples/basic-usages/netlist-manipulations.py">
#r# =======================
#r#  Netlist Manipulations
#r# =======================
#r# This example shows how to manipulate netlist.
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Spice.Netlist import Circuit, SubCircuitFactory
from PySpice.Unit import *
####################################################################################################
class SubCircuit1(SubCircuitFactory):
    NAME = 'sub_circuit1'
    NODES = ('n1', 'n2')
    def __init__(self):
        super().__init__()
        self.R(1, 'n1', 'n2', 1@u_Ω)
        self.R(2, 'n1', 'n2', 2@u_Ω)
#r# Let define a circuit.
circuit = Circuit('Test')
#r# When we add an element to a circuit, we can get a reference to it or ignore it:
C1 = circuit.C(1, 0, 1, 1@u_uF)
circuit.C(2, 1, 2, 2@u_uF)
circuit.subcircuit(SubCircuit1())
circuit.X('1', 'sub_circuit1', 2, 0)
#r# We can get back an element of a circuit using its name, either as a class attribute or using the
#r# dictionary interface:
C1 = circuit.C1
C1 = circuit['C1']
#r# and modify it
C1.capacitance = 10@u_F
#r# To get the SPICE netlist of a citcuit, we just have to convert it to a string:
print(circuit) # str(circuit) is implicit here
#r# same apply to an element
print(C1)
#r# We can disable an element in the circuit
C1.enabled = False
print(circuit)
#r# We can clone a circuit to another one
circuit2 = circuit.clone(title='A clone') # title is optional
print(circuit2)
#r# We can remove an element
C2 = circuit2.C2.detach()
print(circuit2)
</file>

<file path="examples/basic-usages/raw-spice.py">
#r# =========================================
#r#  Pass Raw Spice Definitions to a Netlist
#r# =========================================
#Fixme: to be documented, improved
#r# This example shows how to pass raw spice definitions to a netlist.
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
#r# Let define a circuit.
circuit = Circuit('Test')
#r# Pass raw Spice definitions to a circuit, aka netlist, content is inserted at the beginning of
#r# the netlist.
circuit.raw_spice = '''
Vinput in 0 10V
R1 in out 9kOhm
'''
#r# Pass element parameters as raw Spice, content is concatenated with `R2 out 0`
circuit.R(2, 'out', 0, raw_spice='1k')
print(circuit)
#o#
</file>

<file path="examples/basic-usages/subcircuit.py">
#r# =======================
#r#  How to Use SubCircuit
#r# =======================
#r# This example shows how to use subcircuits.
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Spice.Netlist import Circuit, SubCircuit, SubCircuitFactory
from PySpice.Unit import *
####################################################################################################
#r# There is two ways to define subcircuit with PySpice, either using
#r# :class:`PySpice.Spice.Netlist.SubCircuit` or a simpler alternative
#r# :class:`PySpice.Spice.Netlist.SubCircuitFactory`.
#r#
#r# Let define a parallel resistor subcircuit using the :class:`PySpice.Spice.Netlist.SubCircuitFactory`
class ParallelResistor(SubCircuitFactory):
    NAME = 'parallel_resistor'
    NODES = ('n1', 'n2')
    def __init__(self, R1=1@u_Ω, R2=2@u_Ω):
        super().__init__()
        self.R(1, 'n1', 'n2', R1)
        self.R(2, 'n1', 'n2', R2)
#r# Let define a circuit
circuit = Circuit('Test')
#r# then we can use this subcircuit like this
circuit.subcircuit(ParallelResistor(R2=3@u_Ω))
circuit.X('1', 'parallel_resistor', 1, circuit.gnd)
print(circuit)
#o#
#r# If the above way is not suited for your purpose we can use this second approach
class ParallelResistor2(SubCircuit):
    NODES = ('n1', 'n2')
    def __init__(self, name, R1=1@u_Ω, R2=2@u_Ω):
        SubCircuit.__init__(self, name, *self.NODES)
        self.R(1, 'n1', 'n2', R1)
        self.R(2, 'n1', 'n2', R2)
circuit = Circuit('Test')
circuit.subcircuit(ParallelResistor2('pr1', R2=2@u_Ω))
circuit.X('1', 'pr1', 1, circuit.gnd)
circuit.subcircuit(ParallelResistor2('pr2', R2=3@u_Ω))
circuit.X('2', 'pr2', 1, circuit.gnd)
print(circuit)
#o#
</file>

<file path="examples/basic-usages/unit.py">
#r# This example shows how to use units
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Spice.Netlist import Circuit
####################################################################################################
from PySpice.Unit import *
foo = kilo(1) # unit less
resistance_unit = U_Ω
resistance1 = u_kΩ(1)
resistance1 = u_kOhm(1) # ASCII variant
resistance1 = 1@u_kΩ   # using Python 3.5 syntax
resistance1 = 1 @u_kΩ  # space doesn't matter
resistance1 = 1 @ u_kΩ #
resistance2 = as_Ω(resistance1) # check unit
resistances = u_kΩ(range(1, 11)) # same as [u_kΩ(x) for x in range(1, 11)]
resistances = range(1, 11)@u_kΩ  # using Python 3.5 syntax
capacitance = u_uF(200)
inductance = u_mH(1)
temperature = u_Degree(25)
voltage = resistance1 * u_mA(1) # compute unit
frequency = u_ms(20).frequency
period = u_Hz(50).period
pulsation = frequency.pulsation
pulsation = period.pulsation
#r# According to the Python `operator precedence
#r# <https://docs.python.org/3/reference/expressions.html#operator-precedence>`_, division operators
#r# have a higher priority than the matrix multiplication operator.  In consequence you must had
#r# parenthesis to perform something like :code:`(10@u_s) / (2@_us)`.
####################################################################################################
circuit = Circuit('Resistor Bridge')
resistance = 10@u_kΩ
print(float(resistance))
print(str(resistance))
circuit.V('input', 1, circuit.gnd, 10@u_V)
circuit.R(1, 1, 2, 2@u_kΩ)
circuit.R(2, 1, 3, 1@u_kΩ)
circuit.R(3, 2, circuit.gnd, 1@u_kΩ)
circuit.R(4, 3, circuit.gnd, 2@u_kΩ)
circuit.R(5, 3, 2, 2@u_kΩ)
print(circuit)
####################################################################################################
import pint
u = pint.UnitRegistry()
resistance = 10*u.kΩ
# print(float(resistance))
print(resistance.magnitude)
print(resistance.m)
print(resistance.units)
print(str(resistance))
circuit = Circuit('Resistor Bridge')
circuit.V('input', 1, circuit.gnd, 10*u.V)
circuit.R(1, 1, 2, 2*u.kΩ)
circuit.R(2, 1, 3, 1*u.kΩ)
circuit.R(3, 2, circuit.gnd, 1*u.kΩ)
circuit.R(4, 3, circuit.gnd, 2*u.kΩ)
circuit.R(5, 3, 2, 2*u.kΩ)
print(circuit)
</file>

<file path="examples/data-analysis/fft.py">
####################################################################################################
#r#
#r# ========================
#r#  Fast Fourier Transform
#r# ========================
#r#
#r# This example shows how to compute a FFT of a signal using the scipy Scientific Python package.
#r#
####################################################################################################
import numpy as np
from scipy import signal
from scipy.fftpack import fft
import matplotlib.pyplot as plt
####################################################################################################
#r#
#r# We will first compute the spectrum of the sum of two sinusoidal waveforms.
#r#
N = 1000 # number of sample points
dt = 1. / 500 # sample spacing
frequency1 = 50.
frequency2 = 80.
t = np.linspace(0.0, N*dt, N)
y = np.sin(2*np.pi * frequency1 * t) + .5 * np.sin(2*np.pi * frequency2 * t)
yf = fft(y)
tf = np.linspace(.0, 1./(2.*dt), N//2)
spectrum = 2./N * np.abs(yf[0:N//2])
figure1, ax = plt.subplots(figsize=(20, 10))
ax.plot(tf, spectrum, 'o-')
ax.grid()
for frequency in frequency1, frequency2:
    ax.axvline(x=frequency, color='red')
ax.set_title('Spectrum')
ax.set_xlabel('Frequency [Hz]')
ax.set_ylabel('Amplitude')
#f# save_figure('figure1', 'fft-sum-of-sin.png')
####################################################################################################
#r#
#r# Now we will compute the spectrum of a square waveform.
#r#
#r# The Fourier series is given by:
#r#
#r# .. math::
#r#
#r#   \frac{4}{\pi} \sum_{n=1, 3, 5, \ldots}^{\inf} \frac{1}{n} \sin(n 2\pi f t)
#r#
N = 1000 # number of sample points
dt = 1. / 1000 # sample spacing
frequency = 5.
t = np.linspace(.0, N*dt, N)
y = signal.square(2*np.pi*frequency*t)
figure2, (ax1, ax2) = plt.subplots(2, figsize=(20, 10))
ax1.plot(t, y)
y_sum = None
for n in range(1, 20, 2):
    yn = 4/(np.pi*n)*np.sin((2*np.pi*n*frequency*t))
    if y_sum is None:
        y_sum = yn
    else:
        y_sum += yn
    if n in (1, 3, 5):
        ax1.plot(t, y_sum)
ax1.plot(t, y_sum)
ax1.set_xlim(0, 2/frequency)
ax1.set_ylim(-1.5, 1.5)
yf = fft(y)
tf = np.linspace(.0, 1./(2.*dt), N//2)
spectrum = 2./N * np.abs(yf[0:N//2])
ax2.plot(tf, spectrum)
n = np.arange(1, 20, 2)
ax2.plot(n*frequency, 4/(np.pi*n), 'o', color='red')
ax2.grid()
ax2.set_title('Spectrum')
ax2.set_xlabel('Frequency [Hz]')
ax2.set_ylabel('Amplitude')
#f# save_figure('figure2', 'fft-square-waveform.png')
####################################################################################################
plt.show()
</file>

<file path="examples/diode/m4/diode-characteristic-curve-circuit-ac.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
define(`bigdiode',
  `resized(2., `diode', $1)')
Origin: Here
  ground; dot;
  source(up_ elen, AC); llabel(,V_{in},); dot; "in" above
  resistor(right_ elen); llabel(,R_1,) dot; "out" above
  bigdiode(down_ elen); llabel(,D_1,)
  line down epsilon then to Origin then up epsilon
.PE
</file>

<file path="examples/diode/m4/diode-characteristic-curve-circuit-pulse.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
define(`bigdiode',
  `resized(2., `diode', $1)')
Origin: Here
  ground; dot;
  source(up_ elen, P); llabel(,V_{in},); dot; "in" above
  resistor(right_ elen); llabel(,R_1,) dot; "out" above
  bigdiode(down_ elen); llabel(,D_1,)
  line down epsilon then to Origin then up epsilon
.PE
</file>

<file path="examples/diode/m4/diode-characteristic-curve-circuit.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
define(`bigdiode',
  `resized(2., `diode', $1)')
Origin: Here
  ground; dot;
  source(up_ elen, V); llabel(,V_{in},); dot; "in" above
  resistor(right_ elen); llabel(,R_1,) dot; "out" above
  bigdiode(down_ elen); llabel(,D_1,)
  line down epsilon then to Origin then up epsilon
.PE
</file>

<file path="examples/diode/m4/full-wave-rectification.m4">
.PS
cct_init(SIdefaults)
ifdef(`m4pco',`resetrgb')

linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2

Origin: Here
  T: source(up_ elen, AC) ; llabel(,V_{in},); "in" above
  bridge_len = dimen_/2
  W: T.centre + (dimen_/2,0)
  N: W + (bridge_len,  bridge_len)
  S: W + (bridge_len, -bridge_len)
  E: S + (bridge_len,  bridge_len)
    diode(from W to N)
    diode(from S to E)
  R: resistor(from E + (dimen_,0) down_ dimen_); llabel(+,R_{load},-) # ; "out" above
  C: capacitor(down_ R.start.y - R.end.y from 0.5 between E and R.start, C+); rlabel(,C,)

  setrgb(1,0,0) # red
    dot(at T.end)
    dot(at C.start)
    line from T.end to (N,T.end) then to N; dot
    diode(to E); dot
    line from E to R.start; dot
  resetrgb

  setrgb(0,1,0) # green
    dot(at C.end)
    dot(at R.end)
    ground
    line to (W,Here) then to W; dot
    diode(to S); dot
    line to (Here,T.start) then to T.start; dot
  resetrgb

.PE
</file>

<file path="examples/diode/m4/half-wave-rectification.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
define(`bigdiode',
  `resized(2., `diode', $1)')
Origin: Here
  ground; dot
  source(up_ elen, AC); llabel(,V_{in},); dot; "in" above
  bigdiode(right_ elen); llabel(,D,); dot
  { capacitor(down_ elen, C+); llabel(,C,) dot }
  line right_ dimen_; dot; "out" above
  resistor(down_ elen); llabel(,R,); b_current(i)
  line to Origin
.PE
</file>

<file path="examples/diode/m4/voltage-multiplier-circuit.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
define(`bigdiode',
  `resized(2., `diode', $1)')
Ground: Here
  ground; dot
  source(up_ elen, AC); llabel(,V_{in},); dot; "in" above
  capacitor(right_ elen); llabel(,C1,); dot; "1" above
  bigdiode(down_ elen); rlabel(,D1,)
  { line left_ elen }
  capacitor(right_ elen); rlabel(,C2,); dot; "2" below
   bigdiode(up_ elen); llabel(,D2,)
  { line left_ elen }
  capacitor(right_ elen); llabel(,C3,); dot; "3" above
  bigdiode(down_ elen); rlabel(,D3,)
  { line left_ elen }
  capacitor(right_ elen); rlabel(,C4,); dot; "4" below
  bigdiode(up_ elen); llabel(,D4,)
  { line left_ elen }
.PE
</file>

<file path="examples/diode/m4/zener-diode-characteristic-curve-circuit.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
define(`bigdiode',
  `resized(2., `diode', $1, S)')
Origin: Here
  ground; dot;
  source(up_ elen, V); llabel(,V_{in},); dot; "in" above
  resistor(right_ elen); llabel(,R_1,) dot; "out" above
  bigdiode(down_ elen); llabel(,Dz_1,)
  line down epsilon then to Origin then up epsilon
.PE
</file>

<file path="examples/diode/tex/diode.tex">
\documentclass[crop,tikz,convert={outext=.svg,command=\unexpanded{pdf2svg \infile\space\outfile}},multi=false]{standalone}

% \usepackage{tikz}
% \usepackage[europeanresistors,americaninductors]{circuitikz}
\usetikzlibrary{calc,decorations.pathreplacing,arrows.meta}

\renewcommand{\familydefault}{\sfdefault}

% \pgfrealjobname{}

\begin{document}
\def\DiodeH{1}
\def\DiodeW{2}
\def\DiodePinLength{1.5}
% \beginpgfgraphicnamed{}
\begin{tikzpicture}[]
  \begin{scope}[local bounding box=scope1]
    \draw[fill,color=gray!20] (-\DiodeW,-\DiodeH) rectangle (0,\DiodeH);
    \draw[fill,color=gray!40] (0,-\DiodeH) rectangle (\DiodeW,\DiodeH);
    \draw (-\DiodeW*2/3,0) node {P};
    \draw ( \DiodeW*2/3,0) node {N};
    \foreach \i in {-2,...,2} {
      \foreach \j in {.25,.7} {
        \node[draw,circle,inner sep=0pt] at (-\j,\i*\DiodeH/2.5) {$-$};
        \node[draw,circle,inner sep=0pt] at ( \j,\i*\DiodeH/2.5) {$+$};
      }
      \foreach \j in {1.25,2} {
        \node[anchor=west] at (-\j,\i*\DiodeH/2.5) {\tiny $+$};
        \node[anchor=east] at ( \j,\i*\DiodeH/2.5) {\tiny $-$};
      }
    }
    \draw[decorate, decoration=brace] (-1,\DiodeH*1.2) -- (1,\DiodeH*1.2);
    \node[anchor=south] at (0,\DiodeH*1.2) {Depletion Region};
    \foreach \i in {-1,1} {
      \draw[line width=1mm] (\i*\DiodeW,-\DiodeH) -- (\i*\DiodeW,\DiodeH);
      \draw[fill] (\i*\DiodeW,-\DiodeH/4) -- (\i*\DiodeW,\DiodeH/4) -- (\i*\DiodeW+\i*\DiodeW/10, 0) -- cycle;
      \draw[line width=.5mm] (\i*\DiodeW,0) -- +(\i*\DiodePinLength,0);
    }
    \node[anchor=north west] at (-\DiodeW-\DiodePinLength,0) {Cathode};
    \node[anchor=north east] at ( \DiodeW+\DiodePinLength,0) {Anode};
  \end{scope}
  \begin{scope}[shift={(0,-2.5*\DiodeH)}]
    \draw[fill] (-\DiodeW/2,-\DiodeH) -- (-\DiodeW/2,\DiodeH) -- (0,0) -- cycle;
    \draw[fill] (0,-\DiodeH) rectangle (.1,\DiodeH);
    \coordinate (Cc) at (-\DiodeW+.25*\DiodePinLength,0);
    \coordinate (Ca) at (\DiodeW-.25*\DiodePinLength,0);
    \draw[line width=.5mm,<-,>={Latex[length=15pt,inset=0pt]}] (-\DiodeW-.7*\DiodePinLength,-1.5\DiodeH)
    -- node[anchor=north] {$U$} (\DiodeW+.7*\DiodePinLength,-1.5\DiodeH);
    \draw[line width=.5mm] (-\DiodeW-.7*\DiodePinLength,0) -- (\DiodeW+.7*\DiodePinLength,0);
    \node[anchor=south east] at (Cc) {$i$};
    \draw[line width=.5mm,->,>={Latex[length=10pt,inset=0pt]}] (-\DiodeW-.7*\DiodePinLength,0) -- (Cc);
    \node[anchor=south west] at (Ca) {$e-$};
    \draw[line width=.5mm,->,>={Latex[length=10pt,inset=0pt]}] (\DiodeW+.7*\DiodePinLength,0) -- (Ca);
  \end{scope}
\end{tikzpicture}%}
% \endpgfgraphicnamed

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: ""
%%% End:
</file>

<file path="examples/diode/diode-characteristic-curve.py">
#r# This example shows how to simulate and plot the characteristic curve of a diode.
#r#
#r# Theory
#r# ------
#r# A diode is a semiconductor device made of a PN junction which is a sandwich of two doped silicon
#r# layers.
#f# tikz('diode.tex', width=500)
#r# Before two explains the purpose of the silicon doping.  We will give a quick and simplified look
#r# on the atomic world.  An atom is made of the same number of protons and electrons, this number
#r# is so called Z and characterise the atom.  Each electron is coupled to the proton's kernel by
#r# the electromagnetic interaction, but with different levels of energy.  The reason is due to the
#r# fact each electron screens each other.  There is thus some electrons which are strongly coupled
#r# and other ones which are weakly coupled, so called valence's electrons.  An atom is a neutral
#r# object when we observe it at a large distance, but when the pressure and temperature of the
#r# environment match some conditions, the weakly coupled electrons can be shared with atoms in the
#r# neighbourhood and create the electromagnetic interaction between atoms which make the cohesion
#r# of the matter.
#r#
#r# Depending on the weakness of the electrons, an atom can be an insulated material or a conductor.
#r# Semiconductors are between them.
#r#
#r# The doping consists to diffuse a small quantities of atoms with a larger or smaller number of
#r# valence electron in a silicon layer.  Since a silicon atom has four valence electrons, we use
#r# atoms having 3 or 5 valence electrons for the doping.  A doping using a larger number of valence
#r# electrons is called N for negative, and P respectively.  In a silicon lattice doped with atoms
#r# having a larger number of valence electrons, the additional electrons do not participate to the
#r# lattice cohesion and are weakly coupled to the atoms.  The conductivity is thus improved.  In
#r# other hands, a silicon lattice doped with atoms having a smaller number of valence electrons,
#r# some electrons are missing for the lattice cohesion.  These missing electrons are called holes
#r# since the P doping atoms will catch free electrons so as to normalise the lattice cohesion.
#r#
#r# When we make a sandwich of P and N doped silicon layers, the weak electrons of the N layer
#r# diffuse to the P layer until an equilibrium state is achieved.  Indeed this diffusion creates a
#r# depletion region which acts as a barrier to the electrons, since a P doping atom becomes negative
#r# (anion) when it catches an electron and reciprocally a N doping atom becomes positive (cation)
#r# when it lost an electron.  The depletion region is thus a kind of capacitor.
#r#
#r# The volume of the depletion region can be changed by applying a tension across the PN junction.
#r# If the tension between the PN junction is negative then the depletion region is enlarged, and
#r# only a very small current can flow through the junction due to the thermal agitation.  But if we
#r# apply a positive tension, the depletion region is pressurised, and if it reaches a threshold, an
#r# electron flow will be able to pass through the junction.
#r#
#r# A PN junction can thus only conduct a current from the anode to the cathode and only if a
#r# minimal bias tension is applied across it.
#r#
#r# However if a large enough inverse tension is applied to the junction then the electrostatic
#r# force will become sufficiently large enough to pull off electrons across the junction and the
#r# current will flow from the cathode to the anode. This effect is called breakdown.
#r#
#r# Simulation
#r# ----------
####################################################################################################
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Spice.Netlist import Circuit
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Unit import *
from PySpice.Physics.SemiConductor import ShockleyDiode
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
#r# For this purpose, we use the common high-speed diode 1N4148.  The diode is driven by a variable
#r# voltage source through a limiting current resistance.
#f# circuit_macros('diode-characteristic-curve-circuit.m4')
circuit = Circuit('Diode Characteristic Curve')
circuit.include(spice_library['1N4148'])
circuit.V('input', 'in', circuit.gnd, 10@u_V)
circuit.R(1, 'in', 'out', 1@u_Ω) # not required for simulation
circuit.X('D1', '1N4148', 'out', circuit.gnd)
#r# We simulate the circuit at these temperatures: 0, 25 and 100 °C.
# Fixme: Xyce ???
temperatures = [0, 25, 100]@u_Degree
analyses = {}
for temperature in temperatures:
    simulator = circuit.simulator(temperature=temperature, nominal_temperature=temperature)
    analysis = simulator.dc(Vinput=slice(-2, 5, .01))
    analyses[float(temperature)] = analysis
####################################################################################################
#r# We plot the characteristic curve and compare it to the Shockley diode model:
#r#
#r# .. math::
#r#
#r#     I_d = I_s \left( e^{\frac{V_d}{n V_T}} - 1 \right)
#r#
#r# where :math:`V_T = \frac{k T}{q}`
#r#
#r# In order to scale the reverse biased region, we have to do some hack with Matplotlib.
#r#
silicon_forward_voltage_threshold = .7
shockley_diode = ShockleyDiode(Is=4e-9, degree=25)
def two_scales_tick_formatter(value, position):
    if value >= 0:
        return '{} mA'.format(value)
    else:
        return '{} nA'.format(value/100)
formatter = ticker.FuncFormatter(two_scales_tick_formatter)
figure, (ax1, ax2) = plt.subplots(2, figsize=(20, 10))
ax1.set_title('1N4148 Characteristic Curve ')
ax1.set_xlabel('Voltage [V]')
ax1.set_ylabel('Current')
ax1.grid()
ax1.set_xlim(-2, 2)
ax1.axvspan(-2, 0, facecolor='green', alpha=.2)
ax1.axvspan(0, silicon_forward_voltage_threshold, facecolor='blue', alpha=.1)
ax1.axvspan(silicon_forward_voltage_threshold, 2, facecolor='blue', alpha=.2)
ax1.set_ylim(-500, 750) # Fixme: round
ax1.yaxis.set_major_formatter(formatter)
Vd = analyses[25].out
# compute scale for reverse and forward region
forward_region = Vd >= 0@u_V
reverse_region = np.invert(forward_region)
scale =  reverse_region*1e11 + forward_region*1e3
#?# check temperature
for temperature in temperatures:
    analysis = analyses[float(temperature)]
    ax1.plot(Vd, - analysis.Vinput * scale)
ax1.plot(Vd, shockley_diode.I(Vd) * scale, 'black')
ax1.legend(['@ {} °C'.format(temperature)
            for temperature in temperatures] + ['Shockley Diode Model Is = 4 nA'],
           loc=(.02,.8))
ax1.axvline(x=0, color='black')
ax1.axhline(y=0, color='black')
ax1.axvline(x=silicon_forward_voltage_threshold, color='red')
ax1.text(-1, -100, 'Reverse Biased Region', ha='center', va='center')
ax1.text( 1, -100, 'Forward Biased Region', ha='center', va='center')
#r# Now we compute and plot the static and dynamic resistance.
#r#
#r# .. math::
#r#
#r#   \frac{d I_d}{d V_d} = \frac{1}{n V_T}(I_d + I_s)
#r#
#r# .. math::
#r#
#r#   r_d = \frac{d V_d}{d I_d} \approx \frac{n V_T}{I_d}
ax2.set_title('Resistance @ 25 °C')
ax2.grid()
ax2.set_xlim(-2, 3)
ax2.axvspan(-2, 0, facecolor='green', alpha=.2)
ax2.axvspan(0, silicon_forward_voltage_threshold, facecolor='blue', alpha=.1)
ax2.axvspan(silicon_forward_voltage_threshold, 3, facecolor='blue', alpha=.2)
analysis = analyses[25]
static_resistance = -analysis.out / analysis.Vinput
dynamic_resistance = np.diff(-analysis.out) / np.diff(analysis.Vinput)
ax2.semilogy(analysis.out, static_resistance, basey=10)
ax2.semilogy(analysis.out[10:-1], dynamic_resistance[10:], basey=10)
ax2.axvline(x=0, color='black')
ax2.axvline(x=silicon_forward_voltage_threshold, color='red')
ax2.axhline(y=1, color='red')
ax2.text(-1.5, 1.1, 'R limitation = 1 Ω', color='red')
ax2.legend(['{} Resistance'.format(x) for x in ('Static', 'Dynamic')], loc=(.05,.2))
ax2.set_xlabel('Voltage [V]')
ax2.set_ylabel('Resistance [Ω]')
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'diode-characteristic-curve.png')
#r# We observe the forward voltage threshold increase with the temperature.
#?# #r# Indeed the thermal agitation overcome the electron flow.
</file>

<file path="examples/diode/diode-recovery-time.py">
#r# This example illustrates the diode recovery time and the capacitive behaviour of a PN junction.
# Fixme: Split the plots ? Add some explanations at the end
####################################################################################################
import numpy as np
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
#r# Let define some parameters
dc_offset = 1@u_V
ac_amplitude = 100@u_mV
####################################################################################################
#r# We will first compute some quiescent points and the corresponding dynamic resistance.
#f# circuit_macros('diode-characteristic-curve-circuit.m4')
#r# Since this circuit is equivalent to a voltage divider, we can write the following relation :
#r#
#r# .. math::
#r#
#r#     V_{out} = \frac{Z_d}{R_1 + Z_d} V_{in}
#r#
#r# where :math:`Z_d` is the diode impedance.
circuit = Circuit('Diode')
circuit.include(spice_library['BAV21'])
# Fixme: Xyce: Device model BAV21: Illegal parameter(s) given for level 1 diode: IKF
source = circuit.V('input', 'in', circuit.gnd, dc_offset)
circuit.R(1, 'in', 'out', 1@u_kΩ)
circuit.D('1', 'out', circuit.gnd, model='BAV21')
quiescent_points = []
for voltage in (dc_offset - ac_amplitude, dc_offset, dc_offset + ac_amplitude):
    source.dc_value = voltage
    simulator = circuit.simulator(temperature=25, nominal_temperature=25)
    analysis = simulator.operating_point()
    # Fixme: handle unit
    quiescent_voltage = float(analysis.out)
    quiescent_current = - float(analysis.Vinput)
    quiescent_points.append(dict(voltage=voltage,
                                 quiescent_voltage=quiescent_voltage,
                                 quiescent_current=quiescent_current))
    print("Quiescent Point {:.1f} mV {:.1f} mA".format(quiescent_voltage*1e3, quiescent_current*1e3))
#o#
dynamic_resistance = ((quiescent_points[ 0]['quiescent_voltage'] -
                       quiescent_points[-1]['quiescent_voltage'])
                      /
                      (quiescent_points[ 0]['quiescent_current'] -
                       quiescent_points[-1]['quiescent_current']))
#?# print("Dynamic Resistance = {:.1f} Ω".format(dynamic_resistance))
#?# #o#
#r# We found a dynamic resistance of @<@dynamic_resistance:.1f@>@ Ω.
####################################################################################################
#r#
#r# We will now drive the diode with a sinusoidal source and perform an AC analysis.
#f# circuit_macros('diode-characteristic-curve-circuit-ac.m4')
circuit = Circuit('Diode')
circuit.include(spice_library['BAV21'])
circuit.SinusoidalVoltageSource('input', 'in', circuit.gnd,
                   dc_offset=dc_offset, offset=dc_offset,
                   amplitude=ac_amplitude)
R = circuit.R(1, 'in', 'out', 1@u_kΩ)
circuit.D('1', 'out', circuit.gnd, model='BAV21')
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.ac(start_frequency=10@u_kHz, stop_frequency=1@u_GHz, number_of_points=10,  variation='dec')
#r# Let plot the voltage across the diode and the dynamic resistance as a function of the frequency.
figure, (ax1, ax2, ax3)  = plt.subplots(ncols=3, figsize=(20, 10))
# Fixme: handle unit in plot (scale and legend)
ax1.semilogx(analysis.frequency, np.absolute(analysis.out)*1e3)
ax1.grid(True)
ax1.grid(True, which='minor')
ax1.set_xlabel("Frequency [Hz]")
ax1.set_ylabel("Vd [mV]")
current = (analysis['in'] - analysis.out) / float(R.resistance)
ax2.semilogx(analysis.frequency, np.absolute(analysis.out/current))
ax2.grid(True)
ax2.grid(True, which='minor')
ax2.set_xlabel("Frequency [Hz]")
ax2.set_ylabel('Rd [Ω]')
####################################################################################################
#r# We will now drive the diode with a pulse generator and perform a transient analysis.
#f# circuit_macros('diode-characteristic-curve-circuit-pulse.m4')
frequency = 1@u_MHz
circuit = Circuit('Diode')
circuit.include(spice_library['BAV21'])
# source = circuit.SinusoidalVoltageSource('input', 'in', circuit.gnd,
#                             dc_offset=dc_offset, offset=dc_offset,
#                             amplitude=ac_amplitude,
#                             frequency=frequency)
source = circuit.PulseVoltageSource('input', 'in', circuit.gnd,
                       initial_value=dc_offset-ac_amplitude, pulsed_value=dc_offset+ac_amplitude,
                       pulse_width=frequency.period/2, period=frequency.period)
circuit.R(1, 'in', 'out', 1@u_kΩ)
circuit.D('1', 'out', circuit.gnd, model='BAV21')
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=source.period/1e3, end_time=source.period*4)
# Fixme: axis, x scale
# plot(analysis['in'] - dc_offset + quiescent_points[0]['quiescent_voltage'])
# plot(analysis.out)
ax3.plot(analysis.out.abscissa*1e6, analysis.out)
ax3.legend(('Vin [V]', 'Vout [V]'), loc=(.8,.8))
ax3.grid()
ax3.set_xlabel('t [μs]')
ax3.set_ylabel('[V]')
# ax3.set_ylim(.5, 1 + ac_amplitude + .1)
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'diode-recovery-time.png')
#r# We notice the output of the circuit cannot follow the pulse generator.  It is due to the
#r# capacitive behaviour of a PN junction that cut off the highest frequencies of the pulse.  The
#r# plot of the dynamic resistance as a function of the frequency show a typical low pass filter
#r# behaviour where the impedance drop at high frequencies.
</file>

<file path="examples/diode/index.rst">
========
 Diode
========

This section contains examples based on diodes.

.. end
</file>

<file path="examples/diode/rectification.py">
#r# This example depicts half and full wave rectification.
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
figure1, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(20, 10))
####################################################################################################
circuit = Circuit('half-wave rectification')
circuit.include(spice_library['1N4148'])
source = circuit.SinusoidalVoltageSource('input', 'in', circuit.gnd, amplitude=10@u_V, frequency=50@u_Hz)
circuit.X('D1', '1N4148', 'in', 'output')
circuit.R('load', 'output', circuit.gnd, 100@u_Ω)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=source.period/200, end_time=source.period*2)
ax1.set_title('Half-Wave Rectification')
ax1.set_xlabel('Time [s]')
ax1.set_ylabel('Voltage [V]')
ax1.grid()
ax1.plot(analysis['in'])
ax1.plot(analysis.output)
ax1.legend(('input', 'output'), loc=(.05,.1))
ax1.set_ylim(float(-source.amplitude*1.1), float(source.amplitude*1.1))
####################################################################################################
#f# circuit_macros('half-wave-rectification.m4')
circuit.C('1', 'output', circuit.gnd, 1@u_mF)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=source.period/200, end_time=source.period*2)
ax2.set_title('Half-Wave Rectification with filtering')
ax2.set_xlabel('Time [s]')
ax2.set_ylabel('Voltage [V]')
ax2.grid()
ax2.plot(analysis['in'])
ax2.plot(analysis.output)
ax2.legend(('input', 'output'), loc=(.05,.1))
ax2.set_ylim(float(-source.amplitude*1.1), float(source.amplitude*1.1))
####################################################################################################
circuit = Circuit('half-wave rectification')
circuit.include(spice_library['1N4148'])
source = circuit.SinusoidalVoltageSource('input', 'in', circuit.gnd, amplitude=10, frequency=50)
circuit.X('D1', '1N4148', 'in', 'output_plus')
circuit.R('load', 'output_plus', 'output_minus', 100@u_Ω)
circuit.X('D2', '1N4148', 'output_minus', circuit.gnd)
circuit.X('D3', '1N4148', circuit.gnd, 'output_plus')
circuit.X('D4', '1N4148', 'output_minus', 'in')
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=source.period/200, end_time=source.period*2)
ax3.set_title('Full-Wave Rectification')
ax3.set_xlabel('Time [s]')
ax3.set_ylabel('Voltage [V]')
ax3.grid()
ax3.plot(analysis['in'])
ax3.plot(analysis.output_plus - analysis.output_minus)
ax3.legend(('input', 'output'), loc=(.05,.1))
ax3.set_ylim(float(-source.amplitude*1.1), float(source.amplitude*1.1))
####################################################################################################
#f# circuit_macros('full-wave-rectification.m4')
circuit.C('1', 'output_plus', 'output_minus', 1@u_mF)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=source.period/200, end_time=source.period*2)
ax4.set_title('Full-Wave Rectification with filtering')
ax4.set_xlabel('Time [s]')
ax4.set_ylabel('Voltage [V]')
ax4.grid()
ax4.plot(analysis['in'])
ax4.plot(analysis.output_plus - analysis.output_minus)
ax4.legend(('input', 'output'), loc=(.05,.1))
ax4.set_ylim(float(-source.amplitude*1.1), float(source.amplitude*1.1))
plt.tight_layout()
#f# save_figure('figure1', 'rectification.png')
####################################################################################################
circuit = Circuit('115/230V Rectifier')
circuit.include(spice_library['1N4148'])
on_115 = True # switch to select 115 or 230V
if on_115:
    node_230 = circuit.gnd
    node_115 = 'node_115'
    amplitude = 115@u_V
else:
    node_230 = 'node_230'
    node_115 = circuit.gnd
    amplitude = 230@u_V
source = circuit.SinusoidalVoltageSource('input', 'in', circuit.gnd, amplitude=amplitude, frequency=50) # Fixme: rms
circuit.X('D1', '1N4148', 'in', 'output_plus')
circuit.X('D3', '1N4148', node_230, 'output_plus')
circuit.X('D2', '1N4148', 'output_minus', node_230)
circuit.X('D4', '1N4148', 'output_minus', 'in')
circuit.C('1', 'output_plus', node_115, 1@u_mF)
circuit.C('2', node_115, 'output_minus', 1@u_mF)
circuit.R('load', 'output_plus', 'output_minus', 10@u_Ω)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
if on_115:
    simulator.initial_condition(node_115=0)
analysis = simulator.transient(step_time=source.period/200, end_time=source.period*2)
figure2, ax = plt.subplots(figsize=(20, 10))
ax.set_title('115/230V Rectifier')
ax.set_xlabel('Time [s]')
ax.set_ylabel('Voltage [V]')
ax.grid()
ax.plot(analysis['in'])
ax.plot(analysis.output_plus - analysis.output_minus)
ax.legend(('input', 'output'), loc=(.05,.1))
# ax.set_ylim(float(-source.amplitude*1.1), float(source.amplitude*1.1))
plt.tight_layout()
#f# save_figure('figure2', 'universal-rectifier.png')
plt.show()
</file>

<file path="examples/diode/ring-modulator.py">
#r# This example depicts a ring modulator
#r## .. warning:: It don't simulate
#r#
#r##   doAnalyses: TRAN:  Timestep too small; time = 5.5453e-08, timestep = 1.25e-18: trouble with xring_modulator.xd2:1n4148-instance d.xring_modulator.xd2.d1
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
from RingModulator import RingModulator
#f# literal_include('RingModulator.py')
####################################################################################################
circuit = Circuit('Ring Modulator')
modulator = circuit.SinusoidalVoltageSource('modulator', 'in', circuit.gnd, amplitude=1@u_V, frequency=1@u_kHz)
carrier = circuit.SinusoidalVoltageSource('carrier', 'carrier', circuit.gnd, amplitude=10@u_V, frequency=100@u_kHz)
circuit.R('in', 'in', 1, 50@u_Ω)
circuit.R('carrier', 'carrier', 2, 50@u_Ω)
circuit.include(spice_library['1N4148'])
circuit.subcircuit(RingModulator(outer_inductance=1@u_uH,
                                 inner_inductance=1@u_uH,
                                 coupling=.99,
                                 diode_model='1N4148',
                             ))
circuit.X('ring_modulator', 'RingModulator',
          1, circuit.gnd,
          2, circuit.gnd,
          'output', circuit.gnd,
         )
# outer_inductance = .01
# inner_inductance = .0025
# coupling = .9
# diode_model = '1N4148'
# input_inductor = circuit.L('input', 1, circuit.gnd, outer_inductance)
# top_inductor = circuit.L('input_top', 'input_top', 'carrier', inner_inductance)
# bottom_inductor = circuit.L('input_bottom', 'input_bottom', 'carrier', inner_inductance)
# circuit.CoupledInductor('input_top', input_inductor.name, top_inductor.name, coupling)
# circuit.CoupledInductor('input_bottom', input_inductor.name, bottom_inductor.name, coupling)
# circuit.X('D1', diode_model, 'input_top', 'output_top')
# circuit.X('D2', diode_model, 'output_top', 'input_bottom')
# circuit.X('D3', diode_model, 'input_bottom', 'output_bottom')
# circuit.X('D4', diode_model, 'output_bottom', 'input_top')
# top_inductor = circuit.L('output_top', 'output_top', circuit.gnd, inner_inductance)
# bottom_inductor = circuit.L('output_bottom', 'output_bottom', circuit.gnd, inner_inductance)
# output_inductor = circuit.L('output', 'output', circuit.gnd, outer_inductance)
# circuit.CoupledInductor('output_top', output_inductor.name, top_inductor.name, coupling)
# circuit.CoupledInductor('output_bottom', output_inductor.name, bottom_inductor.name, coupling)
circuit.R('load', 'output', circuit.gnd, 1@u_kΩ)
### simulator = circuit.simulator(temperature=25, nominal_temperature=25)
### # simulator.initial_condition(input_top=0, input_bottom=0, output_top=0, output_bottom=0)
### analysis = simulator.transient(step_time=modulator.period/1000, end_time=modulator.period)
###
### figure = plt.figure(1, (20, 10))
### plt.title('Ring Modulator')
### plt.xlabel('Time [s]')
### plt.ylabel('Voltage [V]')
### plt.grid()
### plot(analysis['Vmodulator'])
### plot(analysis['Vcarrier'])
### # plot(analysis['output'])
### plt.legend(('modulator', 'carrier', 'output'), loc=(.05,.1))
####################################################################################################
plt.show()
</file>

<file path="examples/diode/RingModulator.py">
####################################################################################################
from PySpice.Spice.Netlist import SubCircuitFactory
from PySpice.Unit import *
####################################################################################################
class RingModulator(SubCircuitFactory):
    NAME = 'RingModulator'
    NODES = ('input_plus', 'input_minus',
             'carrier_plus', 'carrier_minus',
             'output_plus', 'output_minus')
    ##############################################
    def __init__(self,
                 outer_inductance,
                 inner_inductance,
                 coupling,
                 diode_model,
                ):
        super().__init__()
        input_inductor = self.L('input', 'input_plus', 'input_minus', outer_inductance)
        top_inductor = self.L('input_top', 'input_top', 'carrier_plus', inner_inductance)
        bottom_inductor = self.L('input_bottom', 'carrier_plus', 'input_bottom', inner_inductance)
        self.CoupledInductor('input_top', input_inductor.name, top_inductor.name, coupling)
        self.CoupledInductor('input_bottom', input_inductor.name, bottom_inductor.name, coupling)
        self.X('D1', diode_model, 'input_top', 'output_top')
        self.X('D2', diode_model, 'output_top', 'input_bottom')
        self.X('D3', diode_model, 'input_bottom', 'output_bottom')
        self.X('D4', diode_model, 'output_bottom', 'input_top')
        top_inductor = self.L('output_top', 'output_top', 'carrier_minus', inner_inductance)
        bottom_inductor = self.L('output_bottom', 'carrier_minus', 'output_bottom', inner_inductance)
        output_inductor = self.L('output', 'output_plus', 'output_minus', outer_inductance)
        self.CoupledInductor('output_top', output_inductor.name, top_inductor.name, coupling)
        self.CoupledInductor('output_bottom', output_inductor.name, bottom_inductor.name, coupling)
</file>

<file path="examples/diode/voltage-multiplier.py">
#r# This example depicts a voltage multiplier using diodes and capacitors.  To go further, you can
#r# read this `page <http://en.wikipedia.org/wiki/Voltage_multiplier>`_ on Wikipedia.
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
#f# circuit_macros('voltage-multiplier-circuit.m4')
circuit = Circuit('Voltage Multiplier')
circuit.include(spice_library['1N4148'])
source = circuit.SinusoidalVoltageSource('input', 'in', circuit.gnd, amplitude=10@u_V, frequency=50@u_Hz)
multiplier = 5
for i in range(multiplier):
    if i:
        top_node = i - 1
    else:
        top_node = 'in'
    midlle_node, bottom_node = i + 1, i
    circuit.C(i, top_node, midlle_node, 1@u_mF)
    circuit.X(i, '1N4148', midlle_node, bottom_node)
circuit.R(1, multiplier, multiplier+1, 1@u_MΩ)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=source.period/200, end_time=source.period*20)
####################################################################################################
figure, ax = plt.subplots(figsize=(20, 10))
ax.set_title('Voltage Multiplier')
ax.set_xlabel('Time [s]')
ax.set_ylabel('Voltage [V]')
ax.grid()
# Fixme: axis vs axe ...
ax.plot(analysis['in'])
for i in range(1, multiplier+1):
    y = analysis[str(i)]
    if i & 1: # for odd multiplier the ground is permuted
        y -= analysis['in']
    ax.plot(y)
# ax.axhline(-multiplier*source.amplitude)
ax.set_ylim(float(-multiplier*1.1*source.amplitude), float(1.1*source.amplitude))
ax.legend(['input'] + ['*' + str(i) for i in range(1, multiplier+1)] ,
          loc=(.2,.8))
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'voltage-multiplier.png')
</file>

<file path="examples/diode/zener-characteristic-curve.py">
#r# This example shows how to simulate and plot the characteristic curve of a Zener diode.
####################################################################################################
import numpy as np
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Spice.Netlist import Circuit
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
#f# circuit_macros('zener-diode-characteristic-curve-circuit.m4')
circuit = Circuit('Diode DC Curve')
circuit.include(spice_library['1N4148'])
# 1N5919B: 5.6 V, 3.0 W Zener Diode Voltage Regulator
circuit.include(spice_library['d1n5919brl'])
circuit.V('input', 'in', circuit.gnd, 10@u_V)
circuit.R(1, 'in', 'out', 1@u_Ω) # not required for simulation
# circuit.X('D1', '1N4148', 'out', circuit.gnd)
circuit.X('DZ1', 'd1n5919brl', 'out', circuit.gnd)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.dc(Vinput=slice(-10, 2, .05)) # 10mV
figure, (ax1, ax2) = plt.subplots(2, figsize=(20, 10))
zener_part = analysis.out <= -5.4@u_V
# compute derivate
# fit linear part
ax1.grid()
# Fixme: scale
ax1.plot(analysis.out, -analysis.Vinput*1000)
ax1.axvline(x=0, color='black')
ax1.axvline(x=-5.6, color='red')
ax1.axvline(x=1, color='red')
ax1.legend(('Diode curve',), loc=(.1,.8))
ax1.set_xlabel('Voltage [V]')
ax1.set_ylabel('Current [mA]')
ax2.grid()
# Fixme:
# U = RI   R = U/I
dynamic_resistance = np.diff(-analysis.out) / np.diff(analysis.Vinput)
# ax2.plot(analysis.out[:-1], dynamic_resistance/1000)
ax2.semilogy(analysis.out[10:-1], dynamic_resistance[10:], basey=10)
ax2.axvline(x=0, color='black')
ax2.axvline(x=-5.6, color='red')
ax2.legend(('Dynamic Resistance',), loc=(.1,.8))
ax2.set_xlabel('Voltage [V]')
ax2.set_ylabel('Dynamic Resistance [Ohm]')
# coefficients = np.polyfit(analysis.out[zener_part], dynamic_resistance[zener_part], deg=1)
# x = np.array((min(analysis.out[zener_part]), max(analysis.out[zener_part])))
# y = coefficients[0]*x + coefficients[1]
# axe.semilogy(x, y, 'red')
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'zener-characteristic-curve.png')
</file>

<file path="examples/electricity/three-phase.py">
####################################################################################################
#r#
#r# =================================================
#r#  Three-phased Current: Y and Delta configurations
#r# =================================================
#r#
#r# This examples shows the computation of the voltage for the Y and Delta configurations.
#r#
####################################################################################################
import math
import numpy as np
import matplotlib.pyplot as plt
####################################################################################################
from PySpice.Unit import *
####################################################################################################
#r# Let use an European 230 V / 50 Hz electric network.
frequency = 50@u_Hz
w = frequency.pulsation
period = frequency.period
rms_mono = 230
amplitude_mono = rms_mono * math.sqrt(2)
#r# The phase voltages in Y configuration are dephased of :math:`\frac{2\pi}{3}`:
#r#
#r# .. math::
#r#  V_{L1 - N} = V_{pp} \cos \left( \omega t \right) \\
#r#  V_{L2 - N} = V_{pp} \cos \left( \omega t - \frac{2\pi}{3} \right) \\
#r#  V_{L3 - N} = V_{pp} \cos \left( \omega t - \frac{4\pi}{3} \right)
#r#
#r# We rewrite them in complex notation:
#r#
#r# .. math::
#r#  V_{L1 - N} = V_{pp} e^{j\omega t} \\
#r#  V_{L2 - N} = V_{pp} e^{j \left(\omega t - \frac{2\pi}{3} \right) } \\
#r#  V_{L3 - N} = V_{pp} e^{j \left(\omega t - \frac{4\pi}{3} \right) }
t = np.linspace(0, 3*float(period), 1000)
L1 = amplitude_mono * np.cos(t*w)
L2 = amplitude_mono * np.cos(t*w - 2*math.pi/3)
L3 = amplitude_mono * np.cos(t*w - 4*math.pi/3)
#r# From these expressions, we compute the voltage in delta configuration using trigonometric identities :
#r#
#r# .. math::
#r#   V_{L1 - L2} = V_{L1} \sqrt{3} e^{j \frac{\pi}{6} } \\
#r#   V_{L2 - L3} = V_{L2} \sqrt{3} e^{j \frac{\pi}{6} } \\
#r#   V_{L3 - L1} = V_{L3} \sqrt{3} e^{j \frac{\pi}{6} }
#r#
#r# In comparison to the Y configuration, the voltages in delta configuration are magnified by
#r# a factor :math:`\sqrt{3}` and dephased of :math:`\frac{\pi}{6}`.
#r#
#r# Finally we rewrite them in temporal notation:
#r#
#r# .. math::
#r#  V_{L1 - L2} = V_{pp} \sqrt{3} \cos \left( \omega t + \frac{\pi}{6} \right) \\
#r#  V_{L2 - L3} = V_{pp} \sqrt{3} \cos \left( \omega t - \frac{\pi}{2} \right) \\
#r#  V_{L3 - L1} = V_{pp} \sqrt{3} \cos \left( \omega t - \frac{7\pi}{6} \right)
rms_tri = math.sqrt(3) * rms_mono
amplitude_tri = rms_tri * math.sqrt(2)
L12 = amplitude_tri * np.cos(t*w + math.pi/6)
L23 = amplitude_tri * np.cos(t*w - math.pi/2)
L31 = amplitude_tri * np.cos(t*w - 7*math.pi/6)
#r# Now we plot the waveforms:
figure, ax = plt.subplots(figsize=(20, 10))
ax.plot(
    t, L1, t, L2, t, L3,
    t, L12, t, L23, t, L31,
    # t, L1-L2, t, L2-L3, t, L3-L1,
)
ax.grid()
ax.set_title('Three-phase electric power: Y and Delta configurations (230V Mono/400V Tri 50Hz Europe)')
ax.legend(
    ('L1-N', 'L2-N', 'L3-N',
     'L1-L2', 'L2-L3', 'L3-L1'),
    loc=(.7,.5),
)
ax.set_xlabel('t [s]')
ax.set_ylabel('[V]')
ax.axhline(y=rms_mono, color='blue')
ax.axhline(y=-rms_mono, color='blue')
ax.axhline(y=rms_tri, color='blue')
ax.axhline(y=-rms_tri, color='blue')
plt.show()
#f# save_figure('figure', 'three-phase.png')
</file>

<file path="examples/filter/m4/low-pass-rc-filter.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
Origin: Here
  ground; dot;
  source(up_ elen, AC); llabel(,V_{in},); dot; "in" above
  resistor(right_ elen); llabel(,R_1,) dot; "out" above
  capacitor(down_ elen); llabel(,C_1,)
  line down epsilon then to Origin then up epsilon
.PE
</file>

<file path="examples/filter/m4/low-pass-rlc-filter.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
Origin: Here
  ground; dot;
  source(up_ elen, AC); llabel(,V_{in},); dot; "in" above
  resistor(right_ dimen_); llabel(,R_1,)
  inductor(right_ dimen_); llabel(,L_1,) dot; "out" ljust
  capacitor(down_ elen); llabel(,C_1,)
  line down epsilon then to Origin then up epsilon
.PE
</file>

<file path="examples/filter/m4/pass-band-rlc-filter.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
Origin: Here
  ground; dot;
  source(up_ elen, AC); llabel(,V_{in},); dot; "in" above
  inductor(right_ dimen_); llabel(,L_1,)
  capacitor(right_ dimen_); llabel(,C_1,) dot; "out" ljust
  resistor(down_ elen); llabel(,R_1,)
  line down epsilon then to Origin then up epsilon
.PE
</file>

<file path="examples/filter/low-pass-rc-filter.py">
#r# This example shows a low-pass RC Filter.
####################################################################################################
import math
import numpy as np
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Plot.BodeDiagram import bode_diagram
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
#f# circuit_macros('low-pass-rc-filter.m4')
circuit = Circuit('Low-Pass RC Filter')
circuit.SinusoidalVoltageSource('input', 'in', circuit.gnd, amplitude=1@u_V)
R1 = circuit.R(1, 'in', 'out', 1@u_kΩ)
C1 = circuit.C(1, 'out', circuit.gnd, 1@u_uF)
#r# The break frequency is given by :math:`f_c = \frac{1}{2 \pi R C}`
break_frequency = 1 / (2 * math.pi * float(R1.resistance * C1.capacitance))
print("Break frequency = {:.1f} Hz".format(break_frequency))
#o#
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.ac(start_frequency=1@u_Hz, stop_frequency=1@u_MHz, number_of_points=10,  variation='dec')
# print(analysis.out)
#r# We plot the Bode diagram.
figure, axes = plt.subplots(2, figsize=(20, 10))
plt.title("Bode Diagram of a Low-Pass RC Filter")
bode_diagram(axes=axes,
             frequency=analysis.frequency,
             gain=20*np.log10(np.absolute(analysis.out)),
             phase=np.angle(analysis.out, deg=False),
             marker='.',
             color='blue',
             linestyle='-',
)
for ax in axes:
    ax.axvline(x=break_frequency, color='red')
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'low-pass-rc-filter-bode-diagram.png')
</file>

<file path="examples/filter/rlc-filter.py">
#r# ============
#r#  RLC Filter
#r# ============
#r# This example illustrates RLC Filters.
####################################################################################################
import math
import numpy as np
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Plot.BodeDiagram import bode_diagram
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
#r# We define four low-pass RLC filters with the following factor of quality: .5, 1, 2 and 4.
#f# circuit_macros('low-pass-rlc-filter.m4')
circuit1 = Circuit('Four double-pole Low-Pass RLC Filter')
inductance = 10@u_mH
capacitance = 1@u_uF
circuit1.SinusoidalVoltageSource('input', 'in', circuit1.gnd, amplitude=1@u_V)
#?# pulse 0 5 10 ms
# Q = .5
circuit1.R(1, 'in', 1, 200@u_Ω)
circuit1.L(1, 1, 'out5', inductance)
circuit1.C(1, 'out5', circuit1.gnd, capacitance)
# Q = 1
circuit1.R(2, 'in', 2, 100@u_Ω)
circuit1.L(2, 2, 'out1', inductance)
circuit1.C(2, 'out1', circuit1.gnd, capacitance)
# Q = 2
circuit1.R(3, 'in', 3, 50@u_Ω)
circuit1.L(3, 3, 'out2', inductance)
circuit1.C(3, 'out2', circuit1.gnd, capacitance)
# Q = 4
R4 = circuit1.R(4, 'in', 4, 25@u_Ω)
circuit1.L(4, 4, 'out4', inductance)
circuit1.C(4, 'out4', circuit1.gnd, capacitance)
#r# We perform an AC analysis.
simulator1 = circuit1.simulator(temperature=25, nominal_temperature=25)
analysis1 = simulator1.ac(start_frequency=100@u_Hz, stop_frequency=10@u_kHz, number_of_points=100,  variation='dec')
#r# The resonant frequency is given by
#r#
#r# .. math::
#r#
#r#     f_0 = 2 \pi \omega_0 = \frac{1}{2 \pi \sqrt{L C}}
#r#
#r# and the factor of quality by
#r#
#r# .. math::
#r#
#r#     Q = \frac{1}{R} \sqrt{\frac{L}{C}} = \frac{1}{RC \omega_0}
#r#
resonant_frequency = 1 / (2 * math.pi * math.sqrt(inductance * capacitance))
quality_factor = 1 / R4.resistance * math.sqrt(inductance / capacitance)
print("Resonant frequency = {:.1f} Hz".format(resonant_frequency))
print("Factor of quality = {:.1f}".format(quality_factor))
#o#
#r# We plot the Bode diagram of the four filters.
figure, axes = plt.subplots(2, figsize=(20, 10))
plt.title("Bode Diagrams of RLC Filters")
for out in ('out5', 'out1', 'out2', 'out4'):
    bode_diagram(axes=axes,
                 frequency=analysis1.frequency,
                 gain=20*np.log10(np.absolute(analysis1[out])),
                 phase=np.angle(analysis1[out], deg=False),
                 marker='.',
                 color='blue',
                 linestyle='-',
    )
for axe in axes:
    axe.axvline(x=resonant_frequency, color='red')
####################################################################################################
#r# We define a pass-band RLC filter with a quality's factor of 4.
#f# circuit_macros('pass-band-rlc-filter.m4')
circuit2 = Circuit('Pass-Band RLC Filter')
circuit2.SinusoidalVoltageSource('input', 'in', circuit2.gnd, amplitude=1@u_V)
circuit2.L(1, 'in', 2, inductance)
circuit2.C(1, 2, 'out', capacitance)
circuit2.R(1, 'out', circuit2.gnd, 25@u_Ω)
simulator2 = circuit2.simulator(temperature=25, nominal_temperature=25)
analysis2 = simulator2.ac(start_frequency=100@u_Hz, stop_frequency=10@u_kHz, number_of_points=100,  variation='dec')
bode_diagram(axes=axes,
             frequency=analysis2.frequency,
             gain=20*np.log10(np.absolute(analysis2.out)),
             phase=np.angle(analysis2.out, deg=False),
             marker='.',
             color='magenta',
             linestyle='-',
            )
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'rlc-filter-bode-diagram.png')
</file>

<file path="examples/fundamental-laws/m4/current-divider.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
Origin: Here
  line right_ elen*1/2;
  {
    # simpler way ?
    arrow right arrowht from Origin + (elen*1/4,0) "$I_{in}$" above
  }
  {
    dot;
    resistor(down_ elen,,E); rlabel(,R_1,)
    dot;
  }
  line right_ elen*1/2 then down epsilon
  resistor(down_ elen,,E); llabel(,R_2,); b_current(I_{out})
  line down epsilon then left_ elen
.PE
</file>

<file path="examples/fundamental-laws/m4/millman-theorem-with-current-source.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
dnl Xsection(i, 1 to don't show dot, 1 to show A node)
define(`Vsection', `
  ifelse(eval($2!=1), 1, `dot')
  ifelse(eval($3==1), 1, `dot; "A" above')
  resistor(down_ elen,,E); llabel(,R_`$1',)
  reversed(`source', down_ elen,V); llabel(,V_`$1',)
  ifelse(eval($2!=1), 1, `dot')
 ')
define(`Isection', `
  ifelse(eval($2!=1), 1, `dot')
  ifelse(eval($3==1), 1, `dot; "A" above')
  resistor(down_ elen,,E); llabel(,R_`$1',)
  reversed(`source', down_ elen,I); llabel(,I_`$1',)
  ifelse(eval($2!=1), 1, `dot')
 ')

Origin: Here
  for_(1, 3, 1, `
    ifelse(eval(m4x!=1), 1, `line up epsilon then right_ elen')
    { Vsection(m4x, m4x, 0) }
  ')
  line dotted right_ elen
  { Vsection(i, 0, 0) }
  line dotted right_ elen
  Isection(k, 1, 1)
line down epsilon then to (Origin.x, Here.y) then up epsilon
.PE
</file>

<file path="examples/fundamental-laws/m4/millman-theorem.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
dnl tsection(i, 1 to don't show dot, 1 to show A node)
define(`tsection', `
  ifelse(eval($2!=1), 1, `dot')
  ifelse(eval($3==1), 1, `dot; "A" above')
  resistor(down_ elen,,E); llabel(,R_`$1',)
  reversed(`source', down_ elen,V); llabel(,V_`$1',)
  ifelse(eval($2!=1), 1, `dot')
 ')

Origin: Here
  for_(1, 3, 1, `
    ifelse(eval(m4x!=1), 1, `line up epsilon then right_ elen')
    { tsection(m4x, m4x, 0) }
  ')
  line dotted right_ elen
  tsection(i, 1, 1)
  line down epsilon then to (Origin.x, Here.y) then up epsilon
.PE
</file>

<file path="examples/fundamental-laws/m4/thevenin-norton-theorem.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
T: Here
  source(up_ elen, V); llabel(,V_{th},)
  line up_ epsilon then right_ epsilon
  resistor(right_ elen,,E); llabel(,R_{th},)
  dot; "A" above
  resistor(down_ elen,,E); llabel(,R_{load},)
  dot; "B" below
Tse: Here
  line to T then up epsilon
[
N: Here
  source(up_ elen, I); llabel(,I_{no},)
  line up_ epsilon then right_ elen/2
  {dot; resistor(down_ elen,,E); llabel(,R_{no},); dot}
  line right_ elen
  dot; "A" above
  resistor(down_ elen,,E); llabel(,R_{load},)
  dot; "B" below
  line to N then up epsilon
] with .sw at Tse + (elen*3/2,0)
.PE
</file>

<file path="examples/fundamental-laws/m4/voltage-divider.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
Origin: Here
  dot; "in" above
  resistor(right_ elen,,E); llabel(,R_1,); dot; "out" above
  resistor(down_ elen,,E); llabel(,R_2,)
  line down epsilon then left_ elen; dot
.PE
</file>

<file path="examples/fundamental-laws/index.rst">
This section discusses the fundamental laws of electronics.

Kirchhoff's circuit laws
------------------------

Kirchhoff's circuit laws are two equalities that constrain the current and voltage in electrical
circuits under some approximations.

Kirchhoff's current law (KCL) says at any node in an electrical circuit, the sum of currents flowing
into that node is equal to the sum of currents flowing out of that node:

.. math::

  \sum_{k=1}^n {I}_k = 0

This law is in fact a general principle of flux conservation.

Kirchhoff's voltage law (KVL) says that the sum of the branch's voltage along a closed path in the
network is null:

.. math::

  \sum_{k=1}^n {V}_k = 0

Kirchhoff's circuit laws are used by Spice to evaluate the voltages and currents in a circuit.

To go further on theses equalities, you can read online the section `22-3 of the Feynman Lectures on
Physics, Volume II <http://www.feynmanlectures.caltech.edu/II_22.html#Ch22-S3>`_.

.. http://en.wikipedia.org/wiki/Kirchhoff%27s_circuit_laws

Ohm's Law
---------

The Ohm's law is a simple model of a resistor which say that the current I flowing through a
resistor is proportional to the voltage U applied across it, this constant is called the resistance
(R).

.. math::

   U = R I

You will observe the same phenomenon with a pipe filled with water, the water's flow is proportional
to the declination of the pipe, more you incline the pipe, more you pressure the water within the
pipe.  Electron act as water and voltage as pressure.

In reality, the resistance depends of the temperature of the material, like many device parameters.
It is why we always simulate a circuit at a given temperature.

This law is important in circuit analysis, because it is a first approximation of any dipole for a
particular current and voltage.  Indeed we can approximate any curve locally by a linear relation.
If we know the current and voltage of a dipole under some conditions then we can approximate the
rate of change under a small variation of the current or voltage.  Spice uses this principle to
evalute a circuit at different times.

.. http://en.wikipedia.org/wiki/Ohm%27s_law

.. capacitor and inductor
.. superposition theorem

.. end
</file>

<file path="examples/fundamental-laws/millman-theorem.py">
####################################################################################################
#r# ===================
#r#  Millman's theorem
#r# ===================
#r#
#r# Millman's theorem is a method to compute the voltage of a node in such circuits:
#f# circuit_macros('millman-theorem.m4')
#r# The voltage at node A is:
#r#
#r# .. math::
#r#
#r#     V_A = \frac{\sum \frac{V_i}{R_i}}{\sum \frac{1}{R_i}}
#r#
#r# We can extend this theorem to branches with current sources:
#r#
#r# .. math::
#r#
#r#     V_A = \frac{\sum \frac{V_i}{R_i} + \sum I_k}{\sum \frac{1}{R_i}}
#r#
#r# Note voltage sources can be null and resistances in current's branches don't change the denominator.
#f# circuit_macros('millman-theorem-with-current-source.m4')
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
import numpy as np
####################################################################################################
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
circuit = Circuit("Millman's theorem")
number_of_branches = 3
for i in range(1, number_of_branches +1):
    circuit.V('input%u' % i, i, circuit.gnd, i@u_V)
    circuit.R(i, i, 'A', i@u_kΩ)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.operating_point()
node_A = analysis.A
print('Node {}: {:5.2f} V'.format(str(node_A), float(node_A)))
#o#
branch_voltages = np.arange(1, number_of_branches +1)
branch_resistances = branch_voltages * float(kilo(1))
conductances = 1 / branch_resistances
voltage_A = np.sum(branch_voltages * conductances) / np.sum(conductances)
print('V(A) = {:5.2f} V'.format(voltage_A))
#o#
# with current sources
for i in range(1, number_of_branches +1):
    ii = number_of_branches + i
    circuit.I('input%u' % i, circuit.gnd, ii, 100*i@u_uA)
    circuit.R(ii, ii, 'A', i@u_kΩ)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.operating_point()
node_A = analysis.A
print('Node {}: {:5.2f} V'.format(str(node_A), float(node_A)))
#o#
branch_currents = np.arange(1, number_of_branches +1) * float(micro(100))
voltage_A += np.sum(branch_currents) / np.sum(conductances)
print('V(A) = {:5.2f} V'.format(voltage_A))
#o#
</file>

<file path="examples/fundamental-laws/thevenin-norton-theorem.py">
####################################################################################################
#r# ============================
#r#  Thévenin and Norton Theorem
#r# ============================
#r# The Thévenin's theorem holds that:
#r#
#r#  * Any linear electrical network with voltage and current sources and only resistances can be
#r#    replaced at terminals A-B by an equivalent voltage source Vth in series connection with an
#r#    equivalent resistance Rth.
#r#
#r#  * This equivalent voltage Vth is the voltage obtained at terminals A-B of the network with
#r#    terminals A-B open circuited.
#r#
#r#  * This equivalent resistance Rth is the resistance obtained at terminals A-B of the network
#r#    with all its independent current sources open circuited and all its independent voltage
#r#    sources short circuited.
#r#
#r# The Norton's theorem holds that:
#r#
#r#  * Any linear electrical network with voltage and current sources and only resistances can be
#r#    replaced at terminals A-B by an equivalent current source INO in parallel connection with an
#r#    equivalent resistance Rno.
#r#
#r#  * This equivalent current Ino is the current obtained at terminals A-B of the network with
#r#    terminals A-B short circuited.
#r#
#r#  * This equivalent resistance Rno is the resistance obtained at terminals A-B of the network
#r#    with all its voltage sources short circuited and all its current sources open circuited.
#r#
#r# The Norton's theorem is the dual of the Thévenin's therorem and both are related by
#r# these equations:
#r#
#r#  .. math::
#r#
#r#       \begin{align}
#r#         R_{no} & = R_{th} \\
#r#         I_{no} & = V_{th} / R_{th} \\
#r#         V_{th} & = I_{No} R_{no}
#r#       \end{align}
#f# circuit_macros('thevenin-norton-theorem.m4')
#r# In circuit theory terms, these theorems allows any one-port network to be reduced to a single
#r# voltage or current source and a single impedance.
#r#
#r# For AC circuits these theorems can be applied to reactive impedances as well as resistances.
#?# These theorems also applies to frequency domain AC circuits consisting of reactive and resistive
#?# impedances.
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
thevenin_circuit = Circuit('Thévenin Representation')
thevenin_circuit.V('input', 1, thevenin_circuit.gnd, 10@u_V)
thevenin_circuit.R('generator', 1, 'load', 10@u_Ω)
thevenin_circuit.R('load', 'load', thevenin_circuit.gnd, 1@u_kΩ)
simulator = thevenin_circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.operating_point()
load_node = analysis.load
print('Node {}: {:5.2f} V'.format(str(load_node), float(load_node)))
#o#
norton_circuit = Circuit('Norton Representation')
norton_circuit.I('input', norton_circuit.gnd, 'load',
                 thevenin_circuit.Vinput.dc_value/thevenin_circuit.Rgenerator.resistance)
norton_circuit.R('generator', 'load', norton_circuit.gnd, thevenin_circuit.Rgenerator.resistance)
norton_circuit.R('load', 'load', norton_circuit.gnd, thevenin_circuit.Rload.resistance)
simulator = norton_circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.operating_point()
load_node = analysis.load
print('Node {}: {:5.2f} V'.format(str(load_node), float(load_node)))
#o#
</file>

<file path="examples/fundamental-laws/voltage-current-divider.py">
####################################################################################################
#r# =============================
#r#  Voltage and Current Divider
#r# =============================
#r# This circuit is a fundamental block in electronic that permits to scale a voltage by an
#r# impedance ratio:
#f# circuit_macros('voltage-divider.m4')
#r# The relation between the input and ouput voltage is:
#r#
#r# .. math::
#r#
#r#     \frac{V_{out}}{V_{in}} = \frac{R_2}{R_1 + R_2}
#r#
#r# This equation holds for any impedances like resistance, capacitance, inductance, etc.
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
circuit = Circuit('Voltage Divider')
circuit.V('input', 1, circuit.gnd, 10@u_V)
circuit.R(1, 1, 2, 2@u_kΩ)
circuit.R(2, 2, circuit.gnd, 1@u_kΩ)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.operating_point()
for node in analysis.nodes.values():
    print('Node {}: {:5.2f} V'.format(str(node), float(node))) # Fixme: format value + unit
#o#
####################################################################################################
#r# Similarly we can build a circuit that scale a current by an impedance ratio:
#f# circuit_macros('current-divider.m4')
#r# The relation between the input and ouput current is:
#r#
#r# .. math::
#r#
#r#     \frac{I_{out}}{I_{in}} = \frac{R_1}{R_1 + R_2}
#r#
#r# Note the role of R1 and R2 is exchanged.
#r#
#r# This equation holds for any impedances like resistance, capacitance, inductance, etc.
####################################################################################################
circuit = Circuit('Current Divider')
circuit.I('input', 1, circuit.gnd, 1@u_A) # Fixme: current value
circuit.R(1, 1, circuit.gnd, 2@u_kΩ)
circuit.R(2, 1, circuit.gnd, 1@u_kΩ)
for resistance in (circuit.R1, circuit.R2):
    resistance.minus.add_current_probe(circuit) # to get positive value
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.operating_point()
# Fixme: current over resistor
for node in analysis.branches.values():
    print('Node {}: {:5.2f} A'.format(str(node), float(node))) # Fixme: format value + unit
#o#
</file>

<file path="examples/libraries/diode/general-purpose/BAV21.lib">
* -*- spice -*-
* http://www.nxp.com/documents/spice_model/BAV21.prm
*
*******************************************
*
* BAV21
* 
* NXP Semiconductors
* 
* General-purpose diode 
* 
* VRRM = 250V
* IFRM = 625mA   
* trr  = 50ns
* 
* Package pinning does not match Spice model pinning.
* Package: SOD27
* 
* Package Pin 1: Cathode 
* Package Pin 2: Anode
* 
* Simulator: PSPICE
*
*******************************************
*
.MODEL BAV21 D
+ IS=21.910E-9
+ N=2.2330
+ RS=1.0000E-3
+ IKF=19.230E-3
+ CJO=1.0300E-12
+ M=.1001
+ VJ=.75
* + ISR=10.010E-21 * not recognised
+ BV=293.10
+ IBV=1.2930E-3
+ TT=51.940E-9
*
</file>

<file path="examples/libraries/diode/general-purpose/BAV21.lib@xyce">
* -*- spice -*-
* http://www.nxp.com/documents/spice_model/BAV21.prm
*
*******************************************
*
* BAV21
* 
* NXP Semiconductors
* 
* General-purpose diode 
* 
* VRRM = 250V
* IFRM = 625mA   
* trr  = 50ns
* 
* Package pinning does not match Spice model pinning.
* Package: SOD27
* 
* Package Pin 1: Cathode 
* Package Pin 2: Anode
* 
* Simulator: PSPICE
*
*******************************************
*
.MODEL BAV21 D
+ IS=21.910E-9
+ N=2.2330
+ RS=1.0000E-3
* + IKF=19.230E-3
+ CJO=1.0300E-12
+ M=.1001
+ VJ=.75
* + ISR=10.010E-21 * not recognised
+ BV=293.10
+ IBV=1.2930E-3
+ TT=51.940E-9
*
</file>

<file path="examples/libraries/diode/schottky/1N5822.lib">
* -*- spice -*-
* https://www.vishay.com/docs/88003/1n5822.txt
*
**********************************
* Model created by               *
*   Uni.Dipl.-Ing. Arpad Buermen *
*   arpad.burmen@ieee.org        *
* Copyright:                     *
*   Thomatronik GmbH, Germany    *
*   info@thomatronik.de          *
**********************************
* April 2001
*   SPICE3
.subckt 1N5822 1 2
Ddio 1 2 legd
Dgr 1 2 grd
.model legd d is = 2.37487E-007 n = 1.98477 rs = 0.0171579
+ eg = 1.79999 xti = 3.99991
+ cjo = 5.47556E-010 vj = 1.64135 m = 0.603662 fc = 0.5
+ tt = 1.4427E-009 bv = 48.4 ibv = 3.5 af = 1 kf = 0
.model grd d is = 1.27781E-005 n = 1.2149 rs = 0.0250254
+ eg = 0.55507 xti = 0.794212
.ends
</file>

<file path="examples/libraries/diode/switching/1N4148.lib">
* -*- spice -*-
* http://www.nxp.com/documents/spice_model/1N4148.prm
*
*******************************************
*
* 1N4148
* 
* NXP Semiconductors
* 
* High-speed diodes
* 
* VRRM = 100V
* IFRM = 450 mA 
* trr  = 4ns
* 
* Package pinning does not match Spice model pinning.
* Package: SOD 27
* 
* Package Pin 1 : Cathode
* Package Pin 2 : Anode
* 
* Simulator: PSPICE
*
*******************************************
*
.SUBCKT 1N4148 1 2 
*
* The resistor R1 does not reflect 
* a physical device. Instead it
* improves modeling in the reverse 
* mode of operation.
*
R1 1 2 5.827E+9 
D1 1 2 1N4148
*
.MODEL 1N4148 D 
+ IS = 4.352E-9 
+ N = 1.906 
+ BV = 110 
+ IBV = 0.0001 
+ RS = 0.6458 
+ CJO = 7.048E-13 
+ VJ = 0.869 
+ M = 0.03 
+ FC = 0.5 
+ TT = 3.48E-9 
.ENDS
*
</file>

<file path="examples/libraries/diode/zener/1N5919B.lib">
* -*- spice -*-
* http://www.onsemi.com/pub_link/Collateral/1N5919BRL.SP3
.SUBCKT d1n5919brl 2 1
**************************************
*      Model Generated by MODPEX     *
*Copyright(c) Symmetry Design Systems*
*         All Rights Reserved        *
*    UNPUBLISHED LICENSED SOFTWARE   *
*   Contains Proprietary Information *
*      Which is The Property of      *
*     SYMMETRY OR ITS LICENSORS      *
*    Modeling services provided by   *
* Interface Technologies www.i-t.com *
**************************************
* Model generated on Jun 22, 2004
* MODEL FORMAT: SPICE3
*     anode cathode
*node: 2      1
*    Forward Section
D1 2 1 MD1
.MODEL MD1 D IS=1.33275e-21 N=1 XTI=1 RS=0.1
+ CJO=1e-11 TT=1e-08
*    Leakage Current
R 1 2 600000 MDR	
.MODEL MDR R TC1=0 TC2=0
*    Breakdown
RZ 2 3 0.520393
IZG 4 3 0.3204
R4 4 3 100
D3 3 4 MD3
.MODEL MD3 D IS=2.5e-12 N=2.40102 XTI=0 EG=0.1
D2 5 4 MD2
.MODEL MD2 D IS=2.5e-12 N=3.19856 XTI=0 EG=0.1
EV1 1 5 6 0 1
IBV 0 6 0.001
RBV 6 0 5153.19 MDRBV
.MODEL MDRBV R TC1=1.79e-08
*-- SPICE3 DIODE MODEL DEFAULT PARAMETER
*  VALUES ARE ASSUMED
*IS=1E-14 RS=0 N=1 TT=0 CJO=0
*VJ=1 M=0.5 EG=1.11 XTI=3 FC=0.5
*KF=0 AF=1 BV=inf IBV=1e-3 TNOM=27
.ENDS d1n5919brl
</file>

<file path="examples/libraries/mosfet/irf150.lib">
* -*- spice -*-
* http://www.irf.com/product-info/models/spice/irf150.spi
*
.SUBCKT irf150 1 2 3
**************************************
*      Model Generated by MODPEX     *
*Copyright(c) Symmetry Design Systems*
*         All Rights Reserved        *
*    UNPUBLISHED LICENSED SOFTWARE   *
*   Contains Proprietary Information *
*      Which is The Property of      *
*     SYMMETRY OR ITS LICENSORS      *
*Commercial Use or Resale Restricted *
*   by Symmetry License Agreement    *
**************************************
* Model generated on Dec 17, 96
* MODEL FORMAT: SPICE3
* Symmetry POWER MOS Model (Version 1.0)
* External Node Designations
* Node 1 -> Drain
* Node 2 -> Gate
* Node 3 -> Source
M1 9 7 8 8 MM L=100u W=100u
* Default values used in MM:
* The voltage-dependent capacitances are
* not included. Other default values are:
*   RS=0 RD=0 LD=0 CBD=0 CBS=0 CGBO=0
.MODEL MM NMOS LEVEL=1 IS=1e-32
+VTO=4.07861 LAMBDA=0.000761669 KP=19.0218
+CGSO=3.57784e-05 CGDO=4.96221e-07
RS 8 3 0.0216597
D1 3 1 MD
.MODEL MD D IS=2.01865e-09 RS=0.11592 N=1.5 BV=100
+IBV=0.001 EG=1 XTI=1 TT=1e-07
+CJO=3.28974e-09 VJ=4.39387 M=0.659734 FC=0.1
RDS 3 1 3.2e+06
RD 9 1 0.00224103
RG 2 7 12.1
D2 4 5 MD1
* Default values used in MD1:
*   RS=0 EG=1.11 XTI=3.0 TT=0
*   BV=infinite IBV=1mA
.MODEL MD1 D IS=1e-32 N=50
+CJO=3.78329e-09 VJ=0.607074 M=0.893797 FC=1e-08
D3 0 5 MD2
* Default values used in MD2:
*   EG=1.11 XTI=3.0 TT=0 CJO=0
*   BV=infinite IBV=1mA
.MODEL MD2 D IS=1e-10 N=0.402271 RS=3.00001e-06
RL 5 10 1
FI2 7 9 VFI2 -1
VFI2 4 0 0
EV16 10 0 9 7 1
CAP 11 10 3.78329e-09
FI1 7 9 VFI1 -1
VFI1 11 6 0
RCAP 6 10 1
D4 0 6 MD3
* Default values used in MD3:
*   EG=1.11 XTI=3.0 TT=0 CJO=0
*   RS=0 BV=infinite IBV=1mA
.MODEL MD3 D IS=1e-10 N=0.402271
.ENDS irf150
</file>

<file path="examples/libraries/operational-amplifier/LMV981.MOD">
*Rev-B, March-2010
*Modified notes
*
*//////////////////////////////////////////////////////////////////////
* (C) National Semiconductor, Corporation.
* Models developed and under copyright by:
* National Semiconductor, Corporation.  
*/////////////////////////////////////////////////////////////////////
* Legal Notice:  
* The model may be copied, and distributed without any modifications;
* however, reselling or licensing the material is illegal.
* We reserve the right to make changes to the model without prior notice. 
* Pspice Models are provided "AS IS, WITH NO WARRANTY OF ANY KIND" 
*////////////////////////////////////////////////////////////////////
* For more information, and our latest models,
* please visit the models section of our website at
*       http://www.national.com/models/
*////////////////////////////////////////////////////////////////////
* BEGIN LMV981 MODEL
* MODEL TEMPERATURE RANGE IS -40 C TO +125 C, NOT ALL PARAMETERS TRACK THOSE 
* OF THE REAL PART VS TEMPERATURE
* FEATURES:
* OPEN LOOP GAIN AND PHASE, INPUT BIAS CURRENT, INPUT CAPACITANCE
* INPUT COMMON MODE VOLT RANGE, RAIL TO RAIL INPUT STAGE, WITH OFFSET TRANSITION
* INPUT CLAMPS TO RAILS,  CMRR WITH FREQUENCY EFFECTS, PSRR WITH FREQUENCY
* EFFECTS, SLEW RATE, QUIESCENT CURRENT, RAIL TO RAIL OUTPUT STAGE, HIGH CLOAD
* EFFECTS, CLASS AB BIAS IN OUTPUT STAGE, OUTPUT CURRENT THROUGH SUPPLIES
* OUTPUT CURRENT LIMITING, OUTPUT CLAMPS TO RAILS, OUTPUT SWING VS OUTPUT CURRENT
* SHUTDOWN, ENABLE TIME, QUIESCENT CURRENT DURING SHUTDOWN
*///////////////////////////////////////////////////////////////////////////
*
* PINOUT ORDER +IN -IN +V -V OUT NSD
* PINOUT ORDER  1   3   6  2  4   5
.SUBCKT LMV981 1 3 6 2 4 5
Q20 7 8 9 QLN
R3 10 11 2
R4 12 11 2
R10 8 13 1E3
R11 14 15 1E3
R12 16 6 4
R13 2 17 4
R16 18 19 300
R17 20 21 4
R18 9 22 4
D5 23 6 DD
D6 2 23 DD
D7 24 0 DIN
D8 25 0 DIN
I8 0 24 0.1E-3
I9 0 25 0.1E-3
E2 9 0 2 0 1
E3 21 0 6 0 1
D9 26 0 DVN
D10 27 0 DVN
I10 0 26 0.1E-3
I11 0 27 0.1E-3
E4 28 3 26 27 0.08
G2 29 3 24 25 4E-5
R22 2 6 100E6
E5 30 0 21 0 1
E6 31 0 9 0 1
E7 32 0 33 0 1
R30 30 34 1E5
R31 31 35 1E5
R32 32 36 1E5
R33 0 34 10
R34 0 35 10
R35 0 36 10
E10 37 1 36 0 0.3
R36 38 33 1K
R37 33 39 1K
C6 30 34 1E-12
C7 31 35 2E-12
C8 32 36 200E-12
E11 40 37 35 0 1.2
E12 29 40 34 0 0.8
E14 41 9 21 9 0.5
D11 18 21 DD
D12 9 18 DD
M1 42 43 17 17 NOUT L=3U W=700U
M2 44 45 16 16 POUT L=3U W=1400U
M3 46 46 20 20 POUT L=3U W=1400U
M4 47 48 10 10 PIN L=3U W=220U
M5 49 50 12 12 PIN L=3U W=220U
M8 51 51 22 22 NOUT L=3U W=700U
R43 52 45 100
R44 53 43 100
G3 18 41 54 41 0.2E-3
R45 41 18 60E6
C12 19 23 33E-12
R46 9 47 2E3
R47 9 49 2E3
C13 47 49 1E-12
C14 29 0 3E-12
C15 28 0 3E-12
C16 23 0 0.5E-12
D13 43 7 DD
D14 55 45 DD
Q15 55 15 21 QLP
V18 29 56 1E-3
M19 57 58 21 21 PIN L=6U W=500U
E17 39 0 29 0 1
E18 38 0 3 0 1
M23 58 58 21 21 PIN L=6U W=500U
V21 57 11 0
R59 23 44 20
R60 42 23 20
J1 59 29 59 JNC
J2 59 28 59 JNC
J3 28 60 28 JNC
J4 29 60 29 JNC
C21 29 61 1E-12
E20 62 41 49 47 1
R62 62 54 1E4
C23 54 41 5E-12
G7 63 41 18 41 -1E-3
G8 41 64 18 41 1E-3
G9 41 65 51 9 1E-3
G10 66 41 21 46 1E-3
D17 66 63 DD
D18 64 65 DD
R66 63 66 100E6
R67 65 64 100E6
R68 66 21 1E3
R69 9 65 1E3
E23 21 52 21 66 1
E24 53 9 65 9 1
R70 64 41 1E6
R71 65 41 1E6
R72 41 66 1E6
R73 41 63 1E6
G11 6 2 67 0 -0.1E-3
R75 40 29 1E9
R76 37 40 1E9
R77 1 37 1E9
R78 3 28 1E9
R79 41 54 1E9
R81 52 21 1E9
R82 9 53 1E9
R83 33 0 1E9
G14 58 9 67 0 35E-6
G15 46 51 67 0 220E-6
E48 68 18 67 0 30
E49 69 41 67 0 -30
V49 70 69 15
V50 71 68 -15
R127 68 0 1E12
R128 69 0 1E12
M41 41 71 18 72 PSW L=1.5U W=150U
M42 18 70 41 73 NSW L=1.5U
R129 72 0 1E12
R130 73 0 1E12
M43 74 5 9 9 NEN L=3U W=300U
M44 75 76 9 9 NEN L=3U W=3000U
R131 74 21 1E4
R132 75 77 1E6
V51 77 9 1
M45 78 78 21 21 PEN L=6U W=60U
M46 5 78 21 21 PEN L=6U W=60U
I20 78 9 0.2E-6
C26 5 0 1E-12
E50 67 0 79 9 1
V52 75 79 1.111E-6
R133 9 79 1E12
C32 21 74 15E-12
C33 77 75 3F
I21 6 2 0.2E-6
L1 23 4 4E-9
R150 23 4 400
V78 21 59 0.05
V79 60 9 0.05
R155 46 21 1E8
R156 9 51 1E8
R157 17 43 1E8
R158 16 45 1E8
RG1 0 67 1E9
R159 61 28 100
R225 50 28 64
R226 48 56 64
I40 28 0 15E-9
I47 29 0 15E-9
M48 80 81 2 2 NIQS L=3U W=1000
R297 80 6 8E6
E94 81 2 67 0 2
M49 82 74 9 9 NEN L=3U W=300U
M50 76 82 9 9 NEN L=3U W=300U
R298 82 77 1E4
R299 76 77 1E4
C35 77 82 535P
M51 83 84 85 85 NIN L=3U W=220U
M52 86 87 88 88 NIN L=3U W=220U
R300 89 85 2
R301 89 88 2
R302 83 21 2E3
R303 86 21 2E3
C36 83 86 1E-12
G36 18 41 90 41 0.2E-3
R304 41 90 1E9
C37 90 41 5E-12
E97 91 41 86 83 1
R305 91 90 1E4
V115 92 56 0.25E-3
R306 28 87 64
R307 92 84 64
M53 93 94 95 95 PIN L=6U W=500U
R308 95 57 2E3
V116 21 94 1.0
M54 93 93 9 9 NIN L=3U W=500U
M55 89 93 9 9 NIN L=3U W=500U
E98 21 14 6 16 0.9
E99 13 9 17 2 3
.MODEL DVN D KF=8E-12 IS=1E-16
.MODEL DD D
.MODEL DIN D
.MODEL QLN NPN
.MODEL QLP PNP
.MODEL JNC NJF
.MODEL POUT PMOS KP=200U VTO=-0.7
.MODEL NOUT NMOS KP=200U VTO=0.7
.MODEL PIN PMOS KP=200U VTO=-0.7
.MODEL NIN NMOS KP=200U VTO=0.7
.MODEL NIQS NMOS KP=200U VTO=0.7 IS=1E-18
.MODEL NEN NMOS KP=200U VTO=0.5 IS=1E-18
.MODEL PEN PMOS KP=200U VTO=-0.7 IS=1E-18
.MODEL PSW PMOS KP=200U VTO=-7.5 IS=1E-18
.MODEL NSW NMOS KP=200U VTO=7.5 IS=1E-18
.ENDS
* END LMV981 MODEL
</file>

<file path="examples/libraries/transistor/2N2222A.lib">
* -*- spice -*-
*
* http://www.onsemi.com/pub_link/Collateral/2N2222A.SP3.TXT
*
**************************************
*      Model Generated by MODPEX     *
*Copyright(c) Symmetry Design Systems*
*         All Rights Reserved        *
*    UNPUBLISHED LICENSED SOFTWARE   *
*   Contains Proprietary Information *
*      Which is The Property of      *
*     SYMMETRY OR ITS LICENSORS      *
*Commercial Use or Resale Restricted *
*   by Symmetry License Agreement    *
**************************************
* Model generated on Feb 28, 13
* MODEL FORMAT: SPICE3
.MODEL 2n2222a npn
+IS=3.88184e-14 BF=929.846 NF=1.10496 VAF=16.5003
+IKF=0.019539 ISE=1.0168e-11 NE=1.94752 BR=48.4545
+NR=1.07004 VAR=40.538 IKR=0.19539 ISC=1.0168e-11
+NC=4 RB=0.1 IRB=0.1 RBM=0.1
+RE=0.0001 RC=0.426673 XTB=0.1 XTI=1
+EG=1.05 CJE=2.23677e-11 VJE=0.582701 MJE=0.63466
+TF=4.06711e-10 XTF=3.92912 VTF=17712.6 ITF=0.4334
+CJC=2.23943e-11 VJC=0.576146 MJC=0.632796 XCJC=1
+FC=0.170253 CJS=0 VJS=0.75 MJS=0.5
+TR=1e-07 PTF=0 KF=0 AF=1
</file>

<file path="examples/libraries/transistor/ptm_65nm_nmos_bulk.mod">
* Customized PTM 65nm NMOS
*
* This file has been downloaded from the
* Predictive Technology Model (PTM) website
* http://ptm.asu.edu/
* using the "Nano-CMOS" form and using the default values.
*
* It has been slightly modified from its original for compliance
* reasons with the PySpice python module
* (renamed and cleaned of invisible characters causing errors)
* Please refer to the PTM website and the related publications
* for more information about the technology.
*
* This file is provided here for educational purpose
*

.model  ptm65nm_nmos  nmos  level = 54

+version = 4.0    binunit = 1    paramchk= 1    mobmod  = 0
+capmod  = 2      igcmod  = 1    igbmod  = 1    geomod  = 1
+diomod  = 1      rdsmod  = 0    rbodymod= 1    rgatemod= 1
+permod  = 1      acnqsmod= 0    trnqsmod= 0

* parameters related to the technology node
+tnom = 27          epsrox  = 3.9
+eta0 = 0.0058      nfactor = 1.9           wint = 5e-09
+cgso = 1.5e-10     cgdo    = 1.5e-10       xl   = -3e-08

* parameters customized by the user
+toxe = 1.85e-09    toxp = 1.2e-09      toxm = 1.85e-09     toxref = 1.85e-09
+dtox = 6.5e-10     lint = 5.25e-09
+vth0 = 0.429       k1   = 0.497        u0   = 0.04861      vsat   = 124340
+rdsw = 165         ndep = 2.6e+18      xj   = 1.96e-08

* secondary parameters
+ll      = 0            wl      = 0            lln     = 1            wln     = 1
+lw      = 0            ww      = 0            lwn     = 1            wwn     = 1
+lwl     = 0            wwl     = 0            xpart   = 0
+k2      = 0.01         k3      = 0
+k3b     = 0            w0      = 2.5e-006     dvt0    = 1            dvt1    = 2
+dvt2    = -0.032       dvt0w   = 0            dvt1w   = 0            dvt2w   = 0
+dsub    = 0.1          minv    = 0.05         voffl   = 0            dvtp0   = 1.0e-009
+dvtp1   = 0.1          lpe0    = 0            lpeb    = 0
+ngate   = 2e+020       nsd     = 2e+020       phin    = 0
+cdsc    = 0.000        cdscb   = 0            cdscd   = 0            cit     = 0
+voff    = -0.13        etab    = 0
+vfb     = -0.55        ua      = 6e-010       ub      = 1.2e-018
+uc      = 0            a0      = 1.0          ags     = 1e-020
+a1      = 0            a2      = 1.0          b0      = 0            b1      = 0
+keta    = 0.04         dwg     = 0            dwb     = 0            pclm    = 0.04
+pdiblc1 = 0.001        pdiblc2 = 0.001        pdiblcb = -0.005       drout   = 0.5
+pvag    = 1e-020       delta   = 0.01         pscbe1  = 8.14e+008    pscbe2  = 1e-007
+fprout  = 0.2          pdits   = 0.08         pditsd  = 0.23         pditsl  = 2.3e+006
+rsh     = 5            rsw     = 85           rdw     = 85
+rdswmin = 0            rdwmin  = 0            rswmin  = 0            prwg    = 0
+prwb    = 6.8e-011     wr      = 1            alpha0  = 0.074        alpha1  = 0.005
+beta0   = 30           agidl   = 0.0002       bgidl   = 2.1e+009     cgidl   = 0.0002
+egidl   = 0.8

+aigbacc = 0.012        bigbacc = 0.0028       cigbacc = 0.002
+nigbacc = 1            aigbinv = 0.014        bigbinv = 0.004        cigbinv = 0.004
+eigbinv = 1.1          nigbinv = 3            aigc    = 0.012        bigc    = 0.0028
+cigc    = 0.002        aigsd   = 0.012        bigsd   = 0.0028       cigsd   = 0.002
+nigc    = 1            poxedge = 1            pigcd   = 1            ntox    = 1

+xrcrg1  = 12           xrcrg2  = 5
+cgbo    = 2.56e-011    cgdl    = 2.653e-10
+cgsl    = 2.653e-10    ckappas = 0.03         ckappad = 0.03         acde    = 1
+moin    = 15           noff    = 0.9          voffcv  = 0.02

+kt1     = -0.11        kt1l    = 0            kt2     = 0.022        ute     = -1.5
+ua1     = 4.31e-009    ub1     = 7.61e-018    uc1     = -5.6e-011    prt     = 0
+at      = 33000

+fnoimod = 1            tnoimod = 0

+jss     = 0.0001       jsws    = 1e-011       jswgs   = 1e-010       njs     = 1
+ijthsfwd= 0.01         ijthsrev= 0.001        bvs     = 10           xjbvs   = 1
+jsd     = 0.0001       jswd    = 1e-011       jswgd   = 1e-010       njd     = 1
+ijthdfwd= 0.01         ijthdrev= 0.001        bvd     = 10           xjbvd   = 1
+pbs     = 1            cjs     = 0.0005       mjs     = 0.5          pbsws   = 1
+cjsws   = 5e-010       mjsws   = 0.33         pbswgs  = 1            cjswgs  = 3e-010
+mjswgs  = 0.33         pbd     = 1            cjd     = 0.0005       mjd     = 0.5
+pbswd   = 1            cjswd   = 5e-010       mjswd   = 0.33         pbswgd  = 1
+cjswgd  = 5e-010       mjswgd  = 0.33         tpb     = 0.005        tcj     = 0.001
+tpbsw   = 0.005        tcjsw   = 0.001        tpbswg  = 0.005        tcjswg  = 0.001
+xtis    = 3            xtid    = 3

+dmcg    = 0e-006       dmci    = 0e-006       dmdg    = 0e-006       dmcgt   = 0e-007
+dwj     = 0.0e-008     xgw     = 0e-007       xgl     = 0e-008

+rshg    = 0.4          gbmin   = 1e-010       rbpb    = 5            rbpd    = 15
+rbps    = 15           rbdb    = 15           rbsb    = 15           ngcon   = 1
</file>

<file path="examples/libraries/transistor/ptm_65nm_pmos_bulk.mod">
* Customized PTM 65nm PMOS
*
* This file has been downloaded from the
* Predictive Technology Model (PTM) website
* http://ptm.asu.edu/
* using the "Nano-CMOS" form and using the default values.
*
* It has been slightly modified from its original for compliance
* reasons with the PySpice python module
* (renamed and cleaned of invisible characters causing errors)
* Please refer to the PTM website and the related publications
* for more information about the technology.
*
* This file is provided here for educational purpose
*

.model  ptm65nm_pmos  pmos  level = 54

+version = 4.0    binunit = 1    paramchk= 1    mobmod  = 0
+capmod  = 2      igcmod  = 1    igbmod  = 1    geomod  = 1
+diomod  = 1      rdsmod  = 0    rbodymod= 1    rgatemod= 1
+permod  = 1      acnqsmod= 0    trnqsmod= 0

* parameters related to the technology node
+tnom = 27          epsrox  = 3.9
+eta0 = 0.0058      nfactor = 1.9           int = 5e-09
+cgso = 1.5e-10     cgdo    = 1.5e-10       xl  = -3e-08

* parameters customized by the user
+toxe = 1.95e-09    toxp = 1.2e-09      toxm = 1.95e-09     toxref = 1.95e-09
+dtox = 7.5e-10     lint = 5.25e-09
+vth0 = -0.378      k1   = 0.456        u0   = 0.00548      vsat   = 70000
+rdsw = 165         ndep = 1.97e+18     xj   = 1.96e-08

* secondary parameters
+ll      = 0            wl      = 0            lln     = 1            wln     = 1
+lw      = 0            ww      = 0            lwn     = 1            wwn     = 1
+lwl     = 0            wwl     = 0            xpart   = 0
+k2      = -0.01        k3      = 0
+k3b     = 0            w0      = 2.5e-006     dvt0    = 1            dvt1    = 2
+dvt2    = -0.032       dvt0w   = 0            dvt1w   = 0            dvt2w   = 0
+dsub    = 0.1          minv    = 0.05         voffl   = 0            dvtp0   = 1e-009
+dvtp1   = 0.05         lpe0    = 0            lpeb    = 0
+ngate   = 2e+020       nsd     = 2e+020       phin    = 0
+cdsc    = 0.000        cdscb   = 0            cdscd   = 0            cit     = 0
+voff    = -0.126       etab    = 0
+vfb     = 0.55         ua      = 2.0e-009     ub      = 0.5e-018
+uc      = 0            a0      = 1.0          ags     = 1e-020
+a1      = 0            a2      = 1            b0      = -1e-020      b1      = 0
+keta    = -0.047       dwg     = 0            dwb     = 0            pclm    = 0.12
+pdiblc1 = 0.001        pdiblc2 = 0.001        pdiblcb = 3.4e-008     drout   = 0.56
+pvag    = 1e-020       delta   = 0.01         pscbe1  = 8.14e+008    pscbe2  = 9.58e-007
+fprout  = 0.2          pdits   = 0.08         pditsd  = 0.23         pditsl  = 2.3e+006
+rsh     = 5            rsw     = 85           rdw     = 85
+rdswmin = 0            rdwmin  = 0            rswmin  = 0            prwg    = 3.22e-008
+prwb    = 6.8e-011     wr      = 1            alpha0  = 0.074        alpha1  = 0.005
+beta0   = 30           agidl   = 0.0002       bgidl   = 2.1e+009     cgidl   = 0.0002
+egidl   = 0.8

+aigbacc = 0.012        bigbacc = 0.0028       cigbacc = 0.002
+nigbacc = 1            aigbinv = 0.014        bigbinv = 0.004        cigbinv = 0.004
+eigbinv = 1.1          nigbinv = 3            aigc    = 0.69         bigc    = 0.0012
+cigc    = 0.0008       aigsd   = 0.0087       bigsd   = 0.0012       cigsd   = 0.0008
+nigc    = 1            poxedge = 1            pigcd   = 1            ntox    = 1

+xrcrg1  = 12           xrcrg2  = 5
+cgbo    = 2.56e-011    cgdl    = 2.653e-10
+cgsl    = 2.653e-10    ckappas = 0.03         ckappad = 0.03         acde    = 1
+moin    = 15           noff    = 0.9          voffcv  = 0.02

+kt1     = -0.11        kt1l    = 0            kt2     = 0.022        ute     = -1.5
+ua1     = 4.31e-009    ub1     = 7.61e-018    uc1     = -5.6e-011    prt     = 0
+at      = 33000

+fnoimod = 1            tnoimod = 0

+jss     = 0.0001       jsws    = 1e-011       jswgs   = 1e-010       njs     = 1
+ijthsfwd= 0.01         ijthsrev= 0.001        bvs     = 10           xjbvs   = 1
+jsd     = 0.0001       jswd    = 1e-011       jswgd   = 1e-010       njd     = 1
+ijthdfwd= 0.01         ijthdrev= 0.001        bvd     = 10           xjbvd   = 1
+pbs     = 1            cjs     = 0.0005       mjs     = 0.5          pbsws   = 1
+cjsws   = 5e-010       mjsws   = 0.33         pbswgs  = 1            cjswgs  = 3e-010
+mjswgs  = 0.33         pbd     = 1            cjd     = 0.0005       mjd     = 0.5
+pbswd   = 1            cjswd   = 5e-010       mjswd   = 0.33         pbswgd  = 1
+cjswgd  = 5e-010       mjswgd  = 0.33         tpb     = 0.005        tcj     = 0.001
+tpbsw   = 0.005        tcjsw   = 0.001        tpbswg  = 0.005        tcjswg  = 0.001
+xtis    = 3            xtid    = 3

+dmcg    = 0e-006       dmci    = 0e-006       dmdg    = 0e-006       dmcgt   = 0e-007
+dwj     = 0.0e-008     xgw     = 0e-007       xgl     = 0e-008

+rshg    = 0.4          gbmin   = 1e-010       rbpb    = 5            rbpd    = 15
+rbps    = 15           rbdb    = 15           rbsb    = 15           ngcon   = 1
</file>

<file path="examples/ngspice-shared/external-source.py">
####################################################################################################
#r#
#r# ===================================
#r#  Simulation using External Sources
#r# ===================================
#r#
#r# This example explains how to plug a voltage source from Python to NgSpice.
#r#
####################################################################################################
# Fixme: Travis CI macOS
#
# Error on line 2 :
#   vinput input 0 dc 0 external
#   parameter value out of range or the wrong type
#
# Traceback (most recent call last):
#     analysis = simulator.transient(step_time=period/200, end_time=period*2)
#   File "/usr/local/lib/python3.7/site-packages/PySpice/Spice/NgSpice/Shared.py", line 1145, in load_circuit
#     raise NgSpiceCircuitError('')
####################################################################################################
import math
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Probe.Plot import plot
from PySpice.Spice.Netlist import Circuit
from PySpice.Spice.NgSpice.Shared import NgSpiceShared
from PySpice.Unit import *
####################################################################################################
class MyNgSpiceShared(NgSpiceShared):
    ##############################################
    def __init__(self, amplitude, frequency, **kwargs):
        super().__init__(**kwargs)
        self._amplitude = amplitude
        self._pulsation = float(frequency.pulsation)
    ##############################################
    def get_vsrc_data(self, voltage, time, node, ngspice_id):
        self._logger.debug('ngspice_id-{} get_vsrc_data @{} node {}'.format(ngspice_id, time, node))
        voltage[0] = self._amplitude * math.sin(self._pulsation * time)
        return 0
    ##############################################
    def get_isrc_data(self, current, time, node, ngspice_id):
        self._logger.debug('ngspice_id-{} get_isrc_data @{} node {}'.format(ngspice_id, time, node))
        current[0] = 1.
        return 0
####################################################################################################
circuit = Circuit('Voltage Divider')
circuit.V('input', 'input', circuit.gnd, 'dc 0 external')
circuit.R(1, 'input', 'output', 10@u_kΩ)
circuit.R(2, 'output', circuit.gnd, 1@u_kΩ)
amplitude = 10@u_V
frequency = 50@u_Hz
ngspice_shared = MyNgSpiceShared(amplitude=amplitude, frequency=frequency, send_data=False)
simulator = circuit.simulator(temperature=25, nominal_temperature=25,
                              simulator='ngspice-shared', ngspice_shared=ngspice_shared)
period = float(frequency.period)
analysis = simulator.transient(step_time=period/200, end_time=period*2)
####################################################################################################
figure1, ax = plt.subplots(figsize=(20, 10))
ax.set_title('Voltage Divider')
ax.set_xlabel('Time [s]')
ax.set_ylabel('Voltage [V]')
ax.grid()
ax.plot(analysis.input)
ax.plot(analysis.output)
ax.legend(('input', 'output'), loc=(.05,.1))
ax.set_ylim(float(-amplitude*1.1), float(amplitude*1.1))
plt.tight_layout()
plt.show()
#f# save_figure('figure1', 'voltage-divider.png')
</file>

<file path="examples/ngspice-shared/index.rst">
This section shows how to use the NgSpice Shared Simulation Mode which permits to plug
voltage/current sources from Python to NgSpice and vice versa.

This NgSpice feature paves the way to advanced simulation use cases.  For example we can perform a
mixed level simulation of an analogic circuit connected to a microcontroller.  We just need to
implement an impedance model in Spice for input and output ports and implement the logic within
Python.  The NgSpice callbacks provide the interface to read and set current/voltage of the external
nodes.

See :mod:`PySpice.Spice.NgSpice.Shared` for more details.

.. end
</file>

<file path="examples/ngspice-shared/ngspice-interpreter.py">
####################################################################################################
#r#
#r# =====================
#r#  NgSpice Interpreter
#r# =====================
#r#
#r# This example explains how to use the NgSpice binding.
#r#
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Spice.NgSpice.Shared import NgSpiceShared
####################################################################################################
ngspice = NgSpiceShared.new_instance()
print(ngspice.exec_command('version -f'))
print(ngspice.exec_command('print all'))
print(ngspice.exec_command('devhelp'))
print(ngspice.exec_command('devhelp resistor'))
circuit = '''
.title Voltage Multiplier
.SUBCKT 1N4148 1 2
*
R1 1 2 5.827E+9
D1 1 2 1N4148
*
.MODEL 1N4148 D
+ IS = 4.352E-9
+ N = 1.906
+ BV = 110
+ IBV = 0.0001
+ RS = 0.6458
+ CJO = 7.048E-13
+ VJ = 0.869
+ M = 0.03
+ FC = 0.5
+ TT = 3.48E-9
.ENDS
Vinput in 0 DC 0V AC 1V SIN(0V 10V 50Hz 0s 0Hz)
C0 in 1 1mF
X0 1 0 1N4148
C1 0 2 1mF
X1 2 1 1N4148
C2 1 3 1mF
X2 3 2 1N4148
C3 2 4 1mF
X3 4 3 1N4148
C4 3 5 1mF
X4 5 4 1N4148
R1 5 6 1MegOhm
.options TEMP = 25°C
.options TNOM = 25°C
.options filetype = binary
.options NOINIT
.ic
.tran 0.0001s 0.4s 0s
.end
'''
ngspice.load_circuit(circuit)
print('Loaded circuit:')
print(ngspice.listing())
print(ngspice.show('c3'))
print(ngspice.showmod('c3'))
ngspice.run()
print('Plots:', ngspice.plot_names)
print(ngspice.ressource_usage())
print(ngspice.status())
plot = ngspice.plot(simulation=None, plot_name=ngspice.last_plot)
print(plot)
# ngspice.quit()
</file>

<file path="examples/operational-amplifier/astable.py">
#skip#
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
# from OperationalAmplifier import basic_comparator
####################################################################################################
circuit = Circuit('Astable Multivibrator')
source = circuit.V('cc', 'vcc', circuit.gnd, 15@u_V)
# Time constant
circuit.R(1, 'output', 'comparator', 1@u_kΩ)
circuit.C(1, 'comparator', circuit.gnd, 100@u_nF)
# Reference
circuit.R(2, 'output', 'reference', 100@u_kΩ)
circuit.R(3, 'vcc', 'reference', 100@u_kΩ)
circuit.R(4, 'reference', circuit.gnd, 100@u_kΩ)
# Comparator
# Fixme: ngspice is buggy with such subcircuit
# circuit.subcircuit(basic_comparator)
# circuit.X('comparator', 'BasicComparator', 'reference', 'comparator', 'vcc', circuit.gnd, 'output')
circuit.NonLinearVoltageSource(1, 'output', circuit.gnd,
                               expression='V(reference, comparator)',
                               table=((-micro(1), 0),
                                      (micro(1), source.dc_value))
                               )
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
# simulator.initial_condition(comparator=0)  # Fixme: simulator.nodes.comparator == 0
simulator.node_set(comparator=0)  # Fixme: simulator.nodes.comparator == 0
analysis = simulator.transient(step_time=1@u_us, end_time=500@u_us)
# Fixme: Xyce fails with Time step too small
figure, ax = plt.subplots(figsize=(20, 10))
ax.grid()
ax.plot(analysis.reference)
ax.plot(analysis.comparator)
ax.plot(analysis.output)
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'astable.png')
</file>

<file path="examples/operational-amplifier/operational-amplifier.py">
####################################################################################################
import numpy as np
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Plot.BodeDiagram import bode_diagram
from PySpice.Probe.Plot import plot
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
from OperationalAmplifier import BasicOperationalAmplifier
#f# literal_include('OperationalAmplifier.py')
####################################################################################################
circuit = Circuit('Operational Amplifier')
# AC 1 PWL(0US 0V  0.01US 1V)
circuit.SinusoidalVoltageSource('input', 'in', circuit.gnd, amplitude=1@u_V)
circuit.subcircuit(BasicOperationalAmplifier())
circuit.X('op', 'BasicOperationalAmplifier', 'in', circuit.gnd, 'out')
circuit.R('load', 'out', circuit.gnd, 470@u_Ω)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.ac(start_frequency=1@u_Hz, stop_frequency=100@u_MHz, number_of_points=5,  variation='dec')
figure, (ax1, ax2) = plt.subplots(2, figsize=(20, 10))
plt.title("Bode Diagram of an Operational Amplifier")
bode_diagram(axes=(ax1, ax2),
             frequency=analysis.frequency,
             gain=20*np.log10(np.absolute(analysis.out)),
             phase=np.angle(analysis.out, deg=False),
             marker='.',
             color='blue',
             linestyle='-',
            )
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'operational-amplifier.png')
</file>

<file path="examples/operational-amplifier/OperationalAmplifier-api-brainstorming.py">
#skip#
####################################################################################################
from PySpice.Spice.Netlist import SubCircuit
from PySpice.Unit import *
####################################################################################################
class BasicOperationalAmplifier(SubCircuit): # SubCircuitFactory
    #
    # __init__(self, name, subcircuit_name, *nodes)
    #
    # name = class name
    # node = NODES = interface
    #
    NODES = ('non_inverting_input', 'inverting_input', 'output')
    ##############################################
    def __init__(self):
        # comment: we could pass parameters using ctor
        # Input impedance
        # comment: 'R'+'2' but for other devices ? name/attribute versus spice name
        self.R('input', 'non_inverting_input', 'inverting_input', 10@u_MΩ)
        # dc gain=100k and pole1=100hz
        # unity gain = dcgain x pole1 = 10MHZ
        # Fixme: gain=...
        self.VCVS('gain', 'non_inverting_input', 'inverting_input', 1, self.gnd, kilo(100))
        self.R('P1', 1, 2, 1@u_kΩ)
        self.C('P1', 2, self.gnd, 1.5915@u_uF)
        # Output buffer and resistance
        self.VCVS('buffer', 2, self.gnd, 3, self.gnd, 1)
        self.R('out', 3, 'output', 10@u_Ω)
####################################################################################################
class BasicOperationalAmplifier(SubCircuit): # SubCircuitFactory
    NODES = ('non_inverting_input', 'inverting_input', 'output')
    # Comment: R doesn't know its name, R prefix is redundant
    Rinput = R('non_inverting_input', 'inverting_input', 10@u_MΩ)
    gain = VCVS('non_inverting_input', 'inverting_input', 1, self.gnd, kilo(100))
    RP1 = R(1, 2, 1@u_kΩ)
    CP1 = C(2, self.gnd, 1.591@u_uF)
    # Comment: buffer is a Python name
    buffer = VCVS(2, self.gnd, 3, self.gnd, 1)
    Rout = R(3, 'output', 10@u_Ω)
</file>

<file path="examples/operational-amplifier/OperationalAmplifier.py">
####################################################################################################
from PySpice.Spice.Netlist import SubCircuitFactory
from PySpice.Unit import *
####################################################################################################
class BasicOperationalAmplifier(SubCircuitFactory):
    NAME = 'BasicOperationalAmplifier'
    NODES = ('non_inverting_input', 'inverting_input', 'output')
    ##############################################
    def __init__(self):
        super().__init__()
        # Input impedance
        self.R('input', 'non_inverting_input', 'inverting_input', 10@u_MΩ)
        # dc gain=100k and pole1=100hz
        # unity gain = dcgain x pole1 = 10MHZ
        self.VCVS('gain', 1, self.gnd, 'non_inverting_input', 'inverting_input', voltage_gain=kilo(100))
        self.R('P1', 1, 2, 1@u_kΩ)
        self.C('P1', 2, self.gnd, 1.5915@u_uF)
        # Output buffer and resistance
        self.VCVS('buffer', 3, self.gnd, 2, self.gnd, 1)
        self.R('out', 3, 'output', 10@u_Ω)
####################################################################################################
class BasicComparator(SubCircuitFactory):
    NAME = 'BasicComparator'
    NODES = ('non_inverting_input', 'inverting_input',
             'voltage_plus', 'voltage_minus',
             'output')
    ##############################################
    def __init__(self,):
        super().__init__()
        # Fixme: ngspice is buggy with such subcircuit
        # Fixme: how to pass voltage_plus, voltage_minus ?
        # output_voltage_minus, output_voltage_plus = 0, 15
        # to plug the voltage source
        self.R(1, 'voltage_plus', 'voltage_minus', 1@u_MΩ)
        self.NonLinearVoltageSource(1, 'output', 'voltage_minus',
                                    expression='V(non_inverting_input, inverting_input)',
                                    # table=((-micro(1), output_voltage_minus),
                                    #       (micro(1), output_voltage_plus))
                                    table=(('-1uV', '0V'), ('1uV', '15V'))
                                )
</file>

<file path="examples/passive/m4/capacitor_and_inductor.m4">
.PS
cct_init(SIdefaults)

linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3

[
Origin: Here
  ground; dot;
  source(up_ elen, P); llabel(,V_{in},); dot; "in" above
  resistor(right_ elen); llabel(,R_1,) dot; "out" above
  capacitor(down_ elen); llabel(,C_1,)
  line down epsilon then to Origin then up epsilon
]

[
move right 1.5*elen
Origin: Here
  ground; dot;
  source(up_ elen, P); llabel(,V_{in},); dot; "in" above
  resistor(right_ elen); llabel(,R_1,) dot; "out" above
  inductor(down_ elen); llabel(,L_1,)
  line down epsilon then to Origin then up epsilon
]

.PE
</file>

<file path="examples/passive/capacitor-inductor.py">
#r# This example shows the simulation of a capacitor and an inductor.
#r#
#r# To go further, you can read these pages on Wikipedia: `RC circuit <https://en.wikipedia.org/wiki/RC_circuit>`_
#r# and `RL circuit <https://en.wikipedia.org/wiki/RL_circuit>`_.
####################################################################################################
import numpy as np
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Probe.Plot import plot
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
from scipy.optimize import curve_fit
####################################################################################################
# Warning: the capacitor/inductor return current in the generator
#  could use switches instead
#r# We will use a simple circuit where both capacitor and inductor are driven by a pulse source
#r# through a limiting current resistor.
#f# circuit_macros('capacitor_and_inductor.m4')
# Fixme: for loop makes difficult to intermix code and text !
#r# We will fit from the simulation output the time constant of each circuit and compare it to the
#r# theoretical value.
figure, (ax1, ax2) = plt.subplots(2, figsize=(20, 10))
element_types = ('capacitor', 'inductor')
for element_type in ('capacitor', 'inductor'):
    circuit = Circuit(element_type.title())
    # Fixme: compute value
    source = circuit.PulseVoltageSource('input', 'in', circuit.gnd,
                           initial_value=0@u_V, pulsed_value=10@u_V,
                           pulse_width=10@u_ms, period=20@u_ms)
    circuit.R(1, 'in', 'out', 1@u_kΩ)
    if element_type == 'capacitor':
        element = circuit.C
        value = 1@u_uF
        # tau = RC = 1 ms
    else:
        element = circuit.L
        # Fixme: force component value to an Unit instance ?
        value = 1@u_H
        # tau = L/R = 1 ms
    element(1, 'out', circuit.gnd, value)
    # circuit.R(2, 'out', circuit.gnd, kilo(1)) # for debug
    if element_type == 'capacitor':
        tau = circuit['R1'].resistance * circuit['C1'].capacitance
    else:
        tau = circuit['L1'].inductance / circuit['R1'].resistance
    simulator = circuit.simulator(temperature=25, nominal_temperature=25)
    step_time = 10@u_us
    analysis = simulator.transient(step_time=step_time, end_time=source.period*3)
    # Let define the theoretical output voltage.
    if element_type == 'capacitor':
        def out_voltage(t, tau):
            # Fixme: TypeError: only length-1 arrays can be converted to Python scalars
            return float(source.pulsed_value) * (1 -  np.exp(-t / tau))
    else:
        def out_voltage(t, tau):
            return float(source.pulsed_value) * np.exp(-t / tau)
    # Fixme: get step_time from analysis
    # At t = 5 tau, each circuit has nearly reached it steady state.
    i_max = int(5 * tau / float(step_time))
    popt, pcov = curve_fit(out_voltage, analysis.out.abscissa[:i_max], analysis.out[:i_max])
    tau_measured = popt[0]
    # Fixme: use Unit().canonise()
    print('tau {0} = {1}'.format(element_type, tau.canonise().str_space()))
    print('tau measured {0} = {1:.1f} ms'.format(element_type, tau_measured * 1000))
    if element_type == 'capacitor':
        ax = ax1
        title = "Capacitor: voltage is constant"
    else:
        ax = ax2
        title = "Inductor: current is constant"
    ax.set_title(title)
    ax.grid()
    current_scale = 1000
    ax.plot(analysis['in'])
    ax.plot(analysis['out'])
    # Fixme: resistor current, scale
    ax.plot(((analysis['in'] - analysis.out)/circuit['R1'].resistance) * current_scale)
    ax.axvline(x=float(tau), color='red')
    ax.set_ylim(-11, 11)
    ax.set_xlabel('t [s]')
    ax.set_ylabel('[V]')
    ax.legend(('Vin [V]', 'Vout [V]', 'I'), loc=(.8,.8))
#o#
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'capacitor-inductor.png')
# Fixme: Add formulae
</file>

<file path="examples/power-supplies/m4/capacitive-half-wave-rectification-post-zener-circuit.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
define(`bigdiode',
  `resized(2., `diode', $1)')
define(`bigzenerdiode',
  `resized(2., `reversed', `diode', $1, S)')
Neutral: Here
  dot; "N" below;
  source(up_ elen, AC); llabel(,V_{AC},); dot; "L" above;
  resistor(right_ elen); llabel(,R_{in},); dot; "1" above;
  capacitor(right_ elen); llabel(,C_{in},); dot; "2" above;
  {
  bigzenerdiode(down_ elen); rlabel(,Dz,); dot;
  }
  bigdiode(right_ elen); rlabel(,D,); dot;
  {
  capacitor(down_ elen, C+); llabel(,C,); dot;
  }
  line right_ elen then down epsilon; "out" above;
  resistor(down_ elen); llabel(,R_{load},);
  line down epsilon then to Neutral then up epsilon
.PE
</file>

<file path="examples/power-supplies/m4/capacitive-half-wave-rectification-pre-zener-circuit.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
define(`bigdiode',
  `resized(2., `diode', $1)')
define(`bigzenerdiode',
  `resized(2., `reversed', `diode', $1, S)')
Neutral: Here
  dot; "N" below;
  source(up_ elen*2, AC); llabel(,V_{AC},); dot; "L" above;
  line right_ elen/2; dot;
  {
    line down_ elen/2;
    resistor(right_ elen); llabel(,R_{emi},);
    line up_ elen/2;
  }
  capacitor(right_ elen); llabel(,C_{in},); dot; "1" above;
  resistor(right_ elen); llabel(,R_{in},); dot; "2" above;
  bigdiode(right_ elen); rlabel(,D_{1},); dot;
  {
    C2: capacitor(down_ elen, C+); llabel(,C_{2},); dot; "3" at C2.end ljust;
    { bigdiode(left_ elen); llabel(,D_{2},); line up_ elen; }
    resistor(down_ elen); llabel(,R_{2},); dot;
  }
  line right_ elen; dot;
  {
    bigzenerdiode(down_ elen*2); llabel(,Dz,); dot;
  }
  line right_ elen; dot;
  {
    capacitor(down_ elen*2, C+); llabel(,C,); dot;
  }
  line right_ elen then down epsilon; "out" above;
  resistor(down_ elen*2); llabel(,R_{load},);
  line down epsilon then to Neutral then up epsilon
.PE
</file>

<file path="examples/power-supplies/capacitive-half-wave-rectification-post-zener.py">
#r# This example shows a capacitive power supply with a post zener half-rectification, a kind
#r# of transformless power supply.
#r# To go further on this topic, you can read these design notes:
#r#
#r# * Transformerless Power Supply Design, Designer Circuits, LLC
#r# * Low-cost power supply for home appliances, STM, AN1476
#r# * Transformerless Power Supplies: Resistive and Capacitive, Microchip, AN954
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
#f# circuit_macros('capacitive-half-wave-rectification-post-zener-circuit.m4')
circuit = Circuit('Capacitive Half-Wave Rectification (Post Zener)')
circuit.include(spice_library['1N4148'])
# 1N5919B: 5.6 V, 3.0 W Zener Diode Voltage Regulator
circuit.include(spice_library['d1n5919brl'])
ac_line = circuit.AcLine('input', 'L', circuit.gnd, rms_voltage=230@u_V, frequency=50@u_Hz)
circuit.R('in', 'L', 1, 470@u_Ω)
circuit.C('in', 1, 2, 470@u_nF)
# d1n5919brl pinning is anode cathode ->|-
circuit.X('Dz', 'd1n5919brl', circuit.gnd, 2)
# 1N4148 pinning is anode cathode ->|-
circuit.X('D', '1N4148', 2, 'out')
circuit.C('', 'out', circuit.gnd, 220@u_uF)
circuit.R('load', 'out', circuit.gnd, 1@u_kΩ)
#?# Fixme: circuit.nodes[2].v, circuit.branch.current
# print circuit.nodes
# Simulator(circuit, ...).transient(...)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=ac_line.period/200, end_time=ac_line.period*10)
figure, ax = plt.subplots(figsize=(20, 10))
ax.plot(analysis['L'] / 100)
ax.plot(analysis.out)
###ax.plot((analysis.out - analysis['L']) / 100)
###ax.plot(analysis.out - analysis['2'])
###ax.plot((analysis['2'] - analysis['1']) / 100)
# or:
#   plt.ax.plot(analysis.out.abscissa, analysis.out)
ax.legend(('Vin [V]', 'Vout [V]'), loc=(.8,.8))
ax.grid()
ax.set_xlabel('t [s]')
ax.set_ylabel('[V]')
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'capacitive-half-wave-rectification-post-zener.png')
</file>

<file path="examples/power-supplies/capacitive-half-wave-rectification-pre-zener.py">
#r# This example shows a capacitive power supply with a pre zener half-rectification.
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
#f# circuit_macros('capacitive-half-wave-rectification-pre-zener-circuit.m4')
circuit = Circuit('Capacitive Half-Wave Rectification (Pre Zener)')
circuit.include(spice_library['1N4148'])
# 1N5919B: 5.6 V, 3.0 W Zener Diode Voltage Regulator
circuit.include(spice_library['d1n5919brl'])
ac_line = circuit.AcLine('input', 'L', circuit.gnd, rms_voltage=230@u_V, frequency=50@u_Hz)
circuit.C('in', 'L', 1, 330@u_nF)
circuit.R('emi', 'L', 1, 165@u_kΩ)
circuit.R('in', 1, 2, 2*47@u_Ω)
# 1N4148 pinning is anode cathode ->|-
circuit.X('D1', '1N4148', 2, 'out')
circuit.C('2', 'out', 3, 250@u_uF)
circuit.R('2', 3, circuit.gnd, 1@u_kΩ)
circuit.X('D2', '1N4148', 3, 2)
# d1n5919brl pinning is anode cathode ->|-
circuit.X('Dz', 'd1n5919brl', circuit.gnd, 'out')
circuit.C('', 'out', circuit.gnd, 250@u_uF)
circuit.R('load', 'out', circuit.gnd, 1@u_kΩ)
#?# Fixme: circuit.nodes[2].v, circuit.branch.current
# print circuit.nodes
# Simulator(circuit, ...).transient(...)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=ac_line.period/200, end_time=ac_line.period*50)
figure, ax = plt.subplots(1, figsize=(20, 10))
ax.plot(analysis.L / 100)
ax.plot(analysis.out)
ax.plot(analysis['2'])
ax.plot(analysis['3'])
ax.plot((analysis.out - analysis['3']))
# ax.plot((analysis['2'] - analysis['3']))
#ax.plot((analysis.L - analysis['1']) / 100)
###ax.plot((analysis.out - analysis['L']) / 100)
###ax.plot(analysis.out - analysis['2'])
###ax.plot((analysis['2'] - analysis['1']) / 100)
# or:
#   plt.ax.plot(analysis.out.abscissa, analysis.out)
ax.legend(('Vin [V]', 'Vout [V]', 'V2 [V]', 'V3 [V]', 'VC2 [V]'), loc=(.8,.8))
ax.grid()
ax.set_xlabel('t [s]')
ax.set_ylabel('[V]')
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'capacitive-half-wave-rectification-post-zener.png')
</file>

<file path="examples/power-supplies/hp54501a-cem.py">
#r# ================
#r#  CEM Simulation
#r# ================
#r# This example show a CEM simulation.
# Fixme: retrieve PDF reference and complete
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
from HP54501A import HP54501A
#f# literal_include('HP54501A.py')
####################################################################################################
circuit = Circuit('HP54501A CEM')
circuit.include(spice_library['1N4148'])
diode_model = '1N4148'
ac_line = circuit.AcLine('input', 'input', circuit.gnd, rms_voltage=230@u_V, frequency=50@u_Hz)
# circuit.subcircuit(HP54501A(diode_model='1N4148'))
# circuit.X('hp54501a', 'HP54501A', 'input', circuit.gnd)
circuit.C(1, 'input', circuit.gnd, 1@u_uF)
circuit.X('D1', diode_model, 'line_plus', 'top')
circuit.X('D2', diode_model, 'scope_ground', 'input')
circuit.X('D3', diode_model, circuit.gnd, 'top')
circuit.X('D4', diode_model, 'scope_ground', circuit.gnd)
circuit.R(1, 'top', 'output', 10@u_Ω)
circuit.C(2, 'output', 'scope_ground', 50@u_uF)
circuit.R(2, 'output', 'scope_ground', 900@u_Ω)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=ac_line.period/100, end_time=ac_line.period*3)
figure, ax = plt.subplots(figsize=(20, 6))
ax.plot(analysis.input)
ax.plot(analysis.Vinput)
ax.plot(analysis.output - analysis.scope_ground)
ax.legend(('Vin [V]', 'I [A]'), loc=(.8,.8))
ax.grid()
ax.set_xlabel('t [s]')
ax.set_ylabel('[V]')
plt.show()
#f# save_figure('figure', 'hp54501a-cem.png')
</file>

<file path="examples/power-supplies/HP54501A.py">
####################################################################################################
from PySpice.Spice.Netlist import SubCircuitFactory
from PySpice.Unit import *
####################################################################################################
class HP54501A(SubCircuitFactory):
    NAME = 'HP54501A'
    NODES = ('line_plus', 'line_minus')
    ##############################################
    def __init__(self, diode_model):
        super().__init__()
        self.C(1, 'line_plus', 'line_minus', 1@u_uF)
        self.X('D1', diode_model, 'top', 'line_plus')
        self.X('D2', diode_model, 'line_plus', 'scope_ground')
        self.X('D3', diode_model, 'top', 'line_minus')
        self.X('D4', diode_model, 'line_minus', 'scope_ground')
        self.R(1, 'top', 'output', 10)
        self.C(2, 'output', 'scope_ground', 50@u_uF)
        self.R(2, 'output', 'scope_ground', 900@u_Ω)
</file>

<file path="examples/pyterate-templates/document.jinja2">
{% extends "document_base.jinja2" %}

{% block includes %}
.. include:: /project-links.txt
.. include:: /abbreviation.txt
{% endblock %}
</file>

<file path="examples/relay/relay.py">
#r# =====================================
#r#  Relay drived by a bipolar transistor
#r# =====================================
#r# This example shows the simulation of ...
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
#?# #cm# relay.m4
period = 50@u_ms
pulse_width = period / 2
circuit = Circuit('Relay')
# circuit.V('digital', 'Vdigital', circuit.gnd, 5@u_V)
circuit.PulseVoltageSource('clock', 'clock', circuit.gnd, 0@u_V, 5@u_V, pulse_width, period, rise_time=5@u_ms, fall_time=5@u_ms)
circuit.R('base', 'clock', 'base', 100@u_Ω)
circuit.BJT(1, 'collector', 'base', circuit.gnd, model='bjt') # Q is mapped to BJT !
circuit.model('bjt', 'npn', bf=80, cjc=pico(5), rb=100)
circuit.V('analog', 'VccAnalog', circuit.gnd, 8@u_V)
circuit.R('relay', 'VccAnalog', 1, 50@u_Ω)
circuit.L('relay', 1, 'collector', 100@u_mH)
circuit.include(spice_library['1N5822']) # Schottky diode
diode = circuit.X('D', '1N5822', 'collector', 'VccAnalog')
# Fixme: subcircuit node
# diode.minus.add_current_probe(circuit)
####################################################################################################
figure, ax = plt.subplots(figsize=(20, 10))
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=period/1000, end_time=period*1.1)
ax.set_title('')
ax.set_xlabel('Time [s]')
ax.set_ylabel('Voltage [V]')
ax.grid()
ax.plot(analysis.base)
ax.plot(analysis.collector)
# Fixme: current probe
# ax.plot((analysis['1'] - analysis.collector)/circuit.Rrelay.resistance)
ax.plot(analysis['1'] - analysis.collector)
ax.legend(('Vbase', 'Vcollector'), loc=(.05,.1))
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'relay.png')
</file>

<file path="examples/resistor/m4/resistor-bridge.m4">
.PS
cct_init(SIdefaults)

linethick_(.5)
define(`dimen_', 10)
epsilon = 1e-3

Left: dot; "2" rjust
{
  Point_(45); resistor(,); dlabel(0,4,,,R_1)
  Top: dot; "1" rjust; Point_(-45); resistor(,); dlabel(0,4,,,R_2)
  Right: dot; "3" ljust; resistor(from Right to Left); llabel(,R_5,)
}
{
  Point_(-45); resistor(,); dlabel(0,-4,,,R_3)
  Bottom: dot; "0" rjust; Point_(45); resistor(,); dlabel(0,-4,,,R_4)
}

small_length = dimen_/4
move to Top; line up small_length then left dimen_*2 then down epsilon
STop: Here
move to Bottom; line down small_length; dot; ground
line to (STop, Here) then up epsilon
SBot: Here
source(from SBot to STop, V); dlabel(0,6,,,V_{in})

.PE
</file>

<file path="examples/resistor/m4/voltage-divider.m4">
.PS
cct_init(SIdefaults)
linethick_(.5)
define(`dimen_', 10)
elen = dimen_*3/2
epsilon = 1e-3
Origin: Here
  ground; dot;
  source(up_ elen, V); llabel(,V_{in},); dot; "in" rjust
  resistor(right_ elen); llabel(,R_1,) dot; "out" ljust
  resistor(down_ elen); llabel(,R_2,)
  line down epsilon then to Origin then up epsilon
.PE
</file>

<file path="examples/resistor/resistor-bridge.py">
#r# This example shows the computation of the DC biases in a resistor bridge.
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
#f# circuit_macros('resistor-bridge.m4')
circuit = Circuit('Resistor Bridge')
circuit.V('input', 1, circuit.gnd, 10@u_V)
circuit.R(1, 1, 2, 2@u_kΩ)
circuit.R(2, 1, 3, 1@u_kΩ)
circuit.R(3, 2, circuit.gnd, 1@u_kΩ)
circuit.R(4, 3, circuit.gnd, 2@u_kΩ)
circuit.R(5, 3, 2, 2@u_kΩ)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.operating_point()
for node in analysis.nodes.values():
    print('Node {}: {:4.1f} V'.format(str(node), float(node))) # Fixme: format value + unit
#o#
</file>

<file path="examples/resistor/voltage-divider.py">
#r# This example shows the computation of the DC bias and sensitivity in a voltage divider.
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
#f# circuit_macros('voltage-divider.m4')
circuit = Circuit('Voltage Divider')
circuit.V('input', 'in', circuit.gnd, 10@u_V)
circuit.R(1, 'in', 'out', 9@u_kΩ)
circuit.R(2, 'out', circuit.gnd, 1@u_kΩ)
####################################################################################################
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.operating_point()
for node in (analysis['in'], analysis.out): # .in is invalid !
    print('Node {}: {} V'.format(str(node), float(node)))
#o#
# Fixme: Xyce sensitivity analysis
analysis = simulator.dc_sensitivity('v(out)')
for element in analysis.elements.values():
    print(element, float(element))
#o#
</file>

<file path="examples/spice-examples/ac-coupled-amplifier.cir">
AC-coupled amplifier
Vpwr 6 0 DC 15V
Vin 1 0 AC 1V SIN(0V .5V 1KHz)
C1 1 2 10u
R1 6 2 100k
R2 2 0 20k
RC 6 4 10k
Q1 4 2 3 bjt
RE 3 0 2k
C2 4 5 10u
RL 5 0 1Meg
.model bjt npn(bf=80 cjc=5p rb=100)
.ac dec 5 10m 1G
*.tran .02ms 2ms 0 .01ms
.control
run
plot V(1) V(5)
.end
</file>

<file path="examples/spice-examples/ac-coupled-transistor-amplifier.cir">
A Berkeley SPICE3 compatible circuit
*
* This circuit contains only Berkeley SPICE3 components.
*
* The circuit is an AC coupled transistor amplifier with
* a sine wave input at node "1", again of approximately -3.9,
* and output on node "coll".
*
Vcc vcc 0 12V
Vin 1 0 0V AC 1V SIN(0V 1V 1kHz)
Ccouple 1 base 10uF
Rbias1 vcc base 100k
Rbias2 base 0 24k
Q1 coll base emit generic
Rcollector vcc coll 3.9k
Remitter emit 0 1k
*
.model generic npn
*
.tran  1us 10ms
.control
run
plot V(1) V(coll) 
.endc
.end
</file>

<file path="examples/spice-examples/astable.cir">
.title Astable Multivibrator
*
****************************************************************************************************
.subckt BasicComparator output voltage_minus non_inverting_input inverting_input
E1 output voltage_minus TABLE {V(non_inverting_input, inverting_input)} = (-1uV, 0V) (1uV, 15V)
* Error on line 0 : b.xcomparator.b*1 xcomparator.*1_int1 0 v= v(reference,comparator) ,   -1.0000000000e-06 ,   0.0000000000e+00 ,   1.0000000000e-06 ,   1.5000000000e+01
*  unknown parameter (-1.0000000000e-06) 
.ends
****************************************************************************************************
Vcc vcc 0 15 
****************************************************************************************************
* Time constant
R1 output comparator 1k
C1 comparator 0 100n 
* mandatory
.IC V(comparator)=0
****************************************************************************************************
* Reference
R2 output reference 100k 
R3 Vcc reference 100k 
R4 reference 0 100k 
****************************************************************************************************
* Comparator
* Xcomparator output 0 reference comparator BasicComparator 
E1 output 0 TABLE {V(reference, comparator)} = (-1uV, 0V) (1uV, 15V)
****************************************************************************************************
.end
****************************************************************************************************
.control
tran 1u 500u
plot V(output) V(reference) V(comparator)
.endc
****************************************************************************************************
</file>

<file path="examples/spice-examples/diode-ac.cir">
.title Diode
.include examples/libraries/diode/BAV21.lib
Vinput in 0 DC 5V AC SIN(5V 0.1V 1kHz)
R1 in out 1k
D1 out 0 BAV21
.save V(in) V(out)
.control
op
ac dec 10 10k 1G
.endc
.end
</file>

<file path="examples/spice-examples/diode.cir">
.title Diode
* .include examples/libraries/diode/BAV21.lib
.MODEL BAV21 D
+ IS=21.910E-9
+ N=2.2330
+ RS=1.0000E-3
+ IKF=19.230E-3
+ CJO=1.0300E-12
+ M=.1001
+ VJ=.75
+ BV=293.10
+ IBV=1.2930E-3
+ TT=51.940E-9
* + ISR=10.010E-21
Vinput in 0 0.9
R1 in out 1k
D1 out 0 BAV21
.end
</file>

<file path="examples/spice-examples/low-pass-rc-filter.cir">
.title Low Pass RC Filter
Vinput in 0 DC 0V AC SIN(0V 10V 1kHz)
R1 in out 1k
C1 out 0 1u
.ac dec 1 1 10k
.save v(in) v(out)
.control
run
* plot v(out)
print v(out)
.endc
.end
</file>

<file path="examples/spice-examples/operational-amplifier-model-1.cir">
OPMODEL1.CIR - OPAMP MODEL SINGLE-POLE
* from http://www.ecircuitcenter.com/OpModels/OpampModels.htm
*
VS	1	0	AC	1  PWL(0US 0V  0.01US 1V)
XOP	1 0	3	OPAMP1
RL	3	0	1K
*
* OPAMP MACRO MODEL, SINGLE-POLE 
* connections:      non-inverting input
*                   |   inverting input
*                   |   |   output
*                   |   |   |
.SUBCKT OPAMP1	    1   2   6
* INPUT IMPEDANCE
RIN	1	2	10MEG
* DC GAIN=100K AND POLE1=100HZ
* UNITY GAIN = DCGAIN X POLE1 = 10MHZ
EGAIN	3 0	1 2	100K
RP1	3	4	1K
CP1	4	0	1.5915UF
* OUTPUT BUFFER AND RESISTANCE
EBUFFER	5 0	4 0	1
ROUT	5	6	10
.ENDS
* 
* ANALYSIS
.AC 	DEC 	5 1 100MEG
*.TRAN 	0.05US  2US
.PLOT	AC 	VM(3)
.PROBE
.END
</file>

<file path="examples/spice-examples/operational-amplifier-model-2.cir">
OPAMP2.CIR - OPAMP MODEL (LEVEL 2)
* from http://www.ecircuitcenter.com/OpModels/OpampModels.htm
*
* SIGNAL SOURCE
VS	1	0	AC 1	PWL(0US 0V   0.01US 1V  100US 1V)
*
* POWER SUPPLIES
VCC	10	0	DC	+15V
VEE	11	0	DC	-15V
*
R1	0	2	1
*R2	2	3	1
XOP	1 2 3  10 11	OPAMP2
RL	3	0	100K
*
*
* OPAMP MACRO MODEL (INTERMEDIATE LEVEL)
*
*                IN+ IN- OUT  VCC  VEE
.SUBCKT OPAMP2   1   2   81   101   102  
Q1	5 1	7	NPN
Q2	6 2	8	NPN
RC1	101	5	95.49
RC2	101	6	95.49
RE1	7	4	43.79
RE2	8	4	43.79
I1	4	102	0.001
*
* OPEN-LOOP GAIN, FIRST POLE AND SLEW RATE
G1	100 10	6 5 0.0104719
RP1	10	100	9.549MEG
CP1	10	100	0.0016667UF
*
*OUTPUT STAGE
EOUT	80 100	10 100	1
RO	80	81	100
*
* INTERNAL REFERENCE
RREF1	101	103	100K
RREF2	103	102	100K
EREF	100 0	103 0 1
R100	100	0	1MEG
*
.model NPN  NPN(BF=50000)
*
.ENDS
*
* ANALYSIS
.TRAN 	0.1US  5US
.AC 	DEC 	5 0.1HZ 10MEGHZ
*
* VIEW RESULTS
.PRINT	TRAN 	V(3)
.PRINT	AC 	V(3)
.PROBE
.END
</file>

<file path="examples/spice-examples/resistor-bridge.cir">
.title Resistor Bridge
Vinput 1 0 10V
R1 1 2 2
R2 1 3 1
R3 2 0 1
R4 3 0 2
R5 3 2 2
** .op
* analysis 1
*.dc Vinput 10 20 1
*.save v(2) v(1)
* analysis 2
.sens v(1)
.end
</file>

<file path="examples/spice-examples/small-signal-amplifier-with-diodes.cir">
Small Signal Amplifier
*
* This circuit simulates a small signal amplifier with a diode limiter.
*
Vin input 0 DC 0V
Rsource input amp_in 100
*
Dneg 0 amp_in 1n4148
Dpos amp_in 0 1n4148
*
C1 amp_in 0 1uF
A1 amp_in 0 amp_out amplifier
Rload amp_out 0 1000
*
.model 1n4148 D (is=2.495E-09 rs=4.755E-01 n=1.679E+00
+ tt=3.030E-09 cjo=1.700E-12 vj=1 m=1.959E-01 bv=1.000E+02
+ ibv=1.000E-04)
*
.model amplifier Amp (gain = -10 in_offset = 1e-3 rin = 1meg rout = 0.4)
*
.dc Vin -1V 1V .05V
.control
run
plot V(input) V(amp_out)
.endc
.end
</file>

<file path="examples/spice-examples/small-signal-amplifier.cir">
Small Signal Amplifier
*
* This circuit simulates a simple small signal amplifier.
*
Vin input 0 0V SIN(0V .1V 500Hz)
Rsource input amp_in 100
C1 amp_in 0 1uF
R_amp_input amp_in 0 1Meg
E1 (amp_out 0) (amp_in 0) -10
Rload amp_out 0 1k
.tran 1us 10ms
.control
run
plot V(input) V(amp_out)
.endc
.end
</file>

<file path="examples/spice-examples/transform-less-power-supply.cir">
* **************************************************************************************************

.title STM AN1476: LOW-COST POWER SUPPLY FOR HOME APPLIANCES

* **************************************************************************************************

* 1N4148
.include /home/gv/sys/fc14/fabrice/electronic-design-pattern/spice/libraries/diode/standard-rectifier/1N4148.lib

* 1N5919B: 5.6 V, 3.0 W Zener Diode Voltage Regulator
* d1n5919brl
.include /home/gv/sys/fc14/fabrice/electronic-design-pattern/spice/libraries/diode/zener/1N5919B-spice3.lib

* **************************************************************************************************

.param line_peak_voltage=220V
.param freq=50Hz
.param periode={1 / freq}

Vinput1 out in DC 0V SIN(0V {line_peak_voltage} {freq})
Rload out 0 1k
Cload out 0 220uF
xD1 0 1 1N4148
* xDz1 1 out d1n5919brl
xDz1 1 out 1N4148
Cac 1 2 470nF
Rac 2 in 470

* **************************************************************************************************

.op

.param tran_step={periode / 200}
* .tran 200us 2000ms
.tran {tran_step} {periode * 50}

* **************************************************************************************************

.control
run
plot .1*(V(out)-V(in)), V(out), v(out)-v(1), .1*(V(1)-V(2))
.endc

* **************************************************************************************************

.end

* **************************************************************************************************
</file>

<file path="examples/spice-examples/transistor.cir">
.title Transistor
Vcollector collector 0 dc 0V
* Vcollector 1 0 dc
* Vammeter 1 collector dc 0V
Ibase 0 base dc 100u
Q1 collector base 0 generic
.control
dc vcollector 0 5 10m
* ibase 0 100m 10m
* range 10 mA
plot -vcollector#branch
* plot i(Vammeter)
.endc
.end
</file>

<file path="examples/spice-examples/transistor2.cir">
.title Transistor
Q1 collector base 0 generic 
Vcollector collector 0 5
Ibase 0 base 90m
.model generic npn ()
.end
.options TNOM = 25
.options NOINIT
.options TEMP = 25
</file>

<file path="examples/spice-examples/voltage-divider.cir">
.title Voltage Divider
Vinput in 0 DC 10V
R1 in out 9k
R2 out 0 1k
.op
.end
</file>

<file path="examples/spice-parser/kicad-pyspice-example/kicad-pyspice-example-cache.lib">
EESchema-LIBRARY Version 2.3
#encoding utf-8
#
# CONN_3
#
DEF CONN_3 K 0 40 Y N 1 F N
F0 "K" -50 0 50 V V C CNN
F1 "CONN_3" 50 0 40 V V C CNN
F2 "" 0 0 60 H V C CNN
F3 "" 0 0 60 H V C CNN
DRAW
S -100 150 100 -150 0 1 0 N
X P1 1 -350 100 250 R 60 60 1 1 P I
X PM 2 -350 0 250 R 60 60 1 1 P I
X P3 3 -350 -100 250 R 60 60 1 1 P I
ENDDRAW
ENDDEF
#
# GND-RESCUE-kicad-pyspice-example
#
DEF ~GND-RESCUE-kicad-pyspice-example #PWR 0 0 Y Y 1 F P
F0 "#PWR" 0 0 30 H I C CNN
F1 "GND-RESCUE-kicad-pyspice-example" 0 -70 30 H I C CNN
F2 "" 0 0 60 H V C CNN
F3 "" 0 0 60 H V C CNN
DRAW
P 4 0 1 0 -50 0 0 -50 50 0 -50 0 N
X GND 1 0 0 0 U 30 30 1 1 W N
ENDDRAW
ENDDEF
#
# JACK_2P
#
DEF JACK_2P J 0 40 Y Y 1 F N
F0 "J" -350 -200 50 H V C CNN
F1 "JACK_2P" -150 250 50 H V C CNN
F2 "" 0 0 50 H I C CNN
F3 "" 0 0 50 H I C CNN
DRAW
S -450 150 -400 -100 0 1 0 F
S 300 -150 -400 200 0 1 10 f
P 3 0 1 0 150 0 300 0 300 0 N
P 4 0 1 0 0 -100 -50 -50 -100 -100 -100 -100 N
P 4 0 1 0 0 -100 300 -100 300 -100 300 -100 N
P 4 0 1 0 50 -50 100 -100 150 -50 150 -50 N
P 4 0 1 0 150 0 100 0 100 -100 100 -100 N
P 5 0 1 0 300 150 -250 150 -300 100 -350 150 -350 150 N
X ~ 1 450 -100 150 L 50 50 1 1 P
X ~ 2 450 0 150 L 50 50 1 1 P
X ~ 3 450 150 150 L 50 50 1 1 P
ENDDRAW
ENDDEF
#
# LM193-RESCUE-kicad-pyspice-example
#
DEF LM193-RESCUE-kicad-pyspice-example U 0 20 Y Y 2 F N
F0 "U" 150 150 60 H V C CNN
F1 "LM193-RESCUE-kicad-pyspice-example" 200 -200 60 H V C CNN
F2 "" 0 0 60 H V C CNN
F3 "" 0 0 60 H V C CNN
DRAW
P 4 0 1 0 -200 200 200 0 -200 -200 -200 200 N
X ~ 1 500 0 300 L 40 40 1 1 C
X _ 2 -500 -100 300 R 40 40 1 1 I
X + 3 -500 100 300 R 40 40 1 1 I
X V- 4 -100 -400 250 U 40 40 1 1 W
X V+ 8 -100 400 250 D 40 40 1 1 W
X V- 4 -100 -400 250 U 40 40 2 1 W
X + 5 -500 100 300 R 40 40 2 1 I
X _ 6 -500 -100 300 R 40 40 2 1 I
X ~ 7 500 0 300 L 40 40 2 1 C
X V+ 8 -100 400 250 D 40 40 2 1 W
ENDDRAW
ENDDEF
#
# R-RESCUE-kicad-pyspice-example
#
DEF R-RESCUE-kicad-pyspice-example R 0 0 N Y 1 F N
F0 "R" 80 0 40 V V C CNN
F1 "R-RESCUE-kicad-pyspice-example" 7 1 40 V V C CNN
F2 "" -70 0 30 V V C CNN
F3 "" 0 0 30 H V C CNN
$FPLIST
 R?
 SM0603
 SM0805
 R?-*
 SM1206
$ENDFPLIST
DRAW
S -40 150 40 -150 0 1 12 N
X ~ 1 0 250 100 D 60 60 1 1 P
X ~ 2 0 -250 100 U 60 60 1 1 P
ENDDRAW
ENDDEF
#
# VCC
#
DEF VCC #PWR 0 0 Y Y 1 F P
F0 "#PWR" 0 -150 50 H I C CNN
F1 "VCC" 0 150 50 H V C CNN
F2 "" 0 0 50 H I C CNN
F3 "" 0 0 50 H I C CNN
DRAW
C 0 75 25 0 1 0 N
P 2 0 1 0 0 0 0 50 N
X VCC 1 0 0 0 U 50 50 1 1 W N
ENDDRAW
ENDDEF
#
# VSS
#
DEF VSS #PWR 0 0 Y Y 1 F P
F0 "#PWR" 0 -150 50 H I C CNN
F1 "VSS" 0 150 50 H V C CNN
F2 "" 0 0 50 H I C CNN
F3 "" 0 0 50 H I C CNN
DRAW
C 0 75 25 0 1 0 N
P 2 0 1 0 0 0 0 50 N
X VSS 1 0 0 0 U 50 50 1 1 W N
ENDDRAW
ENDDEF
#
#End Library
</file>

<file path="examples/spice-parser/kicad-pyspice-example/kicad-pyspice-example-rescue.lib">
EESchema-LIBRARY Version 2.3
#encoding utf-8
#
# LM193-RESCUE-kicad-pyspice-example
#
DEF LM193-RESCUE-kicad-pyspice-example U 0 20 Y Y 2 F N
F0 "U" 150 150 60 H V C CNN
F1 "LM193-RESCUE-kicad-pyspice-example" 200 -200 60 H V C CNN
F2 "" 0 0 60 H V C CNN
F3 "" 0 0 60 H V C CNN
DRAW
P 4 0 1 0 -200 200 200 0 -200 -200 -200 200 N
X ~ 1 500 0 300 L 40 40 1 1 C
X _ 2 -500 -100 300 R 40 40 1 1 I
X + 3 -500 100 300 R 40 40 1 1 I
X V- 4 -100 -400 250 U 40 40 1 1 W
X V+ 8 -100 400 250 D 40 40 1 1 W
X V- 4 -100 -400 250 U 40 40 2 1 W
X + 5 -500 100 300 R 40 40 2 1 I
X _ 6 -500 -100 300 R 40 40 2 1 I
X ~ 7 500 0 300 L 40 40 2 1 C
X V+ 8 -100 400 250 D 40 40 2 1 W
ENDDRAW
ENDDEF
#
#End Library
</file>

<file path="examples/spice-parser/kicad-pyspice-example/kicad-pyspice-example.cir">
* /home/gv/fabrice/developpement/PySpice/examples/spice-parser/kicad-pyspice-example/kicad-pyspice-example.cir

* EESchema Netlist Version 1.1 (Spice format) creation date: dim. 29 nov. 2015 18:04:33 CET

* To exclude a component from the Spice Netlist add [Spice_Netlist_Enabled] user FIELD set to: N
* To reorder the component spice node sequence add [Spice_Node_Sequence] user FIELD and define sequence: 2,1,0

* Sheet Name: /
X3  7 6 5 4 1 Opamp		
X1  2 5 5 JackIn		
X4  7 3 5 JackOut		
R2  6 7 50K		
R1  2 6 2K		
R3  5 3 2K		
X2  4 5 1 PowerIn		

.end
</file>

<file path="examples/spice-parser/kicad-pyspice-example/kicad-pyspice-example.pro">
update=lun. 31 juil. 2017 15:10:40 CEST
version=1
last_client=kicad
[pcbnew]
version=1
LastNetListRead=
UseCmpFile=1
PadDrill=0.600000000000
PadDrillOvalY=0.600000000000
PadSizeH=1.500000000000
PadSizeV=1.500000000000
PcbTextSizeV=1.500000000000
PcbTextSizeH=1.500000000000
PcbTextThickness=0.300000000000
ModuleTextSizeV=1.000000000000
ModuleTextSizeH=1.000000000000
ModuleTextSizeThickness=0.150000000000
SolderMaskClearance=0.000000000000
SolderMaskMinWidth=0.000000000000
DrawSegmentWidth=0.200000000000
BoardOutlineThickness=0.100000000000
ModuleOutlineThickness=0.150000000000
[pcbnew/libraries]
LibName1=connect
LibName2=discret
LibName3=pin_array
LibName4=divers
LibName5=smd_resistors
LibName6=smd_crystal&oscillator
LibName7=w_conn_av
LibName8=libcms
LibName9=dip_sockets
LibDir=
[cvpcb]
version=1
NetIExt=net
[cvpcb/libraries]
EquName1=devcms
[general]
version=1
[eeschema]
version=1
LibDir=
[eeschema/libraries]
LibName1=kicad-pyspice-example-rescue
LibName2=power
LibName3=device
LibName4=transistors
LibName5=conn
LibName6=linear
LibName7=regul
LibName8=74xx
LibName9=cmos4000
LibName10=adc-dac
LibName11=memory
LibName12=xilinx
</file>

<file path="examples/spice-parser/kicad-pyspice-example/kicad-pyspice-example.sch">
EESchema Schematic File Version 2
LIBS:kicad-pyspice-example-rescue
LIBS:power
LIBS:device
LIBS:transistors
LIBS:conn
LIBS:linear
LIBS:regul
LIBS:74xx
LIBS:cmos4000
LIBS:adc-dac
LIBS:memory
LIBS:xilinx
LIBS:kicad-pyspice-example-cache
EELAYER 25 0
EELAYER END
$Descr A4 11693 8268
encoding utf-8
Sheet 1 1
Title "Simple Opamp Harness"
Date "28 apr 2015"
Rev "1"
Comp "Horne Inc."
Comment1 ""
Comment2 ""
Comment3 ""
Comment4 ""
$EndDescr
$Comp
L LM193-RESCUE-kicad-pyspice-example X3
U 1 1 55381082
P 5450 3750
F 0 "X3" H 5600 3900 60  0000 C CNN
F 1 "Opamp" H 5650 3550 60  0000 C CNN
F 2 "~" H 5450 3750 60  0000 C CNN
F 3 "~" H 5450 3750 60  0000 C CNN
	1    5450 3750
	1    0    0    -1  
$EndComp
$Comp
L JACK_2P X1
U 1 1 5538123A
P 3150 3750
F 0 "X1" H 2800 3550 60  0000 C CNN
F 1 "JackIn" H 3000 4000 60  0000 C CNN
F 2 "~" H 3150 3750 60  0000 C CNN
F 3 "~" H 3150 3750 60  0000 C CNN
	1    3150 3750
	1    0    0    -1  
$EndComp
$Comp
L JACK_2P X4
U 1 1 553812AD
P 7300 3850
F 0 "X4" H 6950 3650 60  0000 C CNN
F 1 "JackOut" H 7150 4100 60  0000 C CNN
F 2 "~" H 7300 3850 60  0000 C CNN
F 3 "~" H 7300 3850 60  0000 C CNN
	1    7300 3850
	-1   0    0    1   
$EndComp
$Comp
L R-RESCUE-kicad-pyspice-example R2
U 1 1 553812CC
P 5850 4200
F 0 "R2" V 5930 4200 40  0000 C CNN
F 1 "50K" V 5857 4201 40  0000 C CNN
F 2 "~" V 5780 4200 30  0000 C CNN
F 3 "~" H 5850 4200 30  0000 C CNN
	1    5850 4200
	0    -1   -1   0   
$EndComp
$Comp
L R-RESCUE-kicad-pyspice-example R1
U 1 1 553812DB
P 4450 3850
F 0 "R1" V 4530 3850 40  0000 C CNN
F 1 "2K" V 4457 3851 40  0000 C CNN
F 2 "~" V 4380 3850 30  0000 C CNN
F 3 "~" H 4450 3850 30  0000 C CNN
	1    4450 3850
	0    -1   -1   0   
$EndComp
$Comp
L GND-RESCUE-kicad-pyspice-example #PWR01
U 1 1 553813CF
P 4750 4900
F 0 "#PWR01" H 4750 4900 30  0001 C CNN
F 1 "GND" H 4750 4830 30  0001 C CNN
F 2 "" H 4750 4900 60  0000 C CNN
F 3 "" H 4750 4900 60  0000 C CNN
	1    4750 4900
	1    0    0    -1  
$EndComp
$Comp
L VCC #PWR02
U 1 1 553813F7
P 5350 3250
F 0 "#PWR02" H 5350 3350 30  0001 C CNN
F 1 "VCC" H 5350 3350 30  0000 C CNN
F 2 "" H 5350 3250 60  0000 C CNN
F 3 "" H 5350 3250 60  0000 C CNN
	1    5350 3250
	1    0    0    -1  
$EndComp
Wire Wire Line
	6350 3750 6350 4200
Wire Wire Line
	6350 4200 6100 4200
Wire Wire Line
	5600 4200 4850 4200
Wire Wire Line
	4850 4200 4850 3850
Wire Wire Line
	4700 3850 4950 3850
Connection ~ 4850 3850
Wire Wire Line
	5350 3250 5350 3350
Connection ~ 6350 3750
Wire Wire Line
	3950 4750 6750 4750
Wire Wire Line
	4950 3650 4750 3650
Wire Wire Line
	4750 3650 4750 4900
Connection ~ 4750 4750
$Comp
L VCC #PWR03
U 1 1 5538160C
P 4200 2750
F 0 "#PWR03" H 4200 2850 30  0001 C CNN
F 1 "VCC" H 4200 2850 30  0000 C CNN
F 2 "" H 4200 2750 60  0000 C CNN
F 3 "" H 4200 2750 60  0000 C CNN
	1    4200 2750
	1    0    0    -1  
$EndComp
$Comp
L GND-RESCUE-kicad-pyspice-example #PWR04
U 1 1 55381612
P 4450 3150
F 0 "#PWR04" H 4450 3150 30  0001 C CNN
F 1 "GND" H 4450 3080 30  0001 C CNN
F 2 "" H 4450 3150 60  0000 C CNN
F 3 "" H 4450 3150 60  0000 C CNN
	1    4450 3150
	1    0    0    -1  
$EndComp
Wire Wire Line
	3850 2900 4200 2900
Wire Wire Line
	4200 2900 4200 2750
Wire Wire Line
	4200 3100 4200 3300
Wire Wire Line
	5950 3750 6850 3750
Wire Wire Line
	6850 3850 6550 3850
Wire Wire Line
	3600 3850 4200 3850
Wire Wire Line
	3600 3750 3950 3750
Wire Wire Line
	3950 3600 3950 4750
Wire Wire Line
	3600 3600 3950 3600
Connection ~ 3950 3750
Wire Wire Line
	6850 4000 6750 4000
Wire Wire Line
	6750 4000 6750 4750
$Comp
L R-RESCUE-kicad-pyspice-example R3
U 1 1 5538F1ED
P 6550 4300
F 0 "R3" V 6630 4300 40  0000 C CNN
F 1 "2K" V 6557 4301 40  0000 C CNN
F 2 "~" V 6480 4300 30  0000 C CNN
F 3 "~" H 6550 4300 30  0000 C CNN
	1    6550 4300
	-1   0    0    1   
$EndComp
Wire Wire Line
	6550 3850 6550 4050
Wire Wire Line
	6550 4550 6550 4750
Connection ~ 6550 4750
$Comp
L CONN_3 X2
U 1 1 553ABCED
P 3500 3000
F 0 "X2" V 3450 3000 50  0000 C CNN
F 1 "PowerIn" V 3550 3000 40  0000 C CNN
F 2 "~" H 3500 3000 60  0000 C CNN
F 3 "~" H 3500 3000 60  0000 C CNN
	1    3500 3000
	-1   0    0    1   
$EndComp
Wire Wire Line
	3850 3000 4450 3000
Wire Wire Line
	4450 3000 4450 3150
Wire Wire Line
	3850 3100 4200 3100
$Comp
L VSS #PWR05
U 1 1 553ABD92
P 4200 3300
F 0 "#PWR05" H 4200 3300 30  0001 C CNN
F 1 "VSS" H 4200 3230 30  0000 C CNN
F 2 "" H 4200 3300 60  0000 C CNN
F 3 "" H 4200 3300 60  0000 C CNN
	1    4200 3300
	-1   0    0    1   
$EndComp
$Comp
L VSS #PWR06
U 1 1 553ABD9F
P 5350 4500
F 0 "#PWR06" H 5350 4500 30  0001 C CNN
F 1 "VSS" H 5350 4430 30  0000 C CNN
F 2 "" H 5350 4500 60  0000 C CNN
F 3 "" H 5350 4500 60  0000 C CNN
	1    5350 4500
	-1   0    0    1   
$EndComp
Wire Wire Line
	5350 4150 5350 4500
$EndSCHEMATC
</file>

<file path="examples/spice-parser/kicad-spice-example/netlist/kicad-spice-example.default.cir">
* /home/gv/fabrice/developpement/PySpice/examples/spice-parser/kicad-spice-example/kicad-spice-example-0.cir

* EESchema Netlist Version 1.1 (Spice format) creation date: jeu. 26 nov. 2015 16:43:57 CET

* To exclude a component from the Spice Netlist add [Spice_Netlist_Enabled] user FIELD set to: N
* To reorder the component spice node sequence add [Spice_Node_Sequence] user FIELD and define sequence: 2,1,0
* 
* Bring in subckts for power, jacks and opamp
.include components.cir

* Sheet Name: /
U1  Net-_J2-Pad1_ Net-_R1-Pad2_ GND VSS VCC OPAMP		
J1  Net-_J1-Pad1_ GND GND JACK_IN		
J2  Net-_J2-Pad1_ Net-_J2-Pad2_ GND JACK_OUT		
R2  Net-_R1-Pad2_ Net-_J2-Pad1_ 50K		
R1  Net-_J1-Pad1_ Net-_R1-Pad2_ 2K		
R3  GND Net-_J2-Pad2_ 2K		
P1  VSS GND VCC PWR_IN		

.op

.tran 0.1m 3m
.plot tran V(7) V(2)

.ac dec 10 1 100K
.plot ac V(7)

.end
</file>

<file path="examples/spice-parser/kicad-spice-example/netlist/kicad-spice-example.number-node.cir">
* /home/gv/fabrice/developpement/PySpice/examples/spice-parser/kicad-spice-example/kicad-spice-example-3.cir

* EESchema Netlist Version 1.1 (Spice format) creation date: jeu. 26 nov. 2015 16:43:09 CET

* To exclude a component from the Spice Netlist add [Spice_Netlist_Enabled] user FIELD set to: N
* To reorder the component spice node sequence add [Spice_Node_Sequence] user FIELD and define sequence: 2,1,0
* 
* Bring in subckts for power, jacks and opamp
.include components.cir

* Sheet Name: /
XU1  7 6 5 4 1 OPAMP		
J1  2 5 5 JACK_IN		
J2  7 3 5 JACK_OUT		
R2  6 7 50K		
R1  2 6 2K		
R3  5 3 2K		
P1  4 5 1 PWR_IN		

.op

.tran 0.1m 3m
.plot tran V(7) V(2)

.ac dec 10 1 100K
.plot ac V(7)

.end
</file>

<file path="examples/spice-parser/kicad-spice-example/netlist/kicad-spice-example.using-X.cir">
* /home/gv/fabrice/developpement/PySpice/examples/spice-parser/kicad-spice-example/kicad-spice-example-2.cir

* EESchema Netlist Version 1.1 (Spice format) creation date: jeu. 26 nov. 2015 16:42:56 CET

* To exclude a component from the Spice Netlist add [Spice_Netlist_Enabled] user FIELD set to: N
* To reorder the component spice node sequence add [Spice_Node_Sequence] user FIELD and define sequence: 2,1,0
* 
* Bring in subckts for power, jacks and opamp
.include components.cir

* Sheet Name: /
XU1  Net-_J2-Pad1_ Net-_R1-Pad2_ GND VSS VCC OPAMP		
J1  Net-_J1-Pad1_ GND GND JACK_IN		
J2  Net-_J2-Pad1_ Net-_J2-Pad2_ GND JACK_OUT		
R2  Net-_R1-Pad2_ Net-_J2-Pad1_ 50K		
R1  Net-_J1-Pad1_ Net-_R1-Pad2_ 2K		
R3  GND Net-_J2-Pad2_ 2K		
P1  VSS GND VCC PWR_IN		

.op

.tran 0.1m 3m
.plot tran V(7) V(2)

.ac dec 10 1 100K
.plot ac V(7)

.end
</file>

<file path="examples/spice-parser/kicad-spice-example/spice/components.cir">
* Components and subcircuits for use in example.cir

.INCLUDE LMV981.MOD

* 4 0 1 PWR_IN
*              + g -     
.subckt PWR_IN 1 2 3
  Vneg 1 2  3.3V
  Vpos 2 3 3.3V
.ends PWR_IN

* 7 6 0 4 1 OPAMP
*             o - + p n
.subckt OPAMP 1 2 3 4 5
  * PINOUT ORDER  1   3   6  2  4   5
  * PINOUT ORDER +IN -IN +V -V OUT NSD
  Xopamp 3 2 4 5 1 NSD LMV981
.ends OPAMP

*               s x g
.subckt JACK_IN 1 2 3
  *** Simulate mic input A-note
  Vmic  3 1 ac SIN(0 0.02 440)
.ends JACK_IN

*                s x g
.subckt JACK_OUT 1 2 3
  Rwire  1 2   10ohm
.ends JACK_OUT
</file>

<file path="examples/spice-parser/kicad-spice-example/spice/example.cir">
* EESchema Netlist Version 1.1 (Spice format) creation date: Mon 27 Apr 2015 06:01:42 AM JST

* To exclude a component from the Spice Netlist add [Spice_Netlist_Enabled] user FIELD set to: N
* To reorder the component spice node sequence add [Spice_Node_Sequence] user FIELD and define sequence: 2,1,0
* Bring in subckts for power, jacks and opamp
.include components.cir

*Sheet Name:/
XU1  7 6 0 4 1 OPAMP		
XJ1  2 0 0 JACK_IN		
XJ2  7 3 0 JACK_OUT		
R2  6 7 50K		
R1  2 6 2K		
R3  0 3 2K		
XP1  4 0 1 PWR_IN		

.op

.tran 0.1m 3m
.plot tran V(7) V(2)

.ac dec 10 1 100K
.plot ac V(7)

.end
</file>

<file path="examples/spice-parser/kicad-spice-example/spice/LMV981.MOD">
*Rev-B, March-2010
*Modified notes
*
*//////////////////////////////////////////////////////////////////////
* (C) National Semiconductor, Corporation.
* Models developed and under copyright by:
* National Semiconductor, Corporation.  
*/////////////////////////////////////////////////////////////////////
* Legal Notice:  
* The model may be copied, and distributed without any modifications;
* however, reselling or licensing the material is illegal.
* We reserve the right to make changes to the model without prior notice. 
* Pspice Models are provided "AS IS, WITH NO WARRANTY OF ANY KIND" 
*////////////////////////////////////////////////////////////////////
* For more information, and our latest models,
* please visit the models section of our website at
*       http://www.national.com/models/
*////////////////////////////////////////////////////////////////////
* BEGIN LMV981 MODEL
* MODEL TEMPERATURE RANGE IS -40 C TO +125 C, NOT ALL PARAMETERS TRACK THOSE 
* OF THE REAL PART VS TEMPERATURE
* FEATURES:
* OPEN LOOP GAIN AND PHASE, INPUT BIAS CURRENT, INPUT CAPACITANCE
* INPUT COMMON MODE VOLT RANGE, RAIL TO RAIL INPUT STAGE, WITH OFFSET TRANSITION
* INPUT CLAMPS TO RAILS,  CMRR WITH FREQUENCY EFFECTS, PSRR WITH FREQUENCY
* EFFECTS, SLEW RATE, QUIESCENT CURRENT, RAIL TO RAIL OUTPUT STAGE, HIGH CLOAD
* EFFECTS, CLASS AB BIAS IN OUTPUT STAGE, OUTPUT CURRENT THROUGH SUPPLIES
* OUTPUT CURRENT LIMITING, OUTPUT CLAMPS TO RAILS, OUTPUT SWING VS OUTPUT CURRENT
* SHUTDOWN, ENABLE TIME, QUIESCENT CURRENT DURING SHUTDOWN
*///////////////////////////////////////////////////////////////////////////
*
* PINOUT ORDER +IN -IN +V -V OUT NSD
* PINOUT ORDER  1   3   6  2  4   5
.SUBCKT LMV981 1 3 6 2 4 5
Q20 7 8 9 QLN
R3 10 11 2
R4 12 11 2
R10 8 13 1E3
R11 14 15 1E3
R12 16 6 4
R13 2 17 4
R16 18 19 300
R17 20 21 4
R18 9 22 4
D5 23 6 DD
D6 2 23 DD
D7 24 0 DIN
D8 25 0 DIN
I8 0 24 0.1E-3
I9 0 25 0.1E-3
E2 9 0 2 0 1
E3 21 0 6 0 1
D9 26 0 DVN
D10 27 0 DVN
I10 0 26 0.1E-3
I11 0 27 0.1E-3
E4 28 3 26 27 0.08
G2 29 3 24 25 4E-5
R22 2 6 100E6
E5 30 0 21 0 1
E6 31 0 9 0 1
E7 32 0 33 0 1
R30 30 34 1E5
R31 31 35 1E5
R32 32 36 1E5
R33 0 34 10
R34 0 35 10
R35 0 36 10
E10 37 1 36 0 0.3
R36 38 33 1K
R37 33 39 1K
C6 30 34 1E-12
C7 31 35 2E-12
C8 32 36 200E-12
E11 40 37 35 0 1.2
E12 29 40 34 0 0.8
E14 41 9 21 9 0.5
D11 18 21 DD
D12 9 18 DD
M1 42 43 17 17 NOUT L=3U W=700U
M2 44 45 16 16 POUT L=3U W=1400U
M3 46 46 20 20 POUT L=3U W=1400U
M4 47 48 10 10 PIN L=3U W=220U
M5 49 50 12 12 PIN L=3U W=220U
M8 51 51 22 22 NOUT L=3U W=700U
R43 52 45 100
R44 53 43 100
G3 18 41 54 41 0.2E-3
R45 41 18 60E6
C12 19 23 33E-12
R46 9 47 2E3
R47 9 49 2E3
C13 47 49 1E-12
C14 29 0 3E-12
C15 28 0 3E-12
C16 23 0 0.5E-12
D13 43 7 DD
D14 55 45 DD
Q15 55 15 21 QLP
V18 29 56 1E-3
M19 57 58 21 21 PIN L=6U W=500U
E17 39 0 29 0 1
E18 38 0 3 0 1
M23 58 58 21 21 PIN L=6U W=500U
V21 57 11 0
R59 23 44 20
R60 42 23 20
J1 59 29 59 JNC
J2 59 28 59 JNC
J3 28 60 28 JNC
J4 29 60 29 JNC
C21 29 61 1E-12
E20 62 41 49 47 1
R62 62 54 1E4
C23 54 41 5E-12
G7 63 41 18 41 -1E-3
G8 41 64 18 41 1E-3
G9 41 65 51 9 1E-3
G10 66 41 21 46 1E-3
D17 66 63 DD
D18 64 65 DD
R66 63 66 100E6
R67 65 64 100E6
R68 66 21 1E3
R69 9 65 1E3
E23 21 52 21 66 1
E24 53 9 65 9 1
R70 64 41 1E6
R71 65 41 1E6
R72 41 66 1E6
R73 41 63 1E6
G11 6 2 67 0 -0.1E-3
R75 40 29 1E9
R76 37 40 1E9
R77 1 37 1E9
R78 3 28 1E9
R79 41 54 1E9
R81 52 21 1E9
R82 9 53 1E9
R83 33 0 1E9
G14 58 9 67 0 35E-6
G15 46 51 67 0 220E-6
E48 68 18 67 0 30
E49 69 41 67 0 -30
V49 70 69 15
V50 71 68 -15
R127 68 0 1E12
R128 69 0 1E12
M41 41 71 18 72 PSW L=1.5U W=150U
M42 18 70 41 73 NSW L=1.5U
R129 72 0 1E12
R130 73 0 1E12
M43 74 5 9 9 NEN L=3U W=300U
M44 75 76 9 9 NEN L=3U W=3000U
R131 74 21 1E4
R132 75 77 1E6
V51 77 9 1
M45 78 78 21 21 PEN L=6U W=60U
M46 5 78 21 21 PEN L=6U W=60U
I20 78 9 0.2E-6
C26 5 0 1E-12
E50 67 0 79 9 1
V52 75 79 1.111E-6
R133 9 79 1E12
C32 21 74 15E-12
C33 77 75 3F
I21 6 2 0.2E-6
L1 23 4 4E-9
R150 23 4 400
V78 21 59 0.05
V79 60 9 0.05
R155 46 21 1E8
R156 9 51 1E8
R157 17 43 1E8
R158 16 45 1E8
RG1 0 67 1E9
R159 61 28 100
R225 50 28 64
R226 48 56 64
I40 28 0 15E-9
I47 29 0 15E-9
M48 80 81 2 2 NIQS L=3U W=1000
R297 80 6 8E6
E94 81 2 67 0 2
M49 82 74 9 9 NEN L=3U W=300U
M50 76 82 9 9 NEN L=3U W=300U
R298 82 77 1E4
R299 76 77 1E4
C35 77 82 535P
M51 83 84 85 85 NIN L=3U W=220U
M52 86 87 88 88 NIN L=3U W=220U
R300 89 85 2
R301 89 88 2
R302 83 21 2E3
R303 86 21 2E3
C36 83 86 1E-12
G36 18 41 90 41 0.2E-3
R304 41 90 1E9
C37 90 41 5E-12
E97 91 41 86 83 1
R305 91 90 1E4
V115 92 56 0.25E-3
R306 28 87 64
R307 92 84 64
M53 93 94 95 95 PIN L=6U W=500U
R308 95 57 2E3
V116 21 94 1.0
M54 93 93 9 9 NIN L=3U W=500U
M55 89 93 9 9 NIN L=3U W=500U
E98 21 14 6 16 0.9
E99 13 9 17 2 3
.MODEL DVN D KF=8E-12 IS=1E-16
.MODEL DD D
.MODEL DIN D
.MODEL QLN NPN
.MODEL QLP PNP
.MODEL JNC NJF
.MODEL POUT PMOS KP=200U VTO=-0.7
.MODEL NOUT NMOS KP=200U VTO=0.7
.MODEL PIN PMOS KP=200U VTO=-0.7
.MODEL NIN NMOS KP=200U VTO=0.7
.MODEL NIQS NMOS KP=200U VTO=0.7 IS=1E-18
.MODEL NEN NMOS KP=200U VTO=0.5 IS=1E-18
.MODEL PEN PMOS KP=200U VTO=-0.7 IS=1E-18
.MODEL PSW PMOS KP=200U VTO=-7.5 IS=1E-18
.MODEL NSW NMOS KP=200U VTO=7.5 IS=1E-18
.ENDS
* END LMV981 MODEL
</file>

<file path="examples/spice-parser/kicad-spice-example/spice/run.sh">
echo 'Enter'
echo '> tran 0.3m 3m'
echo '> plot V(2) V(7)'
ngspice example.cir
</file>

<file path="examples/spice-parser/kicad-spice-example/kicad-spice-example-cache.lib">
EESchema-LIBRARY Version 2.3
#encoding utf-8
#
# CONN_3
#
DEF CONN_3 K 0 40 Y N 1 F N
F0 "K" -50 0 50 V V C CNN
F1 "CONN_3" 50 0 40 V V C CNN
F2 "" 0 0 60 H V C CNN
F3 "" 0 0 60 H V C CNN
DRAW
S -100 150 100 -150 0 1 0 N
X P1 1 -350 100 250 R 60 60 1 1 P I
X PM 2 -350 0 250 R 60 60 1 1 P I
X P3 3 -350 -100 250 R 60 60 1 1 P I
ENDDRAW
ENDDEF
#
# GND-RESCUE-kicad-spice-example
#
DEF ~GND-RESCUE-kicad-spice-example #PWR 0 0 Y Y 1 F P
F0 "#PWR" 0 0 30 H I C CNN
F1 "GND-RESCUE-kicad-spice-example" 0 -70 30 H I C CNN
F2 "" 0 0 60 H V C CNN
F3 "" 0 0 60 H V C CNN
DRAW
P 4 0 1 0  -50 0  0 -50  50 0  -50 0 N
X GND 1 0 0 0 U 30 30 1 1 W N
ENDDRAW
ENDDEF
#
# JACK_2P
#
DEF JACK_2P J 0 40 Y Y 1 F N
F0 "J" -350 -200 50 H V C CNN
F1 "JACK_2P" -150 250 50 H V C CNN
F2 "" 0 0 60 H V C CNN
F3 "" 0 0 60 H V C CNN
DRAW
S -450 150 -400 -100 0 1 0 F
S 300 -150 -400 200 0 1 0 N
P 3 0 1 0  150 0  300 0  300 0 N
P 4 0 1 0  0 -100  -50 -50  -100 -100  -100 -100 N
P 4 0 1 0  0 -100  300 -100  300 -100  300 -100 N
P 4 0 1 0  50 -50  100 -100  150 -50  150 -50 N
P 4 0 1 0  150 0  100 0  100 -100  100 -100 N
P 5 0 1 0  300 150  -250 150  -300 100  -350 150  -350 150 N
X ~ 1 450 -100 150 L 50 50 1 1 P
X ~ 2 450 0 150 L 50 50 1 1 P
X ~ 3 450 150 150 L 50 50 1 1 P
ENDDRAW
ENDDEF
#
# LM2903
#
DEF LM2903 U 0 20 Y Y 2 F N
F0 "U" 150 150 60 H V C CNN
F1 "LM2903" 200 -200 60 H V C CNN
F2 "" 0 0 60 H V C CNN
F3 "" 0 0 60 H V C CNN
ALIAS LM293 LM393 LM193
DRAW
P 4 0 1 0  -200 200  200 0  -200 -200  -200 200 N
X ~ 1 500 0 300 L 40 40 1 1 C
X _ 2 -500 -100 300 R 40 40 1 1 I
X + 3 -500 100 300 R 40 40 1 1 I
X V- 4 -100 -400 250 U 40 40 1 1 W
X V+ 8 -100 400 250 D 40 40 1 1 W
X V- 4 -100 -400 250 U 40 40 2 1 W
X + 5 -500 100 300 R 40 40 2 1 I
X _ 6 -500 -100 300 R 40 40 2 1 I
X ~ 7 500 0 300 L 40 40 2 1 C
X V+ 8 -100 400 250 D 40 40 2 1 W
ENDDRAW
ENDDEF
#
# R-RESCUE-kicad-spice-example
#
DEF R-RESCUE-kicad-spice-example R 0 0 N Y 1 F N
F0 "R" 80 0 40 V V C CNN
F1 "R-RESCUE-kicad-spice-example" 7 1 40 V V C CNN
F2 "" -70 0 30 V V C CNN
F3 "" 0 0 30 H V C CNN
$FPLIST
 R?
 SM0603
 SM0805
 R?-*
 SM1206
$ENDFPLIST
DRAW
S -40 150 40 -150 0 1 12 N
X ~ 1 0 250 100 D 60 60 1 1 P
X ~ 2 0 -250 100 U 60 60 1 1 P
ENDDRAW
ENDDEF
#
# VCC
#
DEF VCC #PWR 0 0 Y Y 1 F P
F0 "#PWR" 0 -150 50 H I C CNN
F1 "VCC" 0 150 50 H V C CNN
F2 "" 0 0 60 H V C CNN
F3 "" 0 0 60 H V C CNN
DRAW
C 0 75 25 0 1 0 N
P 2 0 1 0  0 0  0 50 N
X VCC 1 0 0 0 U 50 50 1 1 W N
ENDDRAW
ENDDEF
#
# VSS
#
DEF VSS #PWR 0 0 Y Y 1 F P
F0 "#PWR" 0 -150 50 H I C CNN
F1 "VSS" 0 150 50 H V C CNN
F2 "" 0 0 60 H V C CNN
F3 "" 0 0 60 H V C CNN
DRAW
C 0 75 25 0 1 0 N
P 2 0 1 0  0 0  0 50 N
X VSS 1 0 0 0 U 50 50 1 1 W N
ENDDRAW
ENDDEF
#
#End Library
</file>

<file path="examples/spice-parser/kicad-spice-example/kicad-spice-example-rescue.lib">
EESchema-LIBRARY Version 2.3
#encoding utf-8
#
# GND-RESCUE-kicad-spice-example
#
DEF ~GND-RESCUE-kicad-spice-example #PWR 0 0 Y Y 1 F P
F0 "#PWR" 0 0 30 H I C CNN
F1 "GND-RESCUE-kicad-spice-example" 0 -70 30 H I C CNN
F2 "" 0 0 60 H V C CNN
F3 "" 0 0 60 H V C CNN
DRAW
P 4 0 1 0  -50 0  0 -50  50 0  -50 0 N
X GND 1 0 0 0 U 30 30 1 1 W N
ENDDRAW
ENDDEF
#
# R-RESCUE-kicad-spice-example
#
DEF R-RESCUE-kicad-spice-example R 0 0 N Y 1 F N
F0 "R" 80 0 40 V V C CNN
F1 "R-RESCUE-kicad-spice-example" 7 1 40 V V C CNN
F2 "" -70 0 30 V V C CNN
F3 "" 0 0 30 H V C CNN
$FPLIST
 R?
 SM0603
 SM0805
 R?-*
 SM1206
$ENDFPLIST
DRAW
S -40 150 40 -150 0 1 12 N
X ~ 1 0 250 100 D 60 60 1 1 P
X ~ 2 0 -250 100 U 60 60 1 1 P
ENDDRAW
ENDDEF
#
#End Library
</file>

<file path="examples/spice-parser/kicad-spice-example/kicad-spice-example.pro">
update=jeu. 26 nov. 2015 16:40:27 CET
version=1
last_client=kicad
[pcbnew]
version=1
LastNetListRead=
UseCmpFile=1
PadDrill=0.600000000000
PadDrillOvalY=0.600000000000
PadSizeH=1.500000000000
PadSizeV=1.500000000000
PcbTextSizeV=1.500000000000
PcbTextSizeH=1.500000000000
PcbTextThickness=0.300000000000
ModuleTextSizeV=1.000000000000
ModuleTextSizeH=1.000000000000
ModuleTextSizeThickness=0.150000000000
SolderMaskClearance=0.000000000000
SolderMaskMinWidth=0.000000000000
DrawSegmentWidth=0.200000000000
BoardOutlineThickness=0.100000000000
ModuleOutlineThickness=0.150000000000
[pcbnew/libraries]
LibName1=connect
LibName2=discret
LibName3=pin_array
LibName4=divers
LibName5=smd_resistors
LibName6=smd_crystal&oscillator
LibName7=w_conn_av
LibName8=libcms
LibName9=dip_sockets
LibDir=
[cvpcb]
version=1
NetIExt=net
[cvpcb/libraries]
EquName1=devcms
[eeschema]
version=1
LibDir=
[eeschema/libraries]
LibName1=kicad-spice-example-rescue
LibName2=power
LibName3=device
LibName4=transistors
LibName5=conn
LibName6=linear
LibName7=regul
LibName8=74xx
LibName9=cmos4000
LibName10=adc-dac
LibName11=memory
LibName12=xilinx
LibName14=microcontrollers
LibName15=dsp
LibName16=microchip
LibName17=analog_switches
LibName18=motorola
LibName19=texas
LibName20=intel
LibName21=audio
LibName22=interface
LibName23=digital-audio
LibName24=philips
LibName25=display
LibName26=cypress
LibName27=siliconi
LibName28=opto
LibName29=atmel
LibName30=contrib
LibName31=valves
[general]
version=1
</file>

<file path="examples/spice-parser/kicad-spice-example/kicad-spice-example.sch">
EESchema Schematic File Version 2
LIBS:kicad-spice-example-rescue
LIBS:power
LIBS:device
LIBS:transistors
LIBS:conn
LIBS:linear
LIBS:regul
LIBS:74xx
LIBS:cmos4000
LIBS:adc-dac
LIBS:memory
LIBS:xilinx
LIBS:microcontrollers
LIBS:dsp
LIBS:microchip
LIBS:analog_switches
LIBS:motorola
LIBS:texas
LIBS:intel
LIBS:audio
LIBS:interface
LIBS:digital-audio
LIBS:philips
LIBS:display
LIBS:cypress
LIBS:siliconi
LIBS:opto
LIBS:atmel
LIBS:contrib
LIBS:valves
LIBS:kicad-spice-example-cache
EELAYER 25 0
EELAYER END
$Descr A4 11693 8268
encoding utf-8
Sheet 1 1
Title "Simple Opamp Harness"
Date "28 apr 2015"
Rev "1"
Comp "Horne Inc."
Comment1 ""
Comment2 ""
Comment3 ""
Comment4 ""
$EndDescr
$Comp
L LM193 U1
U 1 1 55381082
P 5450 3750
F 0 "U1" H 5600 3900 60  0000 C CNN
F 1 "OPAMP" H 5650 3550 60  0000 C CNN
F 2 "~" H 5450 3750 60  0000 C CNN
F 3 "~" H 5450 3750 60  0000 C CNN
	1    5450 3750
	1    0    0    -1  
$EndComp
$Comp
L JACK_2P J1
U 1 1 5538123A
P 3150 3750
F 0 "J1" H 2800 3550 60  0000 C CNN
F 1 "JACK_IN" H 3000 4000 60  0000 C CNN
F 2 "~" H 3150 3750 60  0000 C CNN
F 3 "~" H 3150 3750 60  0000 C CNN
	1    3150 3750
	1    0    0    -1  
$EndComp
$Comp
L JACK_2P J2
U 1 1 553812AD
P 7300 3850
F 0 "J2" H 6950 3650 60  0000 C CNN
F 1 "JACK_OUT" H 7150 4100 60  0000 C CNN
F 2 "~" H 7300 3850 60  0000 C CNN
F 3 "~" H 7300 3850 60  0000 C CNN
	1    7300 3850
	-1   0    0    1   
$EndComp
$Comp
L R-RESCUE-kicad-spice-example R2
U 1 1 553812CC
P 5900 4350
F 0 "R2" V 5980 4350 40  0000 C CNN
F 1 "50K" V 5907 4351 40  0000 C CNN
F 2 "~" V 5830 4350 30  0000 C CNN
F 3 "~" H 5900 4350 30  0000 C CNN
	1    5900 4350
	0    -1   -1   0   
$EndComp
$Comp
L R-RESCUE-kicad-spice-example R1
U 1 1 553812DB
P 4450 3850
F 0 "R1" V 4530 3850 40  0000 C CNN
F 1 "2K" V 4457 3851 40  0000 C CNN
F 2 "~" V 4380 3850 30  0000 C CNN
F 3 "~" H 4450 3850 30  0000 C CNN
	1    4450 3850
	0    -1   -1   0   
$EndComp
$Comp
L GND-RESCUE-kicad-spice-example #PWR01
U 1 1 553813CF
P 4750 4900
F 0 "#PWR01" H 4750 4900 30  0001 C CNN
F 1 "GND" H 4750 4830 30  0001 C CNN
F 2 "" H 4750 4900 60  0000 C CNN
F 3 "" H 4750 4900 60  0000 C CNN
	1    4750 4900
	1    0    0    -1  
$EndComp
$Comp
L VCC #PWR02
U 1 1 553813F7
P 5350 2750
F 0 "#PWR02" H 5350 2850 30  0001 C CNN
F 1 "VCC" H 5350 2850 30  0000 C CNN
F 2 "" H 5350 2750 60  0000 C CNN
F 3 "" H 5350 2750 60  0000 C CNN
	1    5350 2750
	1    0    0    -1  
$EndComp
Wire Wire Line
	6350 3750 6350 4350
Wire Wire Line
	6350 4350 6150 4350
Wire Wire Line
	5650 4350 4850 4350
Wire Wire Line
	4850 4350 4850 3850
Wire Wire Line
	4700 3850 4950 3850
Connection ~ 4850 3850
Wire Wire Line
	5350 2750 5350 3350
Connection ~ 6350 3750
Wire Wire Line
	3950 4750 6750 4750
Wire Wire Line
	4950 3650 4750 3650
Wire Wire Line
	4750 3650 4750 4900
Connection ~ 4750 4750
$Comp
L VCC #PWR03
U 1 1 5538160C
P 4200 2750
F 0 "#PWR03" H 4200 2850 30  0001 C CNN
F 1 "VCC" H 4200 2850 30  0000 C CNN
F 2 "" H 4200 2750 60  0000 C CNN
F 3 "" H 4200 2750 60  0000 C CNN
	1    4200 2750
	1    0    0    -1  
$EndComp
$Comp
L GND-RESCUE-kicad-spice-example #PWR04
U 1 1 55381612
P 4450 3150
F 0 "#PWR04" H 4450 3150 30  0001 C CNN
F 1 "GND" H 4450 3080 30  0001 C CNN
F 2 "" H 4450 3150 60  0000 C CNN
F 3 "" H 4450 3150 60  0000 C CNN
	1    4450 3150
	1    0    0    -1  
$EndComp
Wire Wire Line
	3850 2900 4200 2900
Wire Wire Line
	4200 2900 4200 2750
Wire Wire Line
	4200 3100 4200 3300
Wire Wire Line
	6850 3750 5950 3750
Wire Wire Line
	6850 3850 6550 3850
Wire Wire Line
	3600 3850 4200 3850
Wire Wire Line
	3600 3750 3950 3750
Wire Wire Line
	3950 3600 3950 4750
Wire Wire Line
	3600 3600 3950 3600
Connection ~ 3950 3750
Wire Wire Line
	6850 4000 6750 4000
Wire Wire Line
	6750 4000 6750 4750
$Comp
L R-RESCUE-kicad-spice-example R3
U 1 1 5538F1ED
P 6550 4300
F 0 "R3" V 6630 4300 40  0000 C CNN
F 1 "2K" V 6557 4301 40  0000 C CNN
F 2 "~" V 6480 4300 30  0000 C CNN
F 3 "~" H 6550 4300 30  0000 C CNN
	1    6550 4300
	-1   0    0    1   
$EndComp
Wire Wire Line
	6550 3850 6550 4050
Wire Wire Line
	6550 4550 6550 4750
Connection ~ 6550 4750
$Comp
L CONN_3 P1
U 1 1 553ABCED
P 3500 3000
F 0 "P1" V 3450 3000 50  0000 C CNN
F 1 "PWR_IN" V 3550 3000 40  0000 C CNN
F 2 "~" H 3500 3000 60  0000 C CNN
F 3 "~" H 3500 3000 60  0000 C CNN
	1    3500 3000
	-1   0    0    1   
$EndComp
Wire Wire Line
	3850 3000 4450 3000
Wire Wire Line
	4450 3000 4450 3150
Wire Wire Line
	3850 3100 4200 3100
$Comp
L VSS #PWR05
U 1 1 553ABD92
P 4200 3300
F 0 "#PWR05" H 4200 3300 30  0001 C CNN
F 1 "VSS" H 4200 3230 30  0000 C CNN
F 2 "" H 4200 3300 60  0000 C CNN
F 3 "" H 4200 3300 60  0000 C CNN
	1    4200 3300
	1    0    0    -1  
$EndComp
$Comp
L VSS #PWR06
U 1 1 553ABD9F
P 5350 4900
F 0 "#PWR06" H 5350 4900 30  0001 C CNN
F 1 "VSS" H 5350 4830 30  0000 C CNN
F 2 "" H 5350 4900 60  0000 C CNN
F 3 "" H 5350 4900 60  0000 C CNN
	1    5350 4900
	1    0    0    -1  
$EndComp
Wire Wire Line
	5350 4150 5350 4900
Text Notes 8450 1400 0    60   ~ 0
+PSPICE \n.op\n\n.tran 0.1m 3m\n.plot tran V(7) V(2)\n\n.ac dec 10 1 100K\n.plot ac V(7)\n
Text Notes 8450 900  0    60   ~ 0
-PSPICE\n* \n* Bring in subckts for power, jacks and opamp\n.include components.cir\n
$EndSCHEMATC
</file>

<file path="examples/spice-parser/kicad-spice-example/README.txt">
This example comes from https://github.com/stffrdhrn/kicad-spice-demo

Note: We have to prexix manually Ji by X.
</file>

<file path="examples/spice-parser/bootstrap-example.py">
####################################################################################################
#r#
#r# ========================================
#r#  Spice Netlist Parser Bootstrap Example
#r# ========================================
#r#
#r# This example shows a bootstrap of a netlist, i.e. we parse the netlist generated by PySpice
#r# and we regenerate it.
#r#
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Spice.Parser import SpiceParser
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
circuit = Circuit('STM AN1476: Low-Cost Power Supply For Home Appliances')
circuit.include(spice_library['1N4148'])
# 1N5919B: 5.6 V, 3.0 W Zener Diode Voltage Regulator
circuit.include(spice_library['d1n5919brl'])
ac_line = circuit.AcLine('input', 'out', 'in', rms_voltage=230, frequency=50)
circuit.R('load', 'out', circuit.gnd, kilo(1))
circuit.C('load', 'out', circuit.gnd, micro(220))
circuit.X('D1', '1N4148', circuit.gnd, 1)
circuit.D(1, circuit.gnd, 1, model='DIODE1', off=True)
circuit.X('Dz1', 'd1n5919brl', 1, 'out')
circuit.C('ac', 1, 2, nano(470))
circuit.R('ac', 2, 'in', 470) # Fixme: , m=1, temperature='{25}'
source = str(circuit)
print(source)
####################################################################################################
parser = SpiceParser(source=source)
bootstrap_circuit = parser.build_circuit()
bootstrap_source = str(bootstrap_circuit)
print(bootstrap_source)
assert(source == bootstrap_source)
</file>

<file path="examples/spice-parser/index.rst">
This section shows how to use the Spice netlist parser.

.. end
</file>

<file path="examples/spice-parser/kicad-example.py">
#r#
#r# ==============================
#r#  Kicad Netlist Parser Example
#r# ==============================
#r#
#r# This example shows how to read a netlist generated from the |Kicad|_ Schematic Editor.
#r#
#r# This example is copied from Stafford Horne's Blog:
#r#  * http://stffrdhrn.github.io/electronics/2015/04/28/simulating_kicad_schematics_in_spice.html
#r#  * https://github.com/stffrdhrn/kicad-spice-demo
#r#
#r# .. note:: The netlist must be generated using numbered node. Subcircuit elements must have a
#r#           reference starting by *X* and a value corresponding to the subcircuit's name.
#r#
#f# image('kicad-pyspice-example/kicad-pyspice-example.sch.svg')
#r# The netlist generated by Kicad is the following:
#f# getthecode('kicad-pyspice-example/kicad-pyspice-example.cir')
####################################################################################################
from pathlib import Path
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import SubCircuitFactory
from PySpice.Spice.Parser import SpiceParser
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
#r# We implement the *PowerIn*, *Opamp*, *JackIn* and *JackOut* elements as subcircuit.
class PowerIn(SubCircuitFactory):
    NAME = 'PowerIn'
    NODES = ('output_plus', 'ground', 'output_minus')
    ##############################################
    def __init__(self):
        super().__init__()
        self.V('positive', 'output_plus', 'ground', 3.3@u_V)
        self.V('negative', 'ground', 'output_minus', 3.3@u_V)
####################################################################################################
class Opamp(SubCircuitFactory):
    NAME = 'Opamp'
    NODES = ('output',
                 'input_negative', 'input_positive',
                 'power_positive', 'power_negative')
    ##############################################
    def __init__(self):
        super().__init__()
        self.X('opamp', 'LMV981',
               'input_positive', 'input_negative',
               'power_positive', 'power_negative',
               'output',
               'NSD')
####################################################################################################
class JackIn(SubCircuitFactory):
    NAME = 'JackIn'
    NODES = ('input', 'x', 'ground')
    ##############################################
    def __init__(self):
        super().__init__()
        # could use SinusoidalVoltageSource as well
        self.V('micro', 'ground', 'input', 'DC 0V AC 1V SIN(0 0.02 440)')
####################################################################################################
class JackOut(SubCircuitFactory):
    NAME = 'JackOut'
    NODES = ('output', 'x', 'ground')
    ##############################################
    def __init__(self):
        super().__init__()
        self.R('load', 'output', 'x', 10@u_Ω)
####################################################################################################
#r# We read the generated netlist.
directory_path = Path(__file__).resolve().parent
kicad_netlist_path = directory_path.joinpath('kicad-pyspice-example', 'kicad-pyspice-example.cir')
parser = SpiceParser(path=str(kicad_netlist_path))
#r# We build the circuit and translate the ground (5 to 0).
circuit = parser.build_circuit(ground=5)
#r# We include the operational amplifier module.
circuit.include(spice_library['LMV981'])
#r# We define the subcircuits.
for subcircuit in (PowerIn(), Opamp(), JackIn(), JackOut()):
    circuit.subcircuit(subcircuit)
# print(str(circuit))
#r# We perform a transient simulation.
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=100@u_us, end_time=3@u_ms)
figure, ax = plt.subplots(figsize=(20, 10))
ax.plot(analysis['2']) # JackIn input
ax.plot(analysis['7']) # Opamp output
ax.legend(('Vin [V]', 'Vout [V]'), loc=(.8,.8))
ax.grid()
ax.set_xlabel('t [s]')
ax.set_ylabel('[V]')
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'kicad-example.png')
</file>

<file path="examples/switched-power-supplies/buck-converter.py">
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
#?# circuit_macros('buck-converter.m4')
circuit = Circuit('Buck Converter')
circuit.include(spice_library['1N5822']) # Schottky diode
circuit.include(spice_library['irf150'])
# From Microchip WebSeminars - Buck Converter Design Example
Vin = 12@u_V
Vout = 5@u_V
ratio = Vout / Vin
Iload = 2@u_A
Rload = Vout / (.8 * Iload)
frequency = 400@u_kHz
period = frequency.period
duty_cycle = ratio * period
ripple_current = .3 * Iload # typically 30 %
ripple_voltage = 50@u_mV
print('ratio =', ratio)
print('RLoad =', Rload)
print('period =', period.canonise())
print('duty_cycle =', duty_cycle.canonise())
print('ripple_current =', ripple_current)
#r# .. math:
#r#      U = L \frac{dI}{dt}
L = (Vin - Vout) * duty_cycle / ripple_current
RL = 37@u_mΩ
#r# .. math:
#r#      dV = dI (ESR + \frac{dt}{C} + \frac{ESL}{dt})
ESR = 30@u_mΩ
ESL = 0
Cout = (ripple_current * duty_cycle) / (ripple_voltage - ripple_current * ESR)
ripple_current_in = Iload / 2
ripple_voltage_in = 200@u_mV
ESR_in = 120@u_mΩ
Cin = duty_cycle / (ripple_voltage_in / ripple_current_in - ESR_in)
L = L.canonise()
Cout = Cout.canonise()
Cin = Cin.canonise()
print('L =', L)
print('Cout =', Cout)
print('Cint =', Cin)
circuit.V('in', 'in', circuit.gnd, Vin)
circuit.C('in', 'in', circuit.gnd, Cin)
# Fixme: out drop from 12V to 4V
# circuit.VCS('switch', 'gate', circuit.gnd, 'in', 'source', model='Switch', initial_state='off')
# circuit.PulseVoltageSource('pulse', 'gate', circuit.gnd, 0@u_V, Vin, duty_cycle, period)
# circuit.model('Switch', 'SW', ron=1@u_mΩ, roff=10@u_MΩ)
# Fixme: Vgate => Vout ???
circuit.X('Q', 'irf150', 'in', 'gate', 'source')
# circuit.PulseVoltageSource('pulse', 'gate', 'source', 0@u_V, Vin, duty_cycle, period)
circuit.R('gate', 'gate', 'clock', 1@u_Ω)
circuit.PulseVoltageSource('pulse', 'clock', circuit.gnd, 0@u_V, 2.*Vin, duty_cycle, period)
circuit.X('D', '1N5822', circuit.gnd, 'source')
circuit.L(1, 'source', 1, L)
circuit.R('L', 1, 'out', RL)
circuit.C(1, 'out', circuit.gnd, Cout) # , initial_condition=0@u_V
circuit.R('load', 'out', circuit.gnd, Rload)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=period/300, end_time=period*150)
figure, ax = plt.subplots(figsize=(20, 10))
ax.plot(analysis.out)
ax.plot(analysis['source'])
# ax.plot(analysis['source'] - analysis['out'])
# ax.plot(analysis['gate'])
ax.axhline(y=float(Vout), color='red')
ax.legend(('Vout [V]', 'Vsource [V]'), loc=(.8,.8))
ax.grid()
ax.set_xlabel('t [s]')
ax.set_ylabel('[V]')
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'buck-converter.png')
</file>

<file path="examples/transformer/transformer-example.py">
####################################################################################################
#r#
#r# =============
#r#  Transformer
#r# =============
#r#
#r# This examples shows how to simulate a transformer.
#r#
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Probe.Plot import plot
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
from Transformer import Transformer
#f# literal_include('Transformer.py')
####################################################################################################
circuit = Circuit('Transformer')
ac_line = circuit.AcLine('input', 'input', circuit.gnd, rms_voltage=230@u_V, frequency=50@u_Hz)
circuit.subcircuit(Transformer(turn_ratio=10))
circuit.X('transformer', 'Transformer', 'input', circuit.gnd, 'output', circuit.gnd)
circuit.R('load', 'output', circuit.gnd, 1@u_kΩ)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=ac_line.period/200, end_time=ac_line.period*3)
figure, ax = plt.subplots(figsize=(20, 10))
ax.plot(analysis.input)
ax.plot(analysis.output)
ax.legend(('Vin [V]', 'Vout [V]'), loc=(.8,.8))
ax.grid()
ax.set_xlabel('t [s]')
ax.set_ylabel('[V]')
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'transformer.png')
</file>

<file path="examples/transformer/Transformer.py">
####################################################################################################
from PySpice.Spice.Netlist import SubCircuitFactory
from PySpice.Unit import *
####################################################################################################
class Transformer(SubCircuitFactory):
    NAME = 'Transformer'
    NODES = ('input_plus', 'input_minus',
             'output_plus', 'output_minus')
    ##############################################
    def __init__(self,
                 turn_ratio,
                 primary_inductance=1@u_H,
                 copper_resistance=1@u_Ω,
                 leakage_inductance=1@u_mH,
                 winding_capacitance=20@u_pF,
                 coupling=.999,
             ):
        super().__init__()
        # For an ideal transformer you can reduce the values for the flux leakage inductances, the
        # copper resistors and the winding capacitances. But
        if copper_resistance <= 0:
            raise ValueError("copper resistance must be > 0")
        if leakage_inductance <= 0:
            raise ValueError("leakage inductance must be > 0")
        # primary_turns =
        # secondary_turns =
        # turn_ratio = primary_turns / secondary_turns
        # primary_inductance =
        # primary_inductance / secondary_inductance = turn_ratio**2
        secondary_inductance = primary_inductance / float(turn_ratio**2)
        # Primary
        self.C('primary', 'input_plus', 'input_minus', winding_capacitance)
        self.L('primary_leakage', 'input_plus', 1, leakage_inductance)
        primary_inductor = self.L('primary', 1, 2, primary_inductance)
        self.R('primary', 2, 'output_minus', copper_resistance)
        # Secondary
        self.C('secondary', 'output_plus', 'output_minus', winding_capacitance)
        self.L('secondary_leakage', 'output_plus', 3, leakage_inductance)
        secondary_inductor = self.L('secondary', 3, 4, secondary_inductance)
        self.R('secondary', 4, 'output_minus', copper_resistance)
        # Coupling
        self.CoupledInductor('coupling', primary_inductor.name, secondary_inductor.name, coupling)
</file>

<file path="examples/transistor/m4/ac-coupled-amplifier.m4">
.PS

cct_init

elen = 0.75
epsilon = 1e-3

G: ground; dot; "0" rjust
  source(up_ elen,AC); llabel(,V_{in},); dot; "in" rjust
  capacitor(right_ elen); llabel(,C_{1},); dot; "2" rjust above
  { resistor(down_ to (Here,G)); rlabel(,R_{2}) }
  { R1: resistor(up_ elen_*1.5); llabel(,R_{1}); dot; "5" above }

  line right_ elen_/2; up_ # Q1 direction
Q1: bi_tr(,,,E) with .B at Here; llabel(,,Q_1)

Q1E: Q1.E - (0,elen_/8) # shift a little bit
  # resistor(down_ from Q1.E to (Q1.E,G)); rlabel(,R_{E})
  line down from Q1.E to Q1E; dot; "3" ljust
  resistor(down_ to (Q1.E,G)); rlabel(,R_{E})

Q1C: Q1.C + (0,elen_/8) # shift a little bit
  dot(at Q1C); "4" ljust above
  capacitor(right_ elen from Q1C); llabel(,C_{2})
  dot; "out" ljust
  resistor(down_ to (Here,G)); rlabel(,R_{L})
  line down epsilon then to G

  resistor(up_ from Q1.C to (Q1.C,R1.end)); llabel(,R_{C})
  line up epsilon then left to (G,R1.end) then down epsilon
  reversed(`source', down_ elen,V); llabel(,V_{pwr},)
  ground
.PE
</file>

<file path="examples/transistor/m4/transistor.m4">
.PS
cct_init

elen = 0.75
epsilon = 1e-3

G: ground; dot
  source(up_ elen,AC); llabel(,V_{base},)
  line up epsilon then right epsilon
  resistor(right_ elen); llabel(,R_{b},)

Q1: bi_tr(up_,,,E) with .B at Here; llabel(,,Q_1)

line down from Q1.E to (Q1.E, G) then right to G then up epsilon

resistor(up_ 1.25*elen from Q1.C); rlabel(,R_{c})
Top: Here
line up epsilon then left to (G,Top) then down epsilon
reversed(`source', down_ elen,V); llabel(,V_{collector},)
ground

.PE
</file>

<file path="examples/transistor/ac-coupled-amplifier.py">
#r# ======================
#r#  AC Coupled Amplifier
#r# ======================
#r# This example shows the simulation of an AC coupled amplifier using a NPN bipolar transistor.
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
#f# circuit_macros('ac-coupled-amplifier.m4')
circuit = Circuit('Transistor')
circuit.V('power', 5, circuit.gnd, 15@u_V)
source = circuit.SinusoidalVoltageSource('in', 'in', circuit.gnd, amplitude=.5@u_V, frequency=1@u_kHz)
circuit.C(1, 'in', 2, 10@u_uF)
circuit.R(1, 5, 2, 100@u_kΩ)
circuit.R(2, 2, 0, 20@u_kΩ)
circuit.R('C', 5, 4, 10@u_kΩ)
circuit.BJT(1, 4, 2, 3, model='bjt') # Q is mapped to BJT !
circuit.model('bjt', 'npn', bf=80, cjc=pico(5), rb=100)
circuit.R('E', 3, 0, 2@u_kΩ)
circuit.C(2, 4, 'out', 10@u_uF)
circuit.R('Load', 'out', 0, 1@u_MΩ)
####################################################################################################
figure, ax = plt.subplots(figsize=(20, 10))
# .ac dec 5 10m 1G
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=source.period/200, end_time=source.period*2)
ax.set_title('')
ax.set_xlabel('Time [s]')
ax.set_ylabel('Voltage [V]')
ax.grid()
ax.plot(analysis['in'])
ax.plot(analysis.out)
ax.legend(('input', 'output'), loc=(.05,.1))
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'ac-coupled-amplifier-plot.png')
</file>

<file path="examples/transistor/nmos-transistor.py">
#r# =====================
#r#  n-MOSFET Transistor
#r# =====================
#r# This example shows how to simulate the characteristic curves of an nmos transistor.
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
#r# We define a basic circuit to drive an nmos transistor using two voltage sources.
#r# The nmos transistor demonstrated in this example is a low-level device description.
#?# TODO: Write the : circuit_macros('nmos_transistor.m4')
circuit = Circuit('NMOS Transistor')
circuit.include(spice_library['ptm65nm_nmos'])
# Define the DC supply voltage value
Vdd = 1.1
# Instanciate circuit elements
Vgate = circuit.V('gate', 'gatenode', circuit.gnd, 0@u_V)
Vdrain = circuit.V('drain', 'vdd', circuit.gnd, u_V(Vdd))
# M <name> <drain node> <gate node> <source node> <bulk/substrate node>
circuit.MOSFET(1, 'vdd', 'gatenode', circuit.gnd, circuit.gnd, model='ptm65nm_nmos')
#r# We plot the characteristics :math:`Id = f(Vgs)` using a DC sweep simulation.
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.dc(Vgate=slice(0, Vdd, .01))
figure, ax = plt.subplots(figsize=(20, 10))
ax.plot(analysis['gatenode'], u_mA(-analysis.Vdrain))
ax.legend('NMOS characteristic')
ax.grid()
ax.set_xlabel('Vgs [V]')
ax.set_ylabel('Id [mA]')
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'transistor-nmos-plot.png')
</file>

<file path="examples/transistor/transistor.py">
#r# ====================
#r#  Bipolar Transistor
#r# ====================
#r# This example shows how to simulate the characteristic curves of a bipolar transistor.
# Fixme: Complete
####################################################################################################
import numpy as np
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Doc.ExampleTools import find_libraries
from PySpice.Probe.Plot import plot
from PySpice.Spice.Library import SpiceLibrary
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################
figure, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(20, 10))
####################################################################################################
#r# We define a basic circuit to drive an NPN transistor (2n2222a) using two voltage sources.
#f# circuit_macros('transistor.m4')
circuit = Circuit('Transistor')
Vbase = circuit.V('base', '1', circuit.gnd, 1@u_V)
circuit.R('base', 1, 'base', 1@u_kΩ)
Vcollector = circuit.V('collector', '2', circuit.gnd, 0@u_V)
circuit.R('collector', 2, 'collector', 1@u_kΩ)
# circuit.BJT(1, 'collector', 'base', circuit.gnd, model='generic')
# circuit.model('generic', 'npn')
circuit.include(spice_library['2n2222a'])
circuit.BJT(1, 'collector', 'base', circuit.gnd, model='2n2222a')
#r# We plot the base-emitter diode curve :math:`Ib = f(Vbe)` using a DC sweep simulation.
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.dc(Vbase=slice(0, 3, .01))
ax1.plot(analysis.base, u_mA(-analysis.Vbase)) # Fixme: I_Vbase
ax1.axvline(x=.65, color='red')
ax1.legend(('Base-Emitter Diode curve',), loc=(.1,.8))
ax1.grid()
ax1.set_xlabel('Vbe [V]')
ax1.set_ylabel('Ib [mA]')
####################################################################################################
#r# We will now replace the base's voltage source by a current source in the previous circuit.
circuit = Circuit('Transistor')
Ibase = circuit.I('base', circuit.gnd, 'base', 10@u_uA) # take care to the orientation
Vcollector = circuit.V('collector', 'collector', circuit.gnd, 5)
# circuit.BJT(1, 'collector', 'base', circuit.gnd, model='generic')
# circuit.model('generic', 'npn')
circuit.include(spice_library['2n2222a'])
circuit.BJT(1, 'collector', 'base', circuit.gnd, model='2n2222a')
# Fixme: ngspice doesn't support multi-sweep ???
#   it works in interactive mode
#?# simulator = circuit.simulator(temperature=25, nominal_temperature=25)
#?# analysis = simulator.dc(Vcollector=slice(0, 5, .1), Ibase=slice(micro(10), micro(100), micro(10)))
#?# 0 v(i-sweep)    voltage # Vcollector in fact
#?# 1 v(collector)  voltage
#?# 2 v(base)       voltage
#?# 3 i(vcollector) current
#?# 0.00000000e+00,   1.00000000e-01,   2.00000000e-01, 3.00000000e-01,   4.00000000e-01,   5.00000000e-01, 6.00000000e-01,   7.00000000e-01,   8.00000000e-01, 9.00000000e-01
#?# 0.00000000e+00,   1.00000000e-01,   2.00000000e-01, 3.00000000e-01,   4.00000000e-01,   5.00000000e-01, 6.00000000e-01,   7.00000000e-01,   8.00000000e-01, 9.00000000e-01
#?# 6.50478604e-01,   7.40522920e-01,   7.68606463e-01, 7.69192913e-01,   7.69049191e-01,   7.69050844e-01, 7.69049584e-01,   7.69049559e-01,   7.69049559e-01, 7.69049559e-01
#?# 9.90098946e-06,  -3.15540984e-04,  -9.59252614e-04, -9.99134834e-04,  -9.99982226e-04,  -1.00005097e-03, -1.00000095e-03,  -9.99999938e-04,  -9.99999927e-04, -9.99999937e-04
#?#
#?# analysis = simulator.dc(Vcollector=slice(0, 10, .1))
#?# 0 v(v-sweep)      voltage
#?# 1 v(collector)    voltage
#?# 2 v(base)         voltage
#?# 3 i(vcollector)   current
#?#
#?# analysis = simulator.dc(Ibase=slice(micro(10), micro(100), micro(10)))
#?# 0 v(i-sweep)      voltage
#?# 1 v(collector)    voltage
#?# 2 v(base)         voltage
#?# 3 i(vcollector)   current
ax2.grid()
# ax2.legend(('Ic(Vce, Ib)',), loc=(.5,.5))
ax2.set_xlabel('Vce [V]')
ax2.set_ylabel('Ic [mA]')
ax2.axvline(x=.2, color='red')
ax3.grid()
# ax3.legend(('beta(Vce)',), loc=(.5,.5))
ax3.set_xlabel('Vce [V]')
ax3.set_ylabel('beta')
ax3.axvline(x=.2, color='red')
for base_current in np.arange(0, 100, 10):
    base_current = base_current@u_uA
    Ibase.dc_value = base_current
    simulator = circuit.simulator(temperature=25, nominal_temperature=25)
    analysis = simulator.dc(Vcollector=slice(0, 5, .01))
    # add ib as text, linear and saturate region
    # Plot Ic = f(Vce)
    ax2.plot(analysis.collector, u_mA(-analysis.Vcollector))
    # Plot β = Ic / Ib = f(Vce)
    ax3.plot(analysis.collector, -analysis.Vcollector/float(base_current))
    # trans-resistance U = RI   R = U / I = Vce / Ie
    # ax3.plot(analysis.collector, analysis.sweep/(float(base_current)-analysis.Vcollector))
    # Fixme: sweep is not so explicit
#r# Let plot :math:`Ic = f(Ib)`
ax4.grid()
ax4.set_xlabel('Ib [uA]')
ax4.set_ylabel('Ic [mA]')
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.dc(Ibase=slice(0, 100e-6, 10e-6))
# Fixme: sweep
ax4.plot(analysis.sweep*1e6, u_mA(-analysis.Vcollector), 'o-')
ax4.legend(('Ic(Ib)',), loc=(.1,.8))
####################################################################################################
plt.tight_layout()
plt.show()
#f# save_figure('figure', 'transistor-plot.png')
</file>

<file path="examples/transmission-lines/time-delay.py">
#r# This example shows the simulation of a transmission line.
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Probe.Plot import plot
from PySpice.Spice.Netlist import Circuit
from PySpice.Unit import *
####################################################################################################
#r# We will drive the transmission line with a pulse source and use a standard 50 Ω load.
circuit = Circuit('Transmission Line')
circuit.PulseVoltageSource('pulse', 'input', circuit.gnd, 0@u_V, 1@u_V, 1@u_ns, 1@u_us)
circuit.LosslessTransmissionLine('delay', 'output', circuit.gnd, 'input', circuit.gnd,
                                 impedance=50, time_delay=40e-9)
circuit.R('load', 'output', circuit.gnd, 50@u_Ω)
simulator = circuit.simulator(temperature=25, nominal_temperature=25)
analysis = simulator.transient(step_time=1e-11, end_time=100e-9)
####################################################################################################
figure, ax = plt.subplots(figsize=(20, 6))
ax.plot(analysis['input'])
ax.plot(analysis['output'])
ax.set_xlabel('Time [s]')
ax.set_ylabel('Voltage (V)')
ax.grid()
ax.legend(['input', 'output'], loc='upper right')
plt.show()
#f# save_figure('figure', 'time-delay.png')
</file>

<file path="examples/index.rst">
.. -*- Mode: rst -*-

.. _examples-page:

==========
 Examples
==========

The examples are classified by topics.

.. here comes examples/examples.rst
</file>

<file path="examples/run-examples">
#! /usr/bin/env python3
# -*- Python -*-

####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################

####################################################################################################

from pathlib import Path
import glob
import os
import subprocess
import sys

####################################################################################################

examples_path = Path(__file__).resolve().parent

for topic in os.listdir(examples_path):
    python_files = glob.glob(str(examples_path.joinpath(topic, '*.py')))
    for file_name in python_files:
        if file_name.islower():
            print('Run {}'.format(file_name))
            subprocess.call(('python', file_name))
            print('To continue press Enter')
            rc = sys.stdin.readline().strip()
</file>

<file path="examples/Settings.py">
#skip#
####################################################################################################
from Pyterate.RstFactory.Settings import DefaultRstFactorySettings
####################################################################################################
class RstFactorySettings(DefaultRstFactorySettings):
    # Flags
    show_counters = True # Show documents counters in toc
</file>

<file path="PySpice/Config/ConfigInstall.py">
####################################################################################################
import os
import sys
####################################################################################################
import PySpice.Tools.Path as PathTools # Fixme: why ?
####################################################################################################
class OsFactory:
    ##############################################
    def __init__(self):
        if sys.platform.startswith('linux'):
            self._name = 'linux'
        elif sys.platform.startswith('win'):
            self._name = 'windows'
        elif sys.platform.startswith('darwin'):
            self._name = 'osx'
    ##############################################
    @property
    def name(self):
        return self._name
    @property
    def on_linux(self):
        return self._name == 'linux'
    @property
    def on_windows(self):
        return self._name == 'windows'
    @property
    def on_osx(self):
        return self._name == 'osx'
OS = OsFactory()
####################################################################################################
_this_file = PathTools.to_absolute_path(__file__)
class Path:
    pyspice_module_directory = PathTools.parent_directory_of(_this_file, step=2)
    config_directory = os.path.dirname(_this_file)
####################################################################################################
class Logging:
    default_config_file = 'logging.yml'
    directories = (Path.config_directory,)
    ##############################################
    @staticmethod
    def find(config_file):
        return PathTools.find(config_file, Logging.directories)
</file>

<file path="PySpice/Config/logging.yml">
####################################################################################################
version: 1
####################################################################################################
formatters:
  simple:
    format: '%(asctime)s - %(name)s - %(module)s.%(levelname)s - %(message)s'
  ansi:
#   RESET_SEQ = "\033[0m"
#   COLOR_SEQ = "\033[1;%dm"
#   BOLD_SEQ = "\033[1m"
    format: '<ESC>[1;32m%(asctime)s<ESC>[0m - <ESC>[1;34m%(name)s.%(funcName)s<ESC>[0m - <ESC>[1;31m%(levelname)s<ESC>[0m - %(message)s'
####################################################################################################
handlers:
  console:
    class: logging.StreamHandler
    # level: INFO
    # formatter: ansi
    stream: ext://sys.stdout
####################################################################################################
root:
  level: INFO
  # level: WARNING
  # level: DEBUG
  handlers: [console]
####################################################################################################
# loggers:
#   PySpice:
#     level: DEBUG
#     #level: INFO
#     #level: WARNING
#     handlers: [console]
</file>

<file path="PySpice/DeviceLibrary/__init__.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
class Manufacturer:
    ##############################################
    def __init__(self,
                 name,
                 url=None,
    ):
        self._name = name
        self._url = url
    ##############################################
    @property
    def name(self):
        return self._name
    @name.setter
    def name(self, value):
        self._name = value
    @property
    def url(self):
        return self._url
    @url.setter
    def url(self, value):
        self._url = value
####################################################################################################
class Footprint:
    ##############################################
    def __init__(self,
                 name,
    ):
        self._name = name
    ##############################################
    @property
    def name(self):
        return self._name
    @name.setter
    def name(self, value):
        self._name = value
####################################################################################################
class Device:
    ##############################################
    def __init__(self,
                 name,
                 manufacturer,
                 datasheet_url=None,
                 model_url=None
    ):
        # part
        # part_number
        # footprint
        # description
        # device_category x/y
        # pins
        # features / parameters
        self._name = name
    ##############################################
    @property
    def name(self):
        return self._name
    @name.setter
    def name(self, value):
        self._name = value
</file>

<file path="PySpice/Doc/ExampleTools.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
import logging
import os
import sys
from PySpice.Tools.Path import parent_directory_of
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
def find_libraries():
    try:
        library_path = os.environ['PySpiceLibraryPath']
    except KeyError:
        # Fixme: only works for one level
        python_file = os.path.abspath(sys.argv[0])
        examples_root = parent_directory_of(python_file, step=2)
        # .../PySpice/examples/diode/__example_rst_factory__nlrrr2fh.py .../PySpice/examples
        library_path = os.path.join(examples_root, 'libraries')
    _module_logger.info('SPICE library path is {}'.format(library_path))
    return library_path
</file>

<file path="PySpice/Logging/Logging.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
import yaml
import logging
import logging.config
import os
####################################################################################################
import PySpice.Config.ConfigInstall as ConfigInstall
####################################################################################################
def setup_logging(application_name='PySpice',
                  config_file=ConfigInstall.Logging.default_config_file,
                  logging_level=None):
    """Setup the logging.
    Logging configuration is set by a YAML file given by *config_file*.  Alternatively we can set
    the logging level using the environment variable 'PySpiceLogLevel' or using *logging_level*,
    level can be a integer or a string
    """
    logging_config_file_name = ConfigInstall.Logging.find(config_file)
    logging_config = yaml.load(open(logging_config_file_name, 'r'), Loader=yaml.SafeLoader)
    if ConfigInstall.OS.on_linux:
        # Fixme: \033 is not interpreted in YAML
        formatter_config = logging_config['formatters']['ansi']['format']
        logging_config['formatters']['ansi']['format'] = formatter_config.replace('<ESC>', '\033')
    if ConfigInstall.OS.on_windows or ConfigInstall.OS.on_osx:
        formatter = 'simple'
    else:
        formatter = 'ansi'
    logging_config['handlers']['console']['formatter'] = formatter
    logging.config.dictConfig(logging_config)
    logger = logging.getLogger(application_name)
    if logging_level:
        logger.setLevel(logging_level)
    if 'PySpiceLogLevel' in os.environ: # used by tools/make-examples
        level = getattr(logging, os.environ['PySpiceLogLevel'].upper(), None)
        logger.setLevel(level) # level can be int or string
    return logger
</file>

<file path="PySpice/Math/__init__.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This module implements mathematical functions.
"""
####################################################################################################
import math
####################################################################################################
def odd(x):
    """Return True is *x* is odd"""
    return x & 1
def even(x):
    """Return True is *x* is even"""
    return not(odd(x))
####################################################################################################
def rms_to_amplitude(x):
    """Return :math:`x \sqrt{2}`"""
    return x * math.sqrt(2)
def amplitude_to_rms(x):
    """Return :math:`x / \sqrt{2}`"""
    return x / math.sqrt(2)
</file>

<file path="PySpice/Math/Calculus.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This module provides algorithms to compute the derivative of a function sampled on an uniform
grid.
"""
####################################################################################################
import fractions
import numpy as np
####################################################################################################
from PySpice.Math import odd
####################################################################################################
def compute_exact_finite_difference_coefficients(derivative_order, grid, x0=0):
    """This function compute the finite difference coefficients for the given derivative order and
    grid.  The parameter *x* specifies where is computed the derivative on the grid.  The grid is
    given as a list of integer offsets.
    The algorithm is derived from the article: Generation of Finite Difference Formulas on Arbitrary Space
    Grids, Bengt Fornberg, Mathematics of computation, volume 51, number 184, october 1988
    """
    N = len(grid)
    # d[m,n,v]
    d = [[[0
           for v in range(N)]
          for n in range(N)]
         for m in range(derivative_order +1)]
    d[0][0][0] = fractions.Fraction(1,1)
    c1 = 1
    for n in range(1, N):
        c2 = 1
        for v in range(n):
            c3 = grid[n] - grid[v]
            c2 *= c3
            if n <= derivative_order:
                d[n][n-1][v] = 0
            for m in range(min(n, derivative_order) +1):
                d[m][n][v] = ( (grid[n] - x0)*d[m][n-1][v] - m*d[m-1][n-1][v] ) / c3
        for m in range(min(n, derivative_order) +1):
            d[m][n][n] = fractions.Fraction(c1,c2)*( m*d[m-1][n-1][n-1] - (grid[n-1] - x0)*d[m][n-1][n-1] )
        c1 = c2
    return d[-1][-1]
####################################################################################################
def compute_finite_difference_coefficients(derivative_order, grid):
    return [float(x) for x in compute_exact_finite_difference_coefficients(derivative_order, grid)]
####################################################################################################
_coefficient_cache = dict(centred={}, forward={}, backward={})
def get_finite_difference_coefficients(derivative_order, accuracy_order, grid_type):
    if derivative_order < 1:
        raise ValueError("Wrong derivative order")
    if odd(accuracy_order) or accuracy_order < 2:
        raise ValueError("Wrong accuracy order")
    if grid_type == 'centred':
        window_size = accuracy_order // 2
        grid = list(range(-window_size, window_size +1))
    elif grid_type == 'forward':
        grid = list(range(derivative_order + accuracy_order))
    elif grid_type == 'backward':
        grid = list(range(-(derivative_order + accuracy_order) +1, 1))
        grid = list(reversed(grid)) # Fixme: why ?
    else:
        raise ValueError("Wrong grid type")
    key = '{}-{}'.format(derivative_order, accuracy_order)
    coefficients = _coefficient_cache[grid_type].get(key, None)
    if coefficients is None:
        coefficients = compute_finite_difference_coefficients(derivative_order, grid)
        _coefficient_cache[grid_type][key] = coefficients
    return grid, coefficients
####################################################################################################
def simple_derivative(x, values):
    """ Compute the derivative as a simple slope. """
    return x[:-1], np.diff(values)/np.diff(x)
####################################################################################################
def derivative(x, values, derivative_order=1, accuracy_order=4):
    """Compute the derivative at the given derivative order and accuracy order. The precision of the
    Taylor expansion is :math:`\mathcal{O}(dx^{accuracy})`.
    """
    dx = np.diff(x)
    # if not np.all(dx == dx[0]):
    #     raise ValueError("Sampling is not uniform")
    dx = dx[0]
    values_size, = values.shape
    derivative = np.zeros(values_size, dtype=values.dtype)
    grid, coefficients = get_finite_difference_coefficients(derivative_order, accuracy_order, 'centred')
    window_size = grid[-1]
    # print grid, coefficients
    vector_size = values_size - 2*window_size
    if not vector_size:
        raise ValueError("The size of the value's array is not sufficient for the given accuracy order")
    lower_index = window_size
    upper_index = values_size - window_size
    derivative_view = derivative[window_size:-window_size]
    for offset, coefficient in zip(grid, coefficients):
        if coefficient:
            # print offset, lower_index + offset, upper_index + offset
            derivative_view += values[lower_index + offset:upper_index + offset] * coefficient
    grid, coefficients = get_finite_difference_coefficients(derivative_order, accuracy_order, 'forward')
    # print grid, coefficients
    grid_size = len(grid)
    upper_index = window_size
    derivative_view = derivative[:window_size]
    for offset, coefficient in zip(grid, coefficients):
        # print offset, offset, window_size+offset
        derivative_view += values[offset:upper_index + offset] * coefficient
    grid, coefficients = get_finite_difference_coefficients(derivative_order, accuracy_order, 'backward')
    # print grid, coefficients
    grid_size = len(grid)
    lower_index = values_size - window_size
    upper_index = values_size
    derivative_view = derivative[-window_size:]
    for offset, coefficient in zip(grid, coefficients):
        # print offset, lower_index + offset, upper_index + offset
        derivative_view += values[lower_index + offset:upper_index + offset] * coefficient
    return derivative / dx**derivative_order
</file>

<file path="PySpice/Physics/MaterialProperties.py">
# -*- coding: utf-8 -*-
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
class Copper:
    atomic_number = 29
    atomic_mass = 63.546 * 1e-3 # kg
    density = 8.96 * 1e3 # kg·m−3
    thermal_conductivity = 401 # W·m−1·K−1
    electrical_resistivity = 16.78 * 1e-9 # Ω·m @20 °C
    electron_mobility = - 4.6 * 1e3 # m2·V−1·s−1
    ##############################################
    def electrical_resistance_for_conductor(self, degree):
        """ Used to compute conductor resistance. """
        rho0 = 16e-3 # Ω·m·mm−2
        return rho0 * (1 + .00393 * degree)
</file>

<file path="PySpice/Physics/PhysicalConstants.py">
# -*- coding: utf-8 -*-
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
#
# Physical Constants from Particle Data Group 2013
#   http://pdg.lbl.gov/2013/reviews/rpp2013-rev-phys-constants.pdf
#
####################################################################################################
####################################################################################################
pi = 3.141592653589793238 # π = 3.141 592 653 589 793 238
####################################################################################################
speed_of_light_in_vacuum = c = 299792458 # 299 792 458 m s−1
electron_charge_magnitude = e = q = 1.602176565e-19 # 1.602 176 565(35)×10−19 C = 4.803 204 50(11)×10−10 esu
permeability_of_free_space = mu0 = 4*pi*1e-7 # 4π × 10−7 N A−2 = 12.566 370 614 ... ×10−7 N A−2
permittivity_of_free_space = epsilon0 = 1./(mu0*c**2) # 8.854 187 817 ... ×10−12 F m −1
avogadro_constant = Na = 6.02214129e23 # 6.022 141 29(27)×1023 mol−1
boltzmann_constant = k = 1.3806488e-23 # 1.380 6488(13)×10−23 J K−1 = 8.617 3324(78)×10−5 eV K−1
# 1 eV = 1.602 176 565(35) × 10−19 J
# 1 eV/c2 = 1.782 661 845(39) × 10−36 kg
####################################################################################################
# 0 ◦C ≡ 273.15 K
def degree_to_kelvin(x):
    return x + 273.15
def kelvin_to_degree(x):
    return x - 273.15
def temperature(degree=None, kelvin=None):
    if degree is not None:
        return degree_to_kelvin(degree)
    else:
        return kelvin
# kT at 300 K = [38.681 731(35)]−1 eV
def kT(degree=None, kelvin=None):
    return k*temperature(degree=degree, kelvin=kelvin)
</file>

<file path="PySpice/Physics/Resistor.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
#
# Notes: Drude model, Nernst-Einstein law
#
####################################################################################################
####################################################################################################
def conductor_resistance(resistivity, length, section):
    return resistivity * length / section
</file>

<file path="PySpice/Physics/SemiConductor.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
""" This module provides semiconductor models.
"""
####################################################################################################
import numpy as np
####################################################################################################
import PySpice.Physics.PhysicalConstants as Cst
####################################################################################################
class ShockleyDiode:
    """ This class provides an implementation of the Shockley Diode Model.
    """
    ##############################################
    def __init__(self,
                 Is=10e-12, # 10 pA
                 n=1,
                 degree=25, kelvin=None):
        self.Is = Is # reverse bias saturation current
        self.n = n # ideality factor or emission coefficient
        self.T = Cst.temperature(degree=degree, kelvin=kelvin)
    ##############################################
    @property
    def Vt(self):
        """ Thermal Voltage """
        return Cst.kT(kelvin=self.T) / Cst.q
    ##############################################
    def I(self, Vd):
        return self.Is*(np.exp(Vd/(self.n*self.Vt)) - 1)
    ##############################################
    def rd(self, Vd):
        """ Dynamic resistance defined by dVd/dI. """
        return self.n*self.Vt/self.I(Vd)
</file>

<file path="PySpice/Plot/BodeDiagram.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This module provides helpers to plot Bode diagrams using Matplolib.
Frequency is in Hz, gain in dB, phase in radians between -π and π.
"""
####################################################################################################
import math
from matplotlib import pyplot
####################################################################################################
def bode_diagram_gain(axe, frequency, gain, **kwargs):
    axe.semilogx(frequency, gain, basex=10, **kwargs)
    axe.grid(True)
    axe.grid(True, which='minor')
    axe.set_xlabel("Frequency [Hz]")
    axe.set_ylabel("Gain [dB]")
####################################################################################################
def bode_diagram_phase(axe, frequency, phase, **kwargs):
    axe.semilogx(frequency, phase, basex=10, **kwargs)
    axe.set_ylim(-math.pi, math.pi)
    axe.grid(True)
    axe.grid(True, which='minor')
    axe.set_xlabel("Frequency [Hz]")
    axe.set_ylabel("Phase [rads]")
    # axe.set_yticks # Fixme:
    pyplot.yticks((-math.pi, -math.pi/2,0, math.pi/2, math.pi),
                  (r"$-\pi$", r"$-\frac{\pi}{2}$", "0", r"$\frac{\pi}{2}$", r"$\pi$"))
####################################################################################################
def bode_diagram(axes, frequency, gain, phase, **kwargs):
    bode_diagram_gain(axes[0], frequency, gain, **kwargs)
    bode_diagram_phase(axes[1], frequency, phase, **kwargs)
</file>

<file path="PySpice/Probe/Plot.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
# Fixme: versus PySpice.Plot ???
####################################################################################################
"""This module implements plotting helper."""
####################################################################################################
import matplotlib.pyplot as plt
####################################################################################################
def plot(waveform, *args, **kwargs):
    """Plot a waveform using the current Axes instance or the one specified by the *axis* key
    argument. Additional parameters are passed to the Matplotlib plot function.
    """
    axis = kwargs.get('axis', plt.gca())
    if 'axis' in kwargs:
        del kwargs['axis']
    axis.plot(waveform.abscissa, waveform, *args, **kwargs)
</file>

<file path="PySpice/Probe/WaveForm.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
"""This module implements classes to handle analysis output.
"""
# https://numpy.org/doc/stable/user/basics.subclassing.html#basics-subclassing
####################################################################################################
import logging
import os
# import numpy as np
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
from PySpice.Unit.Unit import UnitValues
####################################################################################################
class WaveForm(UnitValues):
    """This class implements waveform on top of a Numpy Array.
    Public Attributes:
      :attr:`name`
      :attr:`unit`
      :attr:`title`
      :attr:`abscissa`
        Numpy array of the analysis abscissa
    """
    _logger = _module_logger.getChild('WaveForm')
    ##############################################
    @classmethod
    def from_unit_values(cls, name, array, title=None, abscissa=None):
        obj = cls(
            name,
            array.prefixed_unit,
            array.shape,
            dtype=array.dtype,
            title=title,
            abscissa=abscissa,
        )
        obj[...] = array[...]
        return obj
    ##############################################
    @classmethod
    def from_array(cls, name, array, title=None, abscissa=None):
        # Fixme: ok ???
        obj = cls(name, None, array.shape, title=title, abscissa=abscissa)
        obj[...] = array[...]
        return obj
    ##############################################
    def __new__(cls, name, prefixed_unit, shape,
                dtype=float, buffer=None, offset=0, strides=None, order=None,
                title=None, abscissa=None,
                ):
        # Called first
        # cls._logger.info(str((cls, prefixed_unit, shape, dtype, buffer, offset, strides, order)))
        # call UnitValues.__new__(...)
        obj = super(WaveForm, cls).__new__(cls, prefixed_unit, shape, dtype, buffer, offset, strides, order)
        # obj = np.asarray(data).view(cls)
        # extra attributes
        obj._name = str(name)
        obj._title = title   # str(title)
        obj._abscissa = abscissa    # Numpy array
        return obj
    ##############################################
    def __array_finalize__(self, obj):
        # Called after __new__
        # self._logger.info('')
        # Fixme: ??? else _prefixed_unit is not set
        super().__array_finalize__(obj)
        # if obj is None:
        #     return
        # extra attributes
        self._name = getattr(obj, 'name', None)
        self._title = getattr(obj, 'title', None)
        self._abscissa = getattr(obj, 'abscissa', None)
    ##############################################
    # def __init__(self, name, prefixed_unit, shape,
    #              dtype=float, buffer=None, offset=0, strides=None, order=None,
    #              title=None, abscissa=None):
    #     # Called last
    #     self._logger.info('')
    ##############################################
    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
        result = super().__array_ufunc__(ufunc, method, *inputs, **kwargs)
        # self._logger.info("result\n{}".format(result))
        if isinstance(result, UnitValues):
            return self.from_unit_values(name='', array=result, title='', abscissa=self._abscissa)
        else:
            return result  # e.g. foo <= 0
    ##############################################
    @property
    def name(self):
        return self._name
    @property
    def abscissa(self):
        return self._abscissa
    @property
    def title(self):
        return self._title
    @title.setter
    def title(self, value):
        if value is not None:
            self._title = str(value)
        else:
            self._title = None
    ##############################################
    def __repr__(self):
        return '{0.__class__.__name__} {0._name} {1}'.format(self, super().__str__())
    ##############################################
    def __str__(self):
        if self._title is not None:
            return self._title
        else:
            return self._name
    ##############################################
    def str_data(self):
        # Fixme: ok ???
        return repr(self.as_ndarray())
####################################################################################################
class Analysis:
    """Base class for the simulation output.
    Depending of the simulation type, the simulator will return waveforms as a function of
      * time
      * frequency
      * sweep
      * ...
    and corresponding to
      * a node's voltage
      * a source's current
      * ...
    The name of a waveform is
      * node's voltage: node's name
      * source's current: source'name
      * ...
    If the waveform name is a valid Python identifier, then you can get the corresponding waveform using::
      analysis.waveforme_name
    else you have to use this fallback::
      analysis['waveforme_name']
    Examples of usages::
        # Operating point analysis
        for node in analysis.nodes.values():
            print('Node {}: {:5.2f} V'.format(str(node), float(node)))
        for node in analysis.branches.values():
            print('Node {}: {:5.2f} A'.format(str(node), float(node)))
        # DC sensitivity analysis
        for element in analysis.elements.values():
            print(element, float(element))
        # Plot the voltage of the "out" node
        plt.plot(analysis.out.abscissa, analysis.out)
    Public Attributes:
      :attr:`nodes`
        Dictionary for node voltages indexed by node names
      :attr:`branches`
        Dictionary for branch currents indexed by source names
      :attr:`elements`
        Dictionary for elements ...
    """
    ##############################################
    def __init__(self, simulation, nodes=(), branches=(), elements=(), internal_parameters=()):
        # Fixme: branches are elements in fact, and elements is not yet supported ...
        self._simulation = simulation
        # Fixme: to func?
        self._nodes = {waveform.name:waveform for waveform in nodes}
        self._branches = {waveform.name:waveform for waveform in branches}
        self._elements = {waveform.name:waveform for waveform in elements}
        self._internal_parameters = {waveform.name:waveform for waveform in internal_parameters}
    ##############################################
    @property
    def simulation(self):
        """Return the simulation instance"""
        return self._simulation
    @property
    def nodes(self):
        return self._nodes
    @property
    def branches(self):
        return self._branches
    @property
    def elements(self):
        return self._elements
    @property
    def internal_parameters(self):
        return self._internal_parameters
   ##############################################
    def _get_item(self, name):
        # Fixme: cache dict ???
        if name in self._nodes:
            return self._nodes[name]
        elif name in self._branches:
            return self._branches[name]
        elif name in self._elements:
            return self._elements[name]
        elif name in self._internal_parameters:
            return self._internal_parameters[name]
        else:
            raise IndexError(name)
    ##############################################
    def __getitem__(self, name):
        try:
            return self._get_item(name)
        except IndexError:
            return self._get_item(name.lower())
    ##############################################
    @staticmethod
    def _format_dict(d):
        return os.linesep.join([' '*2 + str(x) for x in d])
    ##############################################
    def __getattr__(self, name):
        try:
            return self.__getitem__(name)
        except IndexError:
            raise AttributeError(
                name + os.linesep +
                'Nodes :' + os.linesep + self._format_dict(self._nodes) + os.linesep +
                'Branches :' + os.linesep + self._format_dict(self._branches) + os.linesep +
                'Elements :' + os.linesep + self._format_dict(self._elements) + os.linesep +
                'Internal Parameters :' + os.linesep + self._format_dict(self._internal_parameters)
            )
####################################################################################################
class OperatingPoint(Analysis):
    """This class implements an operating point analysis."""
    pass
####################################################################################################
class SensitivityAnalysis(Analysis):
    """This class implements an sensitivity analysis."""
    ##############################################
    def __init__(self, simulation, elements, internal_parameters):
        super().__init__(simulation=simulation, elements=elements,
                         internal_parameters=internal_parameters)
####################################################################################################
class DcAnalysis(Analysis):
    """This class implements a DC analysis.
    When the DC analysis is performed with multiple sources, sweep is the last source.
    The loop scheme is::
        for v1 in vsource1:
             for v2 in vsource2:
                 ...
    """
    ##############################################
    def __init__(self, simulation, sweep, nodes, branches, internal_parameters):
        super().__init__(simulation=simulation, nodes=nodes, branches=branches,
                         internal_parameters=internal_parameters)
        self._sweep = sweep
    ##############################################
    @property
    def sweep(self):
        """Return an Numpy array for the sweep abscissa"""
        return self._sweep
####################################################################################################
class AcAnalysis(Analysis):
    """This class implements an AC analysis."""
    ##############################################
    def __init__(self, simulation, frequency, nodes, branches, internal_parameters):
        super().__init__(simulation=simulation, nodes=nodes, branches=branches,
                         internal_parameters=internal_parameters)
        self._frequency = frequency
    ##############################################
    @property
    def frequency(self):
        """Return an Numpy array for the frequency abscissa"""
        return self._frequency
####################################################################################################
class TransientAnalysis(Analysis):
    """This class implements a transient analysis."""
    ##############################################
    def __init__(self, simulation, time, nodes, branches, internal_parameters):
        super().__init__(simulation=simulation, nodes=nodes, branches=branches,
                         internal_parameters=internal_parameters)
        self._time = time
    ##############################################
    @property
    def time(self):
        """Return an Numpy array for the time abscissa"""
        return self._time
####################################################################################################
class PoleZeroAnalysis(Analysis):
    """This class implements a Pole-Zero analysis."""
    ##############################################
    def __init__(self, simulation, nodes, branches, internal_parameters):
        super().__init__(simulation=simulation, nodes=nodes, branches=branches,
                         internal_parameters=internal_parameters)
####################################################################################################
class NoiseAnalysis(Analysis):
    """This class implements Noise analysis."""
    ##############################################
    def __init__(self, simulation, nodes, branches, internal_parameters):
        super().__init__(simulation=simulation, nodes=nodes, branches=branches,
                         internal_parameters=internal_parameters)
####################################################################################################
class DistortionAnalysis(Analysis):
    """This class implements Distortion analysis."""
    ##############################################
    def __init__(self, simulation, frequency, nodes, branches, internal_parameters):
        super().__init__(simulation=simulation, nodes=nodes, branches=branches,
                         internal_parameters=internal_parameters)
        self._frequency = frequency
    ##############################################
    @property
    def frequency(self):
        """Return an Numpy array for the frequency abscissa"""
        return self._frequency
####################################################################################################
class TransferFunctionAnalysis(Analysis):
    """This class implements Transfer Function (TF) analysis."""
    ##############################################
    def __init__(self, simulation, nodes, branches, internal_parameters):
        super().__init__(simulation=simulation, nodes=nodes, branches=branches,
                         internal_parameters=internal_parameters)
</file>

<file path="PySpice/Scripts/cir2py.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
import argparse
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()
####################################################################################################
from PySpice.Spice.Parser import SpiceParser
####################################################################################################
def main():
    parser = argparse.ArgumentParser(description='Convert a circuit file to PySpice')
    parser.add_argument('circuit_file', # metavar='circuit_file',
                        help='.cir file')
    parser.add_argument('-o', '--output',
                        default=None,
                        help='Output file')
    parser.add_argument('--ground',
                        type=int,
                        default=0,
                        help='Ground node')
    parser.add_argument('--build',
                        default=False, action='store_true',
                        help='Build circuit')
    args = parser.parse_args()
    ##############################################
    parser = SpiceParser(path=args.circuit_file)
    if args.build:
        parser.build_circuit()
    circuit = parser.to_python_code(ground=args.ground)
    if args.output is not None:
        with open(args.output, 'w') as f:
            f.write(circuit)
    else:
        print(circuit)
</file>

<file path="PySpice/Scripts/pyspice_post_installation.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2020 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""Tool to perform post installation.
"""
####################################################################################################
from pathlib import Path
from zipfile import ZipFile
import argparse
import os
import shutil
import sys
import tempfile
import requests
####################################################################################################
# Archive:  resources/ngspice-31_dll_64.zip
#   Spice64_dll/dll-mingw/
#   Spice64_dll/dll-mingw/libgcc_s_seh-1.dll
#   Spice64_dll/dll-mingw/libgomp-1.dll
#   Spice64_dll/dll-mingw/libwinpthread-1.dll
#   Spice64_dll/dll-mingw/msys-ngspice-0.dll
#   Spice64_dll/dll-vs/
#   Spice64_dll/dll-vs/ngspice.dll
#   Spice64_dll/dll-vs/vcomp140.dll
#   Spice64_dll/include/
#   Spice64_dll/include/ngspice/
#   Spice64_dll/include/ngspice/sharedspice.h
#   Spice64_dll/lib/
#   Spice64_dll/lib/about-libs.txt
#   Spice64_dll/lib/lib-mingw/
#   Spice64_dll/lib/lib-mingw/libngspice.dll.a
#   Spice64_dll/lib/lib-mingw/libngspice.la
#   Spice64_dll/lib/lib-vs/
#   Spice64_dll/lib/lib-vs/ngspice.exp
#   Spice64_dll/lib/lib-vs/ngspice.lib
#   Spice64_dll/lib/ngspice/
#   Spice64_dll/lib/ngspice/analog.cm
#   Spice64_dll/lib/ngspice/digital.cm
#   Spice64_dll/lib/ngspice/spice2poly.cm
#   Spice64_dll/lib/ngspice/table.cm
#   Spice64_dll/lib/ngspice/xtradev.cm
#   Spice64_dll/lib/ngspice/xtraevt.cm
#   Spice64_dll/share/
#   Spice64_dll/share/ngspice/
#   Spice64_dll/share/ngspice/scripts/
#   Spice64_dll/share/ngspice/scripts/spinit
####################################################################################################
class CircuitTest:
    ##############################################
    def test_spinit(self):
        from PySpice.Spice.Netlist import Circuit
        import PySpice.Unit as U
        circuit = Circuit('Test')
        # Fixme: On Windows
        #   Supplies reduced to   2.5749% Supplies reduced to   1.7100% Warning: source stepping failed
        #   doAnalyses: Too many iterations without convergence
        source = circuit.V('cc', 'vcc', circuit.gnd, 15@U.u_V)
        circuit.R(1, 'output', 'comparator', 1@U.u_kΩ)
        circuit.C(1, 'comparator', circuit.gnd, 100@U.u_nF)
        circuit.R(2, 'output', 'reference', 100@U.u_kΩ)
        circuit.R(3, 'vcc', 'reference', 100@U.u_kΩ)
        circuit.R(4, 'reference', circuit.gnd, 100@U.u_kΩ)
        # circuit.NonLinearVoltageSource(1, 'output', circuit.gnd,
        #                                expression='V(reference, comparator)',
        #                                table=((-U.micro(1), 0),
        #                                       (U.micro(1), source.dc_value))
        # )
        simulator = circuit.simulator(temperature=25, nominal_temperature=25)
        simulator.initial_condition(comparator=0)  # Fixme: simulator.nodes.comparator == 0
        analysis = simulator.transient(step_time=1@U.u_us, end_time=500@U.u_us)
        if (len(analysis.output)) < 500:
            raise NameError('Simualtion failed')
####################################################################################################
class PySpicePostInstallation:
    GITHUB_URL = 'https://github.com/FabriceSalvaire/PySpice'
    NGSPICE_BASE_URL = 'https://sourceforge.net/projects/ngspice/files'
    NGSPICE_RELEASE_URL = NGSPICE_BASE_URL + '/ng-spice-rework'
    NGSPICE_WINDOWS_DLL_URL = NGSPICE_RELEASE_URL + '/{0}/ngspice-{0}_dll_64.zip'
    NGSPICE_WINDOWS_DLL_OLD_URL = NGSPICE_RELEASE_URL + '/old-releases/{0}/ngspice-{0}_dll_64.zip'
    NGSPICE_MANUAL_URL = NGSPICE_RELEASE_URL + '/{0}/ngspice-{0}-manual.pdf/download'
    NGSPICE_MANUAL_OLD_URL = NGSPICE_RELEASE_URL + '/old-releases/{0}/ngspice-{0}-manual.pdf/download'
    ##############################################
    def run(self):
        parser = argparse.ArgumentParser(description='Tool to perform PySpice Post Installation.')
        parser.add_argument(
            '--ngspice-version',
            type=int, default=None,
            help='NgSpice version to install',
        )
        parser.add_argument(
            '--install-ngspice-dll',
            action='store_true',
            help='install Windows DLL',
        )
        parser.add_argument(
            '--force-install-ngspice-dll',
            action='store_true',
            help='force DLL installation (for debug only)',
        )
        parser.add_argument(
            '--download-ngspice-manual',
            action='store_true',
            help='download Ngspice manual',
        )
        parser.add_argument(
            '--check-install',
            action='store_true',
            help='check installation',
        )
        parser.add_argument(
            '--download-example',
            action='store_true',
            help='download examples',
        )
        self._args = parser.parse_args()
        count = 0
        if self._args.install_ngspice_dll or self._args.force_install_ngspice_dll:
            self.install_ngspice_dll()
            count += 1
        if self._args.check_install:
            self.check_installation()
            count += 1
        if self._args.download_example:
            self.download_example()
            count += 1
        if self._args.download_ngspice_manual:
            self.download_ngspice_manual()
            count += 1
        if not count:
            parser.print_help()
    ##############################################
    def _download_file(self, url, dst_path):
        print('Get {} ... -> {}'.format(url, dst_path))
        response = requests.get(url, allow_redirects=True)
        if response.status_code != requests.codes.ok:
            response.raise_for_status()
        with open(dst_path, mode='wb') as fh:
            fh.write(response.content)
    ##############################################
    @property
    def ngspice_version(self):
        if not hasattr(self, '_ngspice_version'):
            version = self._args.ngspice_version
            if version is None:
                from PySpice.Spice.NgSpice import NGSPICE_SUPPORTED_VERSION
                version = NGSPICE_SUPPORTED_VERSION
            self._ngspice_version = version
        return self._ngspice_version
    ##############################################
    def install_ngspice_dll(self):
        if not(os.name == 'nt' or self._args.force_install_ngspice_dll):
            return
        from PySpice.Spice import NgSpice
        with tempfile.TemporaryDirectory() as tmp_directory:
            tmp_directory = Path(tmp_directory)
            url = self.NGSPICE_WINDOWS_DLL_URL.format(self.ngspice_version)
            zip_path = tmp_directory.joinpath('ngspice-{}_dll_64.zip'.format(self.ngspice_version))
            dst_path = Path(NgSpice.__file__).parent
            try:
                self._download_file(url, zip_path)
            except requests.exceptions.HTTPError:
                print('Download failed, trying another URL...')
                url = self.NGSPICE_WINDOWS_DLL_OLD_URL.format(self.ngspice_version)
                self._download_file(url, zip_path)
            with ZipFile(zip_path) as zip_file:
                zip_file.extractall(path=dst_path)
                print('Extracted {} in {}'.format(zip_path, dst_path.joinpath('Spice64_dll')))
        spice64_path = dst_path.joinpath('Spice64_dll')
        dll_path = spice64_path.joinpath('dll-vs')
        # src = dll_path.joinpath('ngspice-{}.dll'.format(self.ngspice_version))
        src = 'ngspice-{}.dll'.format(self.ngspice_version)
        target = dll_path.joinpath('ngspice.dll')
        # For ngspice version <=31 DLL naming did not contain a version number
        if dll_path.joinpath(src).exists():
            if target.exists():
                target.unlink()
            try:
                target.symlink_to(src)
            except OSError:
                # OSError: symbolic link privilege not held
                # Windows: If User Account Control (UAC) is on, any user with the "Create Symbolic
                #   Links" privilege that is not in the Administrators group can simply create a
                #   symbolic link.  For users within the Administrators group and with UAC on, the user
                #   must "Run as Administrator".
                shutil.copy(target.parent.joinpath(src), target)
        spinit_path = spice64_path.joinpath('share', 'ngspice', 'scripts', 'spinit')
        with open(spinit_path) as fh:
            content = fh.read()
        rule = '='*80
        print(rule)
        print(content)
        print(rule)
        cm_path = spice64_path.joinpath('lib', 'ngspice')
        content = content.replace('../lib/ngspice/', str(cm_path) + '/')
        print(rule)
        print(content)
        print(rule)
        with open(spinit_path, 'w') as fh:
            fh.write(content)
    ##############################################
    def download_ngspice_manual(self):
        url = self.NGSPICE_MANUAL_URL.format(self.ngspice_version)
        try:
            self._download_file(url, 'ngspice-manual-{}.pdf'.format(self.ngspice_version))
        except requests.exceptions.HTTPError:
            print('Download failed, trying another URL...')
            url = self.NGSPICE_MANUAL_OLD_URL.format(self.ngspice_version)
            self._download_file(url, 'ngspice-manual-{}.pdf'.format(self.ngspice_version))
    ##############################################
    def check_installation(self):
        """Tool to check PySpice is correctly installed.
        """
        import ctypes.util
        print('OS:', sys.platform)
        print()
        print('Environments:')
        for _ in (
                'PATH',
                'LD_LIBRARY_PATH',
                'PYTHONPATH',
                'NGSPICE_LIBRARY_PATH',
                'SPICE_LIB_DIR',
                'SPICE_EXEC_DIR',
                'SPICE_ASCIIRAWFILE',
                'SPICE_SCRIPTS',
                'NGSPICE_MEAS_PRECISION',
                'SPICE_NO_DATASEG_CHECK',
                'NGSPICE_INPUT_DIR',
        ):
            print(_, os.environ.get(_, 'undefined'))
        print()
        if 'VIRTUAL_ENV' in os.environ:
            print('On Virtual Environment:')
            for _ in (
                    'VIRTUAL_ENV',
            ):
                print(_, os.environ.get(_, 'undefined'))
            print()
        if 'CONDA_PREFIX' in os.environ:
            print('On Anaconda:')
            for _ in (
                    # not specific
                    'CONDA_EXE',
                    'CONDA_PYTHON_EXE',
                    # 'CONDA_SHLVL', # shell level, 1 in conda else 0
                    # '_CE_CONDA', # empty
                    # specific
                    'CONDA_DEFAULT_ENV',
                    'CONDA_PREFIX',
                    # 'CONDA_PROMPT_MODIFIER',
            ):
                print(_, os.environ.get(_, 'undefined'))
            print()
        try:
            print('Load PySpice module')
            import PySpice
            print('loaded {} version {}'.format(PySpice.__file__, PySpice.__version__))
            print()
        except ModuleNotFoundError:
            print('PySpice module not found')
            return
        import PySpice.Logging.Logging as Logging
        logger = Logging.setup_logging(logging_level='INFO')
        from PySpice.Config import ConfigInstall
        from PySpice.Spice import NgSpice
        from PySpice.Spice.NgSpice import NGSPICE_SUPPORTED_VERSION
        from PySpice.Spice.NgSpice.Shared import NgSpiceShared
        print('ngspice supported version:', NGSPICE_SUPPORTED_VERSION)
        print()
        ##############################################
        message = os.linesep.join((
            'NgSpiceShared configuration is',
            '  NgSpiceShared.NGSPICE_PATH = {0.NGSPICE_PATH}',
            '  NgSpiceShared.LIBRARY_PATH = {0.LIBRARY_PATH}',
        ))
        print(message.format(NgSpiceShared))
        print()
        ##############################################
        cwd = Path(os.curdir).resolve()
        print('Working directory:', cwd)
        print()
        locale_ngspice = cwd.joinpath('ngspice-{}'.format(NGSPICE_SUPPORTED_VERSION))
        if locale_ngspice.exists() and locale_ngspice.is_dir():
            print('Found local ngspice:')
            for root, _, filenames in os.walk(locale_ngspice, followlinks=True):
                for filename in filenames:
                    print(root, filename)
            print()
        ngspice_module_path = Path(NgSpice.__file__).parent
        print('NgSpice:', ngspice_module_path)
        for root, _, filenames in os.walk(ngspice_module_path):
            for filename in filenames:
                print(root, filename)
        print()
        ##############################################
        if ConfigInstall.OS.on_windows:
            print('OS is Windows')
            library = NgSpiceShared.LIBRARY_PATH
        elif ConfigInstall.OS.on_osx:
            print('OS is OSX')
            library = 'ngspice'
        elif ConfigInstall.OS.on_linux:
            print('OS is Linux')
            library = 'ngspice'
        else:
            raise NotImplementedError
        library_path = ctypes.util.find_library(library)
        print('Found in library search path: {}'.format(library_path))
        ##############################################
        print('\nLoad NgSpiceShared')
        ngspice = NgSpiceShared.new_instance(verbose=True)
        if ConfigInstall.OS.on_linux:
            # For Linux see DLOPEN(3)
            # Apparently there is no simple way to get the path of the loaded library ...
            # But we can look in the process maps
            pid = os.getpid()
            maps_path = '/proc/{}/maps'.format(pid)
            with open(maps_path) as fh:
                for line in fh:
                    if '.so' in line and 'ngspice' in line:
                        parts = [x for x in line.split() if x]
                        path = parts[-1]
                        print('loaded {}'.format(path))
                        break
        print()
        if ngspice.spinit_not_found:
            print('WARNING: spinit was not found')
            print()
        message = os.linesep.join((
            'Ngspice version is {0.ngspice_version}',
            '  has xspice: {0.has_xspice}',
            '  has cider {0.has_cider}',
        ))
        print(message.format(ngspice))
        print()
        command = 'version -f'
        print('> ' + command)
        print(ngspice.exec_command(command))
        print()
        circuit_test = CircuitTest()
        circuit_test.test_spinit()
        print('PySpice should work as expected')
    ##############################################
    def download_example(self):
        import PySpice
        version = PySpice.__version__
        RELEASE_URL = self.GITHUB_URL + '/archive/v{}.zip'.format(version)
        zip_path = 'examples.zip'
        dst_path = input("Enter the path where you want to extract examples: ")
        dst_path = Path(dst_path).resolve()
        dst_parent = dst_path.parent
        if not dst_parent.exists():
            print("Directory {} doesn't exists".format(dst_parent))
            return
        with tempfile.TemporaryDirectory() as tmp_directory:
            self._download_file(RELEASE_URL, zip_path)
            with ZipFile(zip_path) as zip_file:
                zip_file.extractall(path=tmp_directory)
            examples_path = Path(tmp_directory).joinpath('PySpice-{}'.format(version), 'examples')
            shutil.copytree(examples_path, dst_path)
            print('Extracted examples in {}'.format(dst_path))
####################################################################################################
def main():
    _ = PySpicePostInstallation()
    return _.run()
</file>

<file path="PySpice/Spice/Expression/__init__.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
</file>

<file path="PySpice/Spice/Expression/Ast.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This module implements Abstract Syntactic Tree for Spice expressions.
"""
####################################################################################################
import logging
import os
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class StatementList:
    ##############################################
    def __init__(self, *statements):
        self._statements = list(statements)
    ##############################################
    def __nonzero__(self):
        return bool(self._statements)
    ##############################################
    def __iter__(self):
        return iter(self._statements)
    ##############################################
    def add(self, statement):
        self._statements.append(statement)
    ##############################################
    def __str__(self):
        return os.linesep.join([str(statement) for statement in self])
####################################################################################################
class Program(StatementList):
    pass
####################################################################################################
class Variable:
    ##############################################
    def __init__(self, name):
        self._name = name
    ##############################################
    @property
    def name(self):
        return self._name
    ##############################################
    def __str__(self):
        return self._name
####################################################################################################
class Constant:
    ##############################################
    def __init__(self, value):
        self._value = value
    ##############################################
    def __str__(self):
        return str(self._value)
####################################################################################################
class IntConstant(Constant):
    ##############################################
    def __int__(self):
        return self._value
####################################################################################################
class FloatConstant(Constant):
    ##############################################
    def __float__(self):
        return self._value
####################################################################################################
class Expression:
    NUMBER_OF_OPERANDS = None
    ##############################################
    def __init__(self, *args, **kwargs):
        if (self.NUMBER_OF_OPERANDS is not None
            and len(args) != self.NUMBER_OF_OPERANDS):
            raise ValueError("Wrong number of operands")
        self._operands = args
    ##############################################
    def iter_on_operands(self):
        return iter(self._operands)
    ##############################################
    @property
    def operand(self):
        return self._operands[0]
    @property
    def operand1(self):
        return self._operands[0]
    @property
    def operand2(self):
        return self._operands[1]
    @property
    def operand3(self):
        return self._operands[2]
class UnaryExpression(Expression):
    NUMBER_OF_OPERANDS = 1
class BinaryExpression(Expression):
    NUMBER_OF_OPERANDS = 2
class TernaryExpression(Expression):
    NUMBER_OF_OPERANDS = 3
####################################################################################################
class OperatorMetaclass(type):
    """Metaclass to register operators"""
    _declaration_order = 0
    _operators = []
    _unary_operator_map = {}
    _binary_operator_map = {}
    ##############################################
    def __new__(meta, class_name, base_classes, attributes):
        cls = type.__new__(meta, class_name, base_classes, attributes)
        if cls.OPERATOR is not None:
            meta.register_prefix(cls)
        return cls
    ##############################################
    @classmethod
    def register_prefix(meta, cls):
        cls._declaration_order  = meta._declaration_order
        meta._declaration_order += 1
        meta._operators.append(cls)
        if issubclass(cls, UnaryOperator):
            d = meta._unary_operator_map
        elif issubclass(cls, BinaryOperator):
            d = meta._binary_operator_map
        d[cls.OPERATOR] = cls
    ##############################################
    @classmethod
    def operator_iter(cls):
        return iter(cls._operators)
    ##############################################
    @classmethod
    def get_unary(cls, operator):
        return cls._unary_operator_map[operator]
    ##############################################
    @classmethod
    def get_binary(cls, operator):
        return cls._binary_operator_map[operator]
####################################################################################################
class OperatorMixin(metaclass=OperatorMetaclass):
    OPERATOR = None
    _declaration_order = 0
####################################################################################################
class UnaryOperator(UnaryExpression, OperatorMixin):
    def __str__(self):
        return ' '.join((self.OPERATOR, str(self.operand1)))
####################################################################################################
class BinaryOperator(BinaryExpression, OperatorMixin):
    def __str__(self):
        return ' '.join((str(self.operand1), self.OPERATOR, str(self.operand2)))
####################################################################################################
class Assignation(BinaryExpression):
    @property
    def variable(self):
        return self._operands[1]
    @property
    def value(self):
        return self._operands[0]
    def __str__(self):
        return ' '.join((str(self.destination), '=', str(self.value)))
####################################################################################################
class Negation(UnaryOperator):
    OPERATOR = '-'
    PRECEDENCE = 1
class Not(UnaryOperator):
    OPERATOR = '!'
    PRECEDENCE = 1
####################################################################################################
class power(BinaryOperator):
    OPERATOR = '**'
    PRECEDENCE = 2
class Multiplication(BinaryOperator):
    OPERATOR = '*'
    PRECEDENCE = 3
class Division(BinaryOperator):
    OPERATOR = '/'
    PRECEDENCE = 3
class Modulo(BinaryOperator):
    OPERATOR = '%'
    PRECEDENCE = 3
class IntegerDivision(BinaryOperator):
    OPERATOR = '\\'
    PRECEDENCE = 3
class Addition(BinaryOperator):
    OPERATOR = '+'
    PRECEDENCE = 4
class Subtraction(BinaryOperator):
    OPERATOR = '-'
    PRECEDENCE = 4
####################################################################################################
class Equal(BinaryOperator):
    OPERATOR = '=='
    PRECEDENCE = 5
class NotEqual(BinaryOperator):
    OPERATOR = '!='
    PRECEDENCE = 5
class LessEqual(BinaryOperator):
    OPERATOR = '<='
class GreaterEqual(BinaryOperator):
    OPERATOR = '>='
    PRECEDENCE = 5
class Less(BinaryOperator):
    OPERATOR = '<'
    PRECEDENCE = 5
class Greater(BinaryOperator):
    OPERATOR = '>'
    PRECEDENCE = 5
####################################################################################################
class And(BinaryOperator):
    OPERATOR = '&&'
    PRECEDENCE = 6
class Or(BinaryOperator):
    OPERATOR = '||'
    PRECEDENCE = 7
####################################################################################################
class If: #(TernaryExpression)
    # c ? x : y
    PRECEDENCE = 8
    ##############################################
    def __init__(self, condition, then_expression, else_expression):
        self._condition = condition
        self._then_expression = then_expression
        self._else_expression = else_expression
    ##############################################
    @property
    def condition(self):
        return self._condition
    ##############################################
    @property
    def then_expression(self):
        return self._then_expression
    ##############################################
    @property
    def else_expression(self):
        return self._else_expression
    ##############################################
    # def _str_compound_expression(self, expressions):
    #     string = '(' + os.linesep
    #     if expressions:
    #         string += str(expressions) + os.linesep
    #     string += ')'
    #     return string
    ##############################################
    def __str__(self):
        return '{} ? {} : {}'.format(self._condition, self._then_expression, self._else_expression)
####################################################################################################
class Function(Expression):
    ##############################################
    def __init__(self, name, *args):
        super(Function, self).__init__(*args)
        self._name = name
    ##############################################
    @property
    def name(self):
        return self._name
    ##############################################
    def __str__(self):
        parameters = ', '.join([str(operand) for operand in self.iter_on_operands()])
        return self._name + ' (' + parameters  + ')'
</file>

<file path="PySpice/Spice/Expression/Parser.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This module implements a parser for Spice expressions.
"""
####################################################################################################
import logging
####################################################################################################
import ply.lex as lex
import ply.yacc as yacc
####################################################################################################
from .Ast import *
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
# def ensure_statement_list(x):
#     if isinstance(x, StatementList):
#         return x
#     else:
#         return StatementList(x)
####################################################################################################
class Parser:
    _logger = _module_logger.getChild('Parser')
    ##############################################
    reserved = {
    }
    tokens = [
        'NAME',
        # 'INT', 'FLOAT',
        'NUMBER',
        'SEMICOLON',
        'LEFT_PARENTHESIS', 'RIGHT_PARENTHESIS',
        'SET',
        'NOT',
        'POWER',
        'MULTIPLY',
        'DIVIDE', 'INT_DIVIDE', 'MODULO',
        'PLUS', 'MINUS',
        'EQUAL', 'NOT_EQUAL', 'LESS', 'GREATER', 'LESS_EQUAL', 'GREATER_EQUAL',
        'AND', 'OR',
        'IF', 'COLON',
    ] + list(reserved.values())
    ##############################################
    def t_error(self, token):
        self._logger.error("Illegal character '%s' at line %u and position %u" %
                           (token.value[0],
                            token.lexer.lineno,
                            token.lexer.lexpos - self._previous_newline_position))
        # token.lexer.skip(1)
        raise NameError('Lexer error')
    ##############################################
    t_ignore  = ' \t'
    def t_newline(self, t):
        r'\r?\n+'
        # Track newline
        t.lexer.lineno += len(t.value)
        self._previous_newline_position = t.lexer.lexpos
        # t.type = 'SEMICOLON'
        # return t
    t_ignore_COMMENT = r'\#[^\n]*'
    ##############################################
    t_SEMICOLON = r';'
    t_LEFT_PARENTHESIS = r'\('
    t_RIGHT_PARENTHESIS = r'\)'
    t_SET = r'='
    t_NOT = r'!'
    t_POWER = r'\*\*'
    t_MULTIPLY = r'\*'
    t_DIVIDE = r'/'
    t_MODULO = r'%'
    t_INT_DIVIDE = r'\/'
    t_PLUS = r'\+'
    t_MINUS = r'-'
    t_EQUAL = r'=='
    t_NOT_EQUAL = r'!='
    t_LESS = r'<'
    t_GREATER = r'>'
    t_LESS_EQUAL = r'<='
    t_GREATER_EQUAL = r'>='
    t_AND = r'&&'
    t_OR = r'\|\|'
    t_IF = r'\?'
    t_COLON = r':'
    def t_NAME(self, t):
        r'[a-zA-Z_][a-zA-Z_0-9]*'
        # Check for reserved words
        t.type = self.reserved.get(t.value, 'NAME') # Fixme: ???
        return t
    # def t_INT(self, t):
    #     r'\d+'
    #     t.value = int(t.value)
    #     return t
    # exponent_part = r"""([eE][-+]?[0-9]+)"""
    # fractional_constant = r"""([0-9]*\.[0-9]+)|([0-9]+\.)"""
    # floating_constant = '(((('+fractional_constant+')'+exponent_part+'?)|([0-9]+'+exponent_part+'))[FfLl]?)'
    def t_NUMBER(self, t):
        # 1 1. 1.23 .1
        # r'\d*\.?\d+([eE][-+]?\d+)?'
        # r'(\d+)(\.\d+)(e(\+|-)?(\d+))? | (\d+)e(\+|-)?(\d+)'
        r'\d+\.\d+(e(\+|-)?(\d+))? | \d+\.(e(\+|-)?(\d+))? | \.\d+(e(\+|-)?(\d+))? | \d+'
        t.value = t.value
        return t
    ##############################################
    #
    # Grammar
    #
    # from lowest
    precedence = (
        ('left', 'IF'),
        ('left', 'OR'),
        ('left', 'AND'),
        ('left', 'GREATER', 'LESS', 'GREATER_EQUAL', 'LESS_EQUAL', 'NOT_EQUAL', 'EQUAL'),
        ('left', 'MINUS', 'PLUS'),
        ('left', 'INT_DIVIDE', 'MODULO', 'DIVIDE', 'MULTIPLY'),
        ('left', 'POWER'),
        ('left', 'NOT'), # , 'NEGATION'
    )
    def p_error(self, p):
        if p:
            self._logger.error("Syntax error at '%s'", p.value)
            raise NameError('Syntax Error')
        else:
            self._logger.error("Syntax Error at End Of File")
            raise NameError("Syntax Error at End Of File" )
    # start = 'program'
    start = 'statement'
    # def p_empty(self, p):
    #     'empty :'
    #     pass
    def p_statement(self, t):
        'statement : expression'
        print('statement', t[1])
    # def p_program(self, p):
    #     '''program : statement
    #                | program statement
    #                | empty
    #     '''
    #     if len(p) == 3:
    #         statement = p[2]
    #     else:
    #         statement = p[1]
    #     if statement is not None:
    #         self._program.add(statement)
    # def p_statement(self, p):
    #     '''statement : expression_statement
    #     '''
    #     p[0] = p[1]
    # def p_expression_statement(self, p):
    #     '''expression_statement : assignation SEMICOLON
    #                             | function SEMICOLON
    #                             | SEMICOLON
    #     '''
    #     if len(p) == 3:
    #         p[0] = p[1]
    # def p_statement_list(self, p):
    #     '''statement_list : statement
    #                       | statement_list statement
    #     '''
    #     if len(p) == 3:
    #         p[1].add(p[2])
    #         p[0] = p[1]
    #     else:
    #         p[0] = StatementList(p[1])
    # def p_expression_list(self, p):
    #     '''expression_list : expression
    #                        | expression_list COMMA expression
    #     '''
    #     if len(p) == 3:
    #         p[1].add(p[2])
    #         p[0] = p[1]
    #     else:
    #         p[0] = StatementList(p[1])
    # def p_function(self, p):
    #     '''function : NAME LEFT_PARENTHESIS expression_list RIGHT_PARENTHESIS
    #                 | NAME LEFT_PARENTHESIS RIGHT_PARENTHESIS
    #     '''
    #     if len(p) == 5:
    #         p[0] = Function(p[1], p[3])
    #     else:
    #         p[0] = Function(p[1])
    def p_variable(self, p):
        '''variable : NAME
        '''
        p[0] = Variable(p[1])
    # def p_assignation(self, p):
    #     'assignation : variable SET expression'
    #     p[0] = Assignation(p[3], p[1]) # eval value first
    # def p_interger(self, p):
    #     '''constant : INT
    #     '''
    #     p[0] = IntConstant(p[1])
    def p_float(self, p):
        '''constant : NUMBER
        '''
        if '.' in p[1]:
            p[0] = FloatConstant(p[1])
        else:
            p[0] = IntConstant(p[1])
    def p_value(self, p):
        '''expression : variable
                      | constant
        '''
        p[0] = p[1]
    def p_unnary_operation(self, p):
        # OP ...
        '''expression : MINUS expression
                      | NOT expression
        '''
        p[0] = OperatorMetaclass.get_unary(p[1])(p[2])
    def p_binary_operation(self, p):
        # ... OP ...
        '''expression : expression POWER expression
                      | expression MULTIPLY expression
                      | expression DIVIDE expression
                      | expression MODULO expression
                      | expression INT_DIVIDE expression
                      | expression PLUS expression
                      | expression MINUS expression
                      | expression EQUAL expression
                      | expression NOT_EQUAL expression
                      | expression LESS expression
                      | expression GREATER expression
                      | expression LESS_EQUAL expression
                      | expression GREATER_EQUAL expression
                      | expression AND expression
                      | expression OR expression
        '''
        p[0] = OperatorMetaclass.get_binary(p[2])(p[1], p[3])
    def p_if(self, p):
        '''expression : expression IF expression COLON expression
        '''
        p[0] = If(p[1], p[3], p[5])
    ##############################################
    def __init__(self):
        self._build()
    ##############################################
    def _build(self, **kwargs):
        self._lexer = lex.lex(module=self, **kwargs)
        self._parser = yacc.yacc(module=self, **kwargs)
    ##############################################
    def _reset(self):
        self._previous_newline_position = 0
        # self._program = Program()
    ##############################################
    def parse(self, text):
        self._reset() # Fixme: after ?
        self._parser.parse(text, lexer=self._lexer)
        # return self._program
    ##############################################
    def test_lexer(self, text):
        self._reset()
        self._lexer.input(text)
        while True:
            token = self._lexer.token()
            if not token:
                break
            print(token)
</file>

<file path="PySpice/Spice/NgSpice/__init__.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2020 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
__all__ = ['NGSPICE_SUPPORTED_VERSION']
from .SimulationType import LAST_VERSION as NGSPICE_SUPPORTED_VERSION
</file>

<file path="PySpice/Spice/NgSpice/api.h">
/* Simplified Ngspice API for CFFI parser */
typedef struct ngcomplex
{
  double cx_real;
  double cx_imag;
} ngcomplex_t;
typedef struct vector_info
{
  char *v_name;
  int v_type;
  short v_flags;
  double *v_realdata;
  ngcomplex_t *v_compdata;
  int v_length;
} vector_info, *pvector_info;
typedef struct vecvalues
{
  char *name;
  double creal;
  double cimag;
  bool is_scale;
  bool is_complex;
} vecvalues, *pvecvalues;
typedef struct vecvaluesall
{
  int veccount;
  int vecindex;
  pvecvalues *vecsa;
} vecvaluesall, *pvecvaluesall;
typedef struct vecinfo
{
  int number;
  char *vecname;
  bool is_real;
  void *pdvec;
  void *pdvecscale;
} vecinfo, *pvecinfo;
typedef struct vecinfoall
{
  char *name;
  char *title;
  char *date;
  char *type;
  int veccount;
  pvecinfo *vecs;
} vecinfoall, *pvecinfoall;
typedef int (SendChar) (char *, int, void *);
typedef int (SendStat) (char *, int, void *);
typedef int (ControlledExit) (int, bool, bool, int, void *);
typedef int (SendData) (pvecvaluesall, int, int, void *);
typedef int (SendInitData) (pvecinfoall, int, void *);
typedef int (BGThreadRunning) (bool, int, void *);
typedef int (GetVSRCData) (double *, double, char *, int, void *);
typedef int (GetISRCData) (double *, double, char *, int, void *);
typedef int (GetSyncData) (double, double *, double, int, int, int, void *);
int ngSpice_Init (SendChar *, SendStat *, ControlledExit *, SendData *, SendInitData *, BGThreadRunning *, void *);
int ngSpice_Init_Sync (GetVSRCData *, GetISRCData *, GetSyncData *, int *, void *);
int ngSpice_Command (char *);
pvector_info ngGet_Vec_Info (char *);
int ngSpice_Circ (char **);
char *ngSpice_CurPlot (void);
char **ngSpice_AllPlots (void);
char **ngSpice_AllVecs (char *);
bool ngSpice_running (void);
bool ngSpice_SetBkpt (double);
/* End */
</file>

<file path="PySpice/Spice/NgSpice/RawFile.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
import os
from ..RawFile import VariableAbc, RawFileAbc
####################################################################################################
"""This module provide tools to read the output of Ngspice.
Header
.. code::
    Circuit: 230V Rectifier
    Doing analysis at TEMP = 25.000000 and TNOM = 25.000000
    Title: 230V Rectifier
    Date: Thu Jun  4 23:40:58  2015
    Plotname: Transient Analysis
    Flags: real
    No. Variables: 6
    No. Points: 0
    Variables:
    No. of Data Columns : 6
            0       time    time
            1       v(in)   voltage
            ...
            5       i(vinput)       current
    Binary:
Operating Point
Node voltages and source branch currents:
 * v(node_name)
 * i(vname)
Sensitivity Analysis
 * v({element})
 * v({element}_{parameter})
 * v(v{source})
DC
 * v(v-sweep)
 * v({node})
 * i(v{source})
AC
Frequency, node voltages and source branch currents:
 * frequency
 * v({node})
 * i(v{name})
Transient Analysis
Time, node voltages and source branch currents:
 * time
 * v({node})
 * i(v{source})
"""
# * v({element}:bv_max)
# * i(e.xdz1.ev1)
####################################################################################################
import logging
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
# Fixme: self._
class Variable(VariableAbc):
    ##############################################
    def is_voltage_node(self):
        return self.name.startswith('v(')
    ##############################################
    def is_branch_current(self):
        # source branch current
        return self.name.startswith('i(')
    ##############################################
    @property
    def simplified_name(self):
        if self.is_voltage_node() or self.is_branch_current():
            return self.name[2:-1]
        else:
            return self.name
####################################################################################################
class RawFile(RawFileAbc):
    """ This class parse the stdout of ngspice and the raw data output.
    Public Attributes:
      :attr:`circuit`
        same as title
      :attr:`data`
      :attr:`date`
      :attr:`flags`
        'real' or 'complex'
      :attr:`number_of_points`
      :attr:`number_of_variables`
      :attr:`plot_name`
        AC Analysis, Operating Point, Sensitivity Analysis, DC transfer characteristic
      :attr:`temperature`
      :attr:`title`
      :attr:`variables`
      :attr:`warnings`
    """
    _logger = _module_logger.getChild('RawFile')
    _variable_cls = Variable
    ##############################################
    def __init__(self, stdout, number_of_points):
        self.number_of_points = number_of_points
        raw_data = self._read_header(stdout)
        self._read_variable_data(raw_data)
        # self._to_analysis()
        self._simulation = None
    ##############################################
    def _read_header(self, stdout):
        """ Parse the header """
        binary_line = b'Binary:' + os.linesep.encode('ascii')
        binary_location = stdout.find(binary_line)
        if binary_location < 0:
            raise NameError('Cannot locate binary data')
        raw_data_start = binary_location + len(binary_line)
        # self._logger.debug(os.linesep + stdout[:raw_data_start].decode('utf-8'))
        header_lines = stdout[:binary_location].splitlines()
        raw_data = stdout[raw_data_start:]
        header_line_iterator = iter(header_lines)
        self.circuit_name = self._read_header_field_line(header_line_iterator, 'Circuit')
        self.temperature, self.nominal_temperature = self._read_temperature_line(header_line_iterator)
        self.warnings = [self._read_header_field_line(header_line_iterator, 'Warning')
                         for i in range(stdout.count(b'Warning'))]
        for warning in self.warnings:
            self._logger.warn(warning)
        self.title = self._read_header_field_line(header_line_iterator, 'Title')
        self.date = self._read_header_field_line(header_line_iterator, 'Date')
        self.plot_name = self._read_header_field_line(header_line_iterator, 'Plotname')
        self.flags = self._read_header_field_line(header_line_iterator, 'Flags')
        self.number_of_variables = int(self._read_header_field_line(header_line_iterator, 'No. Variables'))
        self._read_header_field_line(header_line_iterator, 'No. Points')
        self._read_header_field_line(header_line_iterator, 'Variables', has_value=False)
        self._read_header_field_line(header_line_iterator, 'No. of Data Columns ')
        self._read_header_variables(header_line_iterator)
        return raw_data
    ##############################################
    def fix_case(self):
        """ Ngspice return lower case names. This method fixes the case of the variable names. """
        circuit = self.circuit
        element_translation = {element.lower():element for element in circuit.element_names}
        node_translation = {node.lower():node for node in circuit.node_names}
        for variable in self.variables.values():
            variable.fix_case(element_translation, node_translation)
    ##############################################
    def _to_dc_analysis(self):
        if 'v(v-sweep)' in self.variables:
            sweep_variable = self.variables['v(v-sweep)']
        elif 'v(i-sweep)' in self.variables:
            sweep_variable = self.variables['v(i-sweep)']
        else:
            #
            raise NotImplementedError
        return super()._to_dc_analysis(sweep_variable)
</file>

<file path="PySpice/Spice/NgSpice/Server.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This module provides an interface to run ngspice in server mode and get back the simulation
output.
When ngspice runs in server mode, it writes on the standard output an header and then the simulation
output in binary format.  At the end of the simulation, it writes on the standard error a line of
the form:
    .. code::
        @@@ \d+ \d+
where the second number is the number of points of the simulation.  Due to the iterative and
adaptive nature of a transient simulation, the number of points is only known at the end.
Any line starting with "Error" in the standard output indicates an error in the simulation process.
The line "run simulation(s) aborted" in the standard error indicates the simulation aborted.
Any line starting with *Warning* in the standard error indicates non critical error in the
simulation process.
"""
####################################################################################################
import logging
import os
import re
import subprocess
####################################################################################################
from .RawFile import RawFile
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class SpiceServer:
    """This class wraps the execution of ngspice in server mode and convert the output to a Python data
    structure.
    Example of usage::
      spice_server = SpiceServer(spice_command='/path/to/ngspice')
      raw_file = spice_server(spice_input)
    It returns a :obj:`PySpice.Spice.RawFile` instance.
    """
    _logger = _module_logger.getChild('SpiceServer')
    SPICE_COMMAND = 'ngspice'
    ##############################################
    def __init__(self, **kwargs):
        self._spice_command = kwargs.get('spice_command') or self.SPICE_COMMAND
    ##############################################
    def _decode_number_of_points(self, line):
        """Decode the number of points in the given line."""
        match = re.match(r'@@@ (\d+) (\d+)', line)
        if match is not None:
            return int(match.group(2))
        else:
            raise NameError("Cannot decode the number of points")
    ##############################################
    def _parse_stdout(self, stdout):
        """Parse stdout for errors."""
        # self._logger.debug(os.linesep + stdout)
        error_found = False
        # UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc0 in position 870: invalid start byte
        # lines = stdout.decode('utf-8').splitlines()
        lines = stdout.splitlines()
        for line_index, line in enumerate(lines):
            if line.startswith(b'Error '):
                error_found = True
                self._logger.error(os.linesep + line.decode('utf-8') + os.linesep + lines[line_index+1].decode('utf-8'))
        if error_found:
            raise NameError("Errors was found by Spice")
    ##############################################
    def _parse_stderr(self, stderr):
        """Parse stderr for warnings and return the number of points."""
        self._logger.debug(os.linesep + stderr)
        stderr_lines = stderr.splitlines()
        number_of_points = None
        for line in stderr_lines:
            if line.startswith('Warning:'):
                self._logger.warning(line[len('Warning :'):])
            elif line == 'run simulation(s) aborted':
                raise NameError('Simulation aborted' + os.linesep + stderr)
            elif line.startswith('@@@'):
                number_of_points = self._decode_number_of_points(line)
        return number_of_points
    ##############################################
    def __call__(self, spice_input):
        """Run SPICE in server mode as a subprocess for the given input and return a
        :obj:`PySpice.RawFile.RawFile` instance.
        """
        self._logger.info("Start the spice subprocess")
        process = subprocess.Popen((self._spice_command, '-s'),
                                   stdin=subprocess.PIPE,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
        input_ = str(spice_input).encode('utf-8')
        stdout, stderr = process.communicate(input_)
        # stdout = stdout.decode('utf-8')
        stderr = stderr.decode('utf-8')
        self._parse_stdout(stdout)
        number_of_points = self._parse_stderr(stderr)
        if number_of_points is None:
            raise NameError('The number of points was not found in the standard error buffer,'
                            ' ngspice returned:' + os.linesep +
                            stderr)
        return RawFile(stdout, number_of_points)
</file>

<file path="PySpice/Spice/NgSpice/Shared.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This module provides a Python interface to the Ngspice shared library described in the *ngspice
as shared library or dynamic link library* section of the Ngspice user manual.
In comparison to the subprocess interface, it provides an interaction with the simulator through
commands and callbacks and it enables the usage of external voltage and current source in the
circuit.
.. This approach corresponds to the *standard way* to make an interface to a simulator code.
.. warning:: Since we don't simulate a circuit in a fresh environment on demand, this approach is
 less safe than the subprocess approach. In case of bugs within Ngspice, we can expect some side
 effects like memory leaks or worse unexpected things.
This interface use the CFFI module to interface with the shared library. It is thus suited to run
within the Pypy interpreter which implements JIT optimisation for Python.
It can also be used to experiment parallel simulation as explained in the Ngspice user manual. But
it seems the Ngspice source code was designed with global variables which imply to use one copy of
the shared library by worker as explained in the manual.
.. warning:: This interface can strongly slow down the simulation if the input or output callbacks
  is used.  If the simulation time goes wrong for you then you need to implement the callbacks at a
  lower level than Python. You can have look to Pypy, Cython or a C extension module.
"""
####################################################################################################
# 16.7 Environmental variables
# 16.7.1 Ngspice specific variables
#
# SPICE_LIB_DIR
#   default: /usr/local/share/ngspice (Linux, CYGWIN), C:\Spice\share\ngspice (Windows)
# SPICE_EXEC_DIR
#   default: /usr/local/bin (Linux, CYGWIN), C:\Spice\bin (Windows)
# SPICE_ASCIIRAWFILE
#   default: 0
#   Format of the rawfile. 0 for binary, and 1 for ascii.
# SPICE_SCRIPTS
#   default: $SPICE_LIB_DIR/scripts
#   In this directory the spinit file will be searched.
# NGSPICE_MEAS_PRECISION
#   default: 5
#   Sets the number of digits if output values are printed by the meas(ure) command.
# SPICE_NO_DATASEG_CHECK
#   default: undefined
#   If defined, will suppress memory resource info (probably obsolete, not used on Windows
#   or where the /proc information system is available.)
# NGSPICE_INPUT_DIR
#   default: undefined
#   If defined, using a valid directory name, will add the given directory to the search path
#   when looking for input files (*.cir, *.inc, *.lib).
####################################################################################################
__all__ = [
    'NgSpiceCircuitError',
    'NgSpiceCommandError',
    'NgSpiceShared',
]
####################################################################################################
from pathlib import Path
import logging
import os
import platform
import re
import numpy as np
from cffi import FFI
####################################################################################################
from PySpice.Config import ConfigInstall
from PySpice.Probe.WaveForm import (
    OperatingPoint, SensitivityAnalysis,
    DcAnalysis, AcAnalysis, TransientAnalysis,
    PoleZeroAnalysis, NoiseAnalysis, DistortionAnalysis, TransferFunctionAnalysis,
    WaveForm,
)
from PySpice.Tools.EnumFactory import EnumFactory
from PySpice.Unit import u_V, u_A, u_s, u_Hz, u_F, u_Degree
from .SimulationType import SIMULATION_TYPE
####################################################################################################
ffi = FFI()
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class NgSpiceCircuitError(NameError):
    pass
class NgSpiceCommandError(NameError):
    pass
####################################################################################################
def ffi_string_utf8(_):
    _ = ffi.string(_)
    try:
        return _.decode('utf8')
    except UnicodeDecodeError:
        return _
####################################################################################################
class Vector:
    """ This class implements a vector in a simulation output.
    Public Attributes:
      :attr:`data`
      :attr:`name`
    """
    _logger = _module_logger.getChild('Vector')
    ##############################################
    def __init__(self, ngspice_shared, name, type_, data):
        self._ngspice_shared = ngspice_shared
        self._name = str(name)
        self._type = type_
        self._data = data
        self._unit = ngspice_shared.type_to_unit(type_)
        if self._unit is None:
            self._logger.warning('Unit is None for {0._name} {0._type}'.format(self))
    ##############################################
    def __repr__(self):
        return 'variable: {0._name} {0._type}'.format(self)
    ##############################################
    @property
    def is_interval_parameter(self):
        return self._name.startswith('@')
    ##############################################
    @property
    def is_voltage_node(self):
        return self._type == self._ngspice_shared.simulation_type.voltage and not self.is_interval_parameter
    ##############################################
    @property
    def is_branch_current(self):
        return self._type == self._ngspice_shared.simulation_type.current and not self.is_interval_parameter
    ##############################################
    @property
    def simplified_name(self):
        if self.is_voltage_node and self._name.startswith('V('):
            return self._name[2:-1]
        elif self.is_branch_current:
            # return self._name.replace('#branch', '')
            return self._name[:-7]
        else:
            return self._name
    ##############################################
    def to_waveform(self, abscissa=None, to_real=False, to_float=False):
        """ Return a :obj:`PySpice.Probe.WaveForm` instance. """
        data = self._data
        if to_real:
            data = data.real
        # Fixme: else UnitValue instead of UnitValues
        # if to_float:
        #     data = float(data[0])
        if self._unit is not None:
            return WaveForm.from_unit_values(self.simplified_name, self._unit(data), abscissa=abscissa)
        else:
            return WaveForm.from_array(self.simplified_name, data, abscissa=abscissa)
####################################################################################################
class Plot(dict):
    """ This class implements a plot in a simulation output.
    Public Attributes:
      :attr:`plot_name`
    """
    ##############################################
    def __init__(self, simulation, plot_name):
        super().__init__()
        self._simulation = simulation
        self.plot_name = plot_name
    ##############################################
    def nodes(self, to_float=False, abscissa=None):
        return [variable.to_waveform(abscissa, to_float=to_float)
                for variable in self.values()
                if variable.is_voltage_node]
    ##############################################
    def branches(self, to_float=False, abscissa=None):
        return [variable.to_waveform(abscissa, to_float=to_float)
                for variable in self.values()
                if variable.is_branch_current]
    ##############################################
    def internal_parameters(self, to_float=False, abscissa=None):
        return [variable.to_waveform(abscissa, to_float=to_float)
                for variable in self.values()
                if variable.is_interval_parameter]
    ##############################################
    def elements(self, abscissa=None):
        return [variable.to_waveform(abscissa, to_float=True)
                for variable in self.values()]
    ##############################################
    def to_analysis(self):
        if self.plot_name.startswith('op'):
            return self._to_operating_point_analysis()
        elif self.plot_name.startswith('sens'):
            return self._to_sensitivity_analysis()
        elif self.plot_name.startswith('dc'):
            return self._to_dc_analysis()
        elif self.plot_name.startswith('ac'):
            return self._to_ac_analysis()
        elif self.plot_name.startswith('tran'):
            return self._to_transient_analysis()
        elif self.plot_name.startswith('disto'):
            return self._to_distortion_analysis()
        elif self.plot_name.startswith('noise'):
            return self._to_noise_analysis()
        elif self.plot_name.startswith('pz'):
            return self._to_polezero_analysis()
        elif self.plot_name.startswith('tf'):
            return self._to_transfer_function_analysis()
        else:
            raise NotImplementedError("Unsupported plot name {}".format(self.plot_name))
    ##############################################
    def _to_operating_point_analysis(self):
        return OperatingPoint(
            simulation=self._simulation,
            nodes=self.nodes(to_float=True),
            branches=self.branches(to_float=True),
            internal_parameters=self.internal_parameters(),
        )
    ##############################################
    def _to_sensitivity_analysis(self):
        # Fixme: separate v(vinput), analysis.R2.m
        return SensitivityAnalysis(
            simulation=self._simulation,
            elements=self.elements(),  # Fixme: internal parameters ???
            internal_parameters=self.internal_parameters(),
        )
    ##############################################
    def _to_dc_analysis(self):
        for name in ('v-sweep', 'i-sweep', 'temp-sweep'):
            if name in self:
                sweep_variable = self[name]
                break
        else:
            raise NotImplementedError(str(self))
        sweep = sweep_variable.to_waveform()
        return DcAnalysis(
            simulation=self._simulation,
            sweep=sweep,
            nodes=self.nodes(),
            branches=self.branches(),
            internal_parameters=self.internal_parameters(),
        )
    ##############################################
    def _to_ac_analysis(self):
        frequency = self['frequency'].to_waveform(to_real=True)
        return AcAnalysis(
            simulation=self._simulation,
            frequency=frequency,
            nodes=self.nodes(),
            branches=self.branches(),
            internal_parameters=self.internal_parameters(),
        )
    ##############################################
    def _to_transient_analysis(self):
        time = self['time'].to_waveform(to_real=True)
        return TransientAnalysis(
            simulation=self._simulation,
            time=time,
            nodes=self.nodes(abscissa=time),
            branches=self.branches(abscissa=time),
            internal_parameters=self.internal_parameters(abscissa=time),
        )
    ##############################################
    def _to_polezero_analysis(self):
        return PoleZeroAnalysis(
            simulation=self._simulation,
            nodes=self.nodes(),
            branches=self.branches(),
            internal_parameters=self.internal_parameters(),
        )
    ##############################################
    def _to_noise_analysis(self):
        return NoiseAnalysis(
            simulation=self._simulation,
            nodes=self.nodes(),
            branches=self.branches(),
            internal_parameters=self.internal_parameters(),
        )
    ##############################################
    def _to_distortion_analysis(self):
        frequency = self['frequency'].to_waveform(to_real=True)
        return DistortionAnalysis(
            simulation=self._simulation,
            frequency=frequency,
            nodes=self.nodes(),
            branches=self.branches(),
            internal_parameters=self.internal_parameters(),
        )
    ##############################################
    def _to_transfer_function_analysis(self):
        return TransferFunctionAnalysis(
            simulation=self._simulation,
            nodes=self.nodes(),
            branches=self.branches(),
            internal_parameters=self.internal_parameters(),
        )
####################################################################################################
class NgSpiceShared:
    _logger = _module_logger.getChild('NgSpiceShared')
    NGSPICE_PATH = None
    LIBRARY_PATH = None
    MAX_COMMAND_LENGTH = 1023
    NUMBER_OF_EXEC_CALLS_TO_RELEASE_MEMORY = 10_000
    ##############################################
    @classmethod
    def setup_platform(cls):
        if ConfigInstall.OS.on_windows:
            if platform.architecture()[0] != '64bit':
                raise NameError('Windows 32bit is no longer supported by NgSpice')
        _ = os.environ.get('NGSPICE_LIBRARY_PATH', None)
        if _ is not None:
            cls.LIBRARY_PATH = _
        else:
            if ConfigInstall.OS.on_windows:
                ngspice_path = Path(__file__).parent.joinpath('Spice64_dll')
                cls.NGSPICE_PATH = ngspice_path
                # path = ngspice_path.joinpath('dll-vs', 'ngspice-{version}{id}.dll')
                path = ngspice_path.joinpath('dll-vs', 'ngspice{}.dll')
            elif ConfigInstall.OS.on_osx:
                path = 'libngspice{}.dylib'
            elif ConfigInstall.OS.on_linux:
                path = 'libngspice{}.so'
            else:
                raise NotImplementedError
            cls.LIBRARY_PATH = str(path)
    ##############################################
    _instances = {}
    @classmethod
    def new_instance(cls, ngspice_id=0, send_data=False, verbose=False):
        """Create a NgSpiceShared instance"""
        # Fixme: send_data
        if ngspice_id in cls._instances:
            return cls._instances[ngspice_id]
        else:
            cls._logger.debug("New instance for id {}".format(ngspice_id))
            instance = cls(ngspice_id=ngspice_id, send_data=send_data, verbose=verbose)
            cls._instances[ngspice_id] = instance
            return instance
    ##############################################
    def __init__(self, ngspice_id=0, send_data=False, verbose=False):
        """ Set the *send_data* flag if you want to enable the output callback.
        Set the *ngspice_id* to an integer value if you want to run NgSpice in parallel.
        """
        self._ngspice_id = ngspice_id
        self._spinit_not_found = False
        self._number_of_exec_calls = 0
        self._stdout = []
        self._stderr = []
        self._error_in_stdout = None
        self._error_in_stderr = None
        self._has_cider = None
        self._has_xspice = None
        self._ngspice_version = None
        self._extensions = []
        self._library_path = None
        self._load_library(verbose)
        self._init_ngspice(send_data)
        self._is_running = False
    ##############################################
    @property
    def spinit_not_found(self):
        return self._spinit_not_found
    ##############################################
    @property
    def library_path(self):
        if self._library_path is None:
            if not self._ngspice_id:
                library_prefix = ''
            else:
                library_prefix = '{}'.format(self._ngspice_id)  # id =
            library_path = self.LIBRARY_PATH.format(library_prefix)
            self._library_path = library_path
        return self._library_path
    ##############################################
    def _load_library(self, verbose):
        if ConfigInstall.OS.on_windows:
            # https://sourceforge.net/p/ngspice/discussion/133842/thread/1cece652/#4e32/5ab8/9027
            # When environment variable SPICE_LIB_DIR is empty, ngspice looks in C:\Spice64\share\ngspice\scripts
            # Else it tries %SPICE_LIB_DIR%\scripts\spinit
            if 'SPICE_LIB_DIR' not in os.environ:
                _ = str(Path(self.NGSPICE_PATH).joinpath('share', 'ngspice'))
                os.environ['SPICE_LIB_DIR'] = _
                # self._logger.warning('Set SPICE_LIB_DIR = %s', _)
        # Fixme: not compatible with supra
        # if 'CONDA_PREFIX' in os.environ:
        #     _ = str(Path(os.environ['CONDA_PREFIX']).joinpath('share', 'ngspice'))
        #     os.environ['SPICE_LIB_DIR'] = _
        #     self._logger.warning('Set SPICE_LIB_DIR = %s', _)
        # https://sourceforge.net/p/ngspice/bugs/490
        # ngspice and Kicad do setlocale(LC_NUMERIC, "C");
        if ConfigInstall.OS.on_windows:
            self._logger.debug('locale LC_NUMERIC is not forced to C')
        elif ConfigInstall.OS.on_linux or ConfigInstall.OS.on_osx:
            self._logger.debug('Set locale LC_NUMERIC to C')
            import locale
            locale.setlocale(locale.LC_NUMERIC, 'C')
        api_path = Path(__file__).parent.joinpath('api.h')
        with open(api_path) as fh:
            ffi.cdef(fh.read())
        message = 'Load library {}'.format(self.library_path)
        self._logger.debug(message)
        if verbose:
            print(message)
        self._ngspice_shared = ffi.dlopen(self.library_path)
        # Note: cannot yet execute command
    ##############################################
    def _init_ngspice(self, send_data):
        # Ngspice API: ngSpice_Init ngSpice_Init_Sync
        self._send_char_c = ffi.callback('int (char *, int, void *)', self._send_char)
        self._send_stat_c = ffi.callback('int (char *, int, void *)', self._send_stat)
        self._exit_c = ffi.callback('int (int, bool, bool, int, void *)', self._exit)
        self._send_init_data_c = ffi.callback('int (pvecinfoall, int, void *)', self._send_init_data)
        self._background_thread_running_c = ffi.callback('int (bool, int, void *)', self._background_thread_running)
        if send_data:
            self._send_data_c = ffi.callback('int (pvecvaluesall, int, int, void *)', self._send_data)
        else:
            self._send_data_c = FFI.NULL
        self._get_vsrc_data_c = ffi.callback('int (double *, double, char *, int, void *)', self._get_vsrc_data)
        self._get_isrc_data_c = ffi.callback('int (double *, double, char *, int, void *)', self._get_isrc_data)
        self_c = ffi.new_handle(self)
        self._self_c = self_c  # To prevent garbage collection
        rc = self._ngspice_shared.ngSpice_Init(self._send_char_c,
                                               self._send_stat_c,
                                               self._exit_c,
                                               self._send_data_c,
                                               self._send_init_data_c,
                                               self._background_thread_running_c,
                                               self_c)
        if rc:
            raise NameError("Ngspice_Init returned {}".format(rc))
        ngspice_id_c = ffi.new('int *', self._ngspice_id)
        self._ngspice_id = ngspice_id_c  # To prevent garbage collection
        rc = self._ngspice_shared.ngSpice_Init_Sync(self._get_vsrc_data_c,
                                                    self._get_isrc_data_c,
                                                    FFI.NULL,  # GetSyncData
                                                    ngspice_id_c,
                                                    self_c)
        if rc:
            raise NameError("Ngspice_Init_Sync returned {}".format(rc))
        self._get_version()
        try:
            self._simulation_type = EnumFactory('SimulationType', SIMULATION_TYPE[self._ngspice_version])
        except KeyError:
            # See SimulationType.py
            self._simulation_type = EnumFactory('SimulationType', SIMULATION_TYPE['last'])
            self._logger.warning("Unsupported Ngspice version {}".format(self._ngspice_version))
        self._type_to_unit = {
            self._simulation_type.time: u_s,
            self._simulation_type.voltage: u_V,
            self._simulation_type.current: u_A,
            self._simulation_type.frequency: u_Hz,
            self._simulation_type.capacitance: u_F,
            self._simulation_type.temperature: u_Degree,
        }
        # Prevent paging output of commands (hangs)
        self.set('nomoremode')
    ##############################################
    @staticmethod
    def _send_char(message_c, ngspice_id, user_data):
        """Callback for sending output from stdout, stderr to caller"""
        self = ffi.from_handle(user_data)
        _module_logger.debug(str(ffi.string(message_c)))
        message = ffi_string_utf8(message_c)
        # split message in "<prefix><match = ' '><content>"
        prefix, _, content = message.partition(' ')
        if prefix == 'stderr':
            self._stderr.append(content)
            if content.startswith('Warning:'):
                func = self._logger.warning
            # elif content.startswith('Warning:'):
            else:
                self._error_in_stderr = True
                func = self._logger.error
                if content.strip() == "Note: can't find init file.":
                    self._spinit_not_found = True
                    self._logger.warning('spinit was not found')
            func(content)
        else:
            self._stdout.append(content)
            # Fixme: Ngspice writes error on stdout and stderr ...
            if 'error' in content.lower():
                self._error_in_stdout = True
            # if self._error_in_stdout:
            #     self._logger.warning(content)
        # Fixme: ???
        return self.send_char(message, ngspice_id)
    ##############################################
    @staticmethod
    def _send_stat(message, ngspice_id, user_data):
        """Callback for simulation status to caller"""
        self = ffi.from_handle(user_data)
        return self.send_stat(ffi_string_utf8(message), ngspice_id)
    ##############################################
    @staticmethod
    def _exit(exit_status, immediate_unloding, quit_exit, ngspice_id, user_data):
        """Callback for asking for a reaction after controlled exit"""
        self = ffi.from_handle(user_data)
        self._logger.debug('ngspice_id-{} exit status={} immediate_unloding={} quit_exit={}'.format(
            ngspice_id,
            exit_status,
            immediate_unloding,
            quit_exit))
        return exit_status
    ##############################################
    @staticmethod
    def _send_data(data, number_of_vectors, ngspice_id, user_data):
        """Callback to send back actual vector data"""
        self = ffi.from_handle(user_data)
        # self._logger.debug('ngspice_id-{} send_data [{}]'.format(ngspice_id, data.vecindex))
        actual_vector_values = {}
        for i in range(int(number_of_vectors)):
            actual_vector_value = data.vecsa[i]
            vector_name = ffi_string_utf8(actual_vector_value.name)
            value = complex(actual_vector_value.creal, actual_vector_value.cimag)
            actual_vector_values[vector_name] = value
            # self._logger.debug('    Vector: {} {}'.format(vector_name, value))
        return self.send_data(actual_vector_values, number_of_vectors, ngspice_id)
    ##############################################
    @staticmethod
    def _send_init_data(data, ngspice_id, user_data):
        """Callback to send back initialization vector data"""
        self = ffi.from_handle(user_data)
        # if self._logger.isEnabledFor(logging.DEBUG):
        #     self._logger.debug('ngspice_id-{} send_init_data'.format(ngspice_id))
        #     number_of_vectors = data.veccount
        #     for i in range(number_of_vectors):
        #         self._logger.debug('  Vector: ' + ffi_string_utf8(data.vecs[i].vecname))
        return self.send_init_data(data, ngspice_id)  # Fixme: should be a Python object
    ##############################################
    @staticmethod
    def _background_thread_running(is_running, ngspice_id, user_data):
        """Callback to indicate if background thread is runnin"""
        self = ffi.from_handle(user_data)
        self._logger.debug('ngspice_id-{} background_thread_running {}'.format(ngspice_id, is_running))
        self._is_running = is_running
    ##############################################
    @staticmethod
    def _get_vsrc_data(voltage, time, node, ngspice_id, user_data):
        """FFI Callback"""
        self = ffi.from_handle(user_data)
        return self.get_vsrc_data(voltage, time, ffi_string_utf8(node), ngspice_id)
    ##############################################
    @staticmethod
    def _get_isrc_data(current, time, node, ngspice_id, user_data):
        """FFI Callback"""
        self = ffi.from_handle(user_data)
        return self.get_isrc_data(current, time, ffi_string_utf8(node), ngspice_id)
    ##############################################
    def send_char(self, message, ngspice_id):
        """ Reimplement this callback in a subclass to process logging messages from the simulator. """
        # self._logger.debug('ngspice-{} send_char {}'.format(ngspice_id, message))
        return 0
    ##############################################
    def send_stat(self, message, ngspice_id):
        """ Reimplement this callback in a subclass to process statistic messages from the simulator. """
        # self._logger.debug('ngspice-{} send_stat {}'.format(ngspice_id, message))
        return 0
    ##############################################
    def send_data(self, actual_vector_values, number_of_vectors, ngspice_id):
        """ Reimplement this callback in a subclass to process the vector actual values. """
        return 0
    ##############################################
    def send_init_data(self, data, ngspice_id):
        """ Reimplement this callback in a subclass to process the initial data. """
        return 0
    ##############################################
    def get_vsrc_data(self, voltage, time, node, ngspice_id):
        """ Reimplement this callback in a subclass to provide external voltage source. """
        self._logger.debug('ngspice_id-{} get_vsrc_data @{} node {}'.format(ngspice_id, time, node))
        return 0
    ##############################################
    def get_isrc_data(self, current, time, node, ngspice_id):
        """ Reimplement this callback in a subclass to provide external current source. """
        self._logger.debug('ngspice_id-{} get_isrc_data @{} node {}'.format(ngspice_id, time, node))
        return 0
    ##############################################
    @staticmethod
    def _convert_string_array(array):
        strings = []
        i = 0
        while True:
            if array[i] == FFI.NULL:
                break
            strings.append(ffi_string_utf8(array[i]))
            i += 1
        return strings
    ##############################################
    @staticmethod
    def _to_python(value):
        try:
            return int(value)
        except ValueError:
            try:
                # Fixme: return float(value.replace(',', '.'))
                return float(value)
            except ValueError:
                return str(value)
    ##############################################
    @staticmethod
    def _lines_to_dicts(lines):
        if lines:
            values = dict(description=lines[0])
            values.update({
                parts[0]: NgSpiceShared._to_python(parts[1])
                for parts in map(str.split, lines)
            })
            return values
        else:
            raise ValueError
    ##############################################
    @property
    def is_running(self):
        return self._is_running
    ##############################################
    def clear_output(self):
        self._stdout = []
        self._stderr = []
        self._error_in_stdout = False
        self._error_in_stderr = False
    ##############################################
    @property
    def stdout(self):
        return os.linesep.join(self._stdout)
    @property
    def stderr(self):
        return os.linesep.join(self._stderr)
    ##############################################
    def exec_command(self, command, join_lines=True):
        """ Execute a command and return the output. """
        # Ngspice API: ngSpice_Command
        # Prevent memory leaks by periodically freeing ngspice history of past commands
        #   Each command sent to ngspice is stored in the control structures
        if self._number_of_exec_calls > self.NUMBER_OF_EXEC_CALLS_TO_RELEASE_MEMORY:
            # Clear the internal control structures
            self._ngspice_shared.ngSpice_Command(FFI.NULL)
            self._number_of_exec_calls = 0
        self._number_of_exec_calls += 1
        if len(command) > self.MAX_COMMAND_LENGTH:
            raise ValueError('Command must not exceed {} characters'.format(self.MAX_COMMAND_LENGTH))
        self._logger.debug('Execute command: {}'.format(command))
        self.clear_output()
        encoded_command = command.encode('ascii')
        rc = self._ngspice_shared.ngSpice_Command(encoded_command)
        if rc:  # Fixme: when not 0 ???
            raise NameError("ngSpice_Command '{}' returned {}".format(command, rc))
        if self._error_in_stdout or self._error_in_stderr:
            raise NgSpiceCommandError("Command '{}' failed".format(command))
        if join_lines:
            return self.stdout
        else:
            return self._stdout
    ##############################################
    def _get_version(self):
        self._ngspice_version = None
        self._has_xspice = False
        self._has_cider = False
        self._extensions = []
        output = self.exec_command('version -f')
        for line in output.split('\n'):
            match = re.match(r'\*\* ngspice\-(\d+)', line)
            if match is not None:
                self._ngspice_version = int(match.group(1))
            # if '** XSPICE extensions included' in line:
            if '** XSPICE' in line:
                self._has_xspice = True
                self._extensions.append('XSPICE')
            # if '** CIDER 1.b1 (CODECS simulator) included' in line:
            if 'CIDER' in line:
                self._has_cider = True
                self._extensions.append('CIDER')
        self._logger.debug(
            'Ngspice version %s with extensions: %s',
            self._ngspice_version,
            ', '.join(self._extensions),
        )
    ##############################################
    @property
    def ngspice_version(self):
        return self._ngspice_version
    @property
    def has_xspice(self):
        """Return True if libngspice was compiled with XSpice support."""
        return self._has_xspice
    @property
    def has_cider(self):
        """Return True if libngspice was compiled with CIDER support."""
        return self._has_cider
    ##############################################
    @property
    def simulation_type(self):
        return self._simulation_type
    def type_to_unit(self, vector_type):
        return self._type_to_unit.get(vector_type, None)
    ##############################################
    def _alter(self, command, device, kwargs):
        # Performance optimization: dispatch multiple alter commands jointly
        device_name = device.lower()
        commands = []
        commands_str_len = 0
        for key, value in kwargs.items():
            if isinstance(value, (list, tuple)):
                value = '[ ' + ' '.join(value) + ' ]'
            cmd = '{} {} {} = {}'.format(command, device_name, key, value)
            # performance optimization: collect multiple alter commands and
            #                           dispatch them jointly
            commands.append(cmd)
            commands_str_len += len(cmd)
            if commands_str_len + len(commands) > self.MAX_COMMAND_LENGTH:
                self.exec_command(';'.join(commands[:-1]))
                commands = commands[-1:]
                commands_str_len = len(commands[0])
        if commands:
            self.exec_command(';'.join(commands))
    ##############################################
    def alter_device(self, device, **kwargs):
        """Alter device parameters"""
        self._alter('alter', device, kwargs)
    ##############################################
    def alter_model(self, model, **kwargs):
        """Alter model parameters"""
        self._alter('altermod', model, kwargs)
    ##############################################
    def delete(self, debug_number):
        """Remove a trace or breakpoint"""
        self.exec_command('delete {}'.format(debug_number))
    ##############################################
    def destroy(self, plot_name='all'):
        """Release the memory holding the output data (the given plot or all plots) for the specified runs."""
        self.exec_command('destroy ' + plot_name)
    ##############################################
    def device_help(self, device):
        """Shows the user information about the devices available in the simulator. """
        return self.exec_command('devhelp ' + device.lower())
    ##############################################
    def save(self, vector):
        self.exec_command('save ' + vector)
    ##############################################
    def _show(self, command):
        lines = self.exec_command(command, join_lines=False)
        if lines:
            values = self._lines_to_dicts(lines)
            return values
        else:
            return ''
    ##############################################
    def show(self, device):
        return self._show('show ' + device.lower())
    ##############################################
    def showmod(self, device):
        return self._show('showmod ' + device.lower())
    ##############################################
    def source(self, file_path):
        """Read a ngspice input file"""
        self.exec_command('source ' + file_path)
    ##############################################
    def option(self, **kwargs):
        """Set any of the simulator variables."""
        for key, value in kwargs.items():
            self.exec_command('option {} = {}'.format(key, value))
    ##############################################
    def quit(self):
        self.set('noaskquit')
        return self.exec_command('quit')
    ##############################################
    def remove_circuit(self):
        """Removes the current circuit from the list of circuits sourced into ngspice."""
        self.exec_command('remcirc')
    ##############################################
    def reset(self):
        """Throw out any intermediate data in the circuit (e.g, after a breakpoint or after one or more
        analyses have been done already), and re-parse the input file. The circuit can then be
        re-run from it’s initial state, overriding the affect of any set or alter commands.
        """
        self.exec_command('reset')
    ##############################################
    def ressource_usage(self, *ressources):
        """Print resource usage statistics. If any resources are given, just print the usage of that resource.
        Most resources require that a circuit be loaded. Currently valid resources are:
        * decklineno    Number of lines in deck
        * netloadtime   Nelist loading time
        * netparsetime  Netlist parsing time
        * elapsed       The amount of time elapsed since the last rusage elapsed call.
        * faults        Number of page faults and context switches (BSD only).
        * space         Data space used.
        * time          CPU time used so far.
        * temp          Operating temperature.
        * tnom          Temperature at which device parameters were measured.
        * equations     Circuit Equations
        * time Total    Analysis Time
        * totiter       Total iterations
        * accept        Accepted time-points
        * rejected      Rejected time-points
        * loadtime      Time spent loading the circuit matrix and RHS.
        * reordertime   Matrix reordering time
        * lutime        L-U decomposition time
        * solvetime     Matrix solve time
        * trantime      Transient analysis time
        * tranpoints    Transient time-points
        * traniter      Transient iterations
        * trancuriters  Transient iterations for the last time point*
        * tranlutime    Transient L-U decomposition time
        * transolvetime Transient matrix solve time
        * everything    All of the above.
        """
        if not ressources:
            ressources = ['everything']
        command = 'rusage ' + ' '.join(ressources)
        lines = self.exec_command(command, join_lines=False)
        values = {}
        for line in lines:
            if '=' in line:
                parts = line.split(' = ')
            else:
                parts = line.split(': ')
            values[parts[0]] = NgSpiceShared._to_python(parts[1])
        return values
    ##############################################
    def set(self, *args, **kwargs):
        """Set the value of variables"""
        for key in args:
            self.exec_command('set {}'.format(key))
        for key, value in kwargs.items():
            self.exec_command('option {} = {}'.format(key, value))
    ##############################################
    def set_circuit(self, name):
        """Change the current circuit"""
        self.exec_command('setcirc {}'.format(name))
    ##############################################
    def status(self):
        """Display breakpoint information"""
        return self.exec_command('status')
    ##############################################
    def step(self, number_of_steps=None):
        """Run a fixed number of time-points"""
        if number_of_steps is not None:
            self.exec_command('step {}'.format(number_of_steps))
        else:
            self.exec_command('step')
    ##############################################
    def stop(self, *args, **kwargs):
        """Set a breakpoint.
        Examples::
            ngspice.stop('v(out) > 1', 'v(1) > 10', after=10)
        A when condition can use theses symbols: = <> > < >= <=.
        """
        command = 'stop'
        if 'after' in kwargs:
            command += ' after {}'.format(kwargs['after'])
        for condition in args:
            command += ' when {}'.format(condition)
        self.exec_command(command)
    ##############################################
    def trace(self, *args):
        """Trace nodes"""
        self.exec_command('trace ' + ' '.join(args))
    ##############################################
    def unset(self, *args):
        """Unset variables"""
        for key in args:
            self.exec_command('unset {}'.format(key))
    ##############################################
    def where(self):
        """Identify troublesome node or device"""
        return self.exec_command('where')
    ##############################################
    def load_circuit(self, circuit):
        """Load the given circuit string."""
        # Ngspice API: ngSpice_Circ
        circuit_lines = [line for line in str(circuit).splitlines() if line]
        self._logger.debug('ngSpice_Circ\n' + str(circuit))
        # ngspice 33 requires an empty line at the end
        circuit_lines.append("")
        circuit_lines_keepalive = [ffi.new("char[]", line.encode('utf8'))
                                   for line in circuit_lines]
        circuit_lines_keepalive += [FFI.NULL]
        circuit_array = ffi.new("char *[]", circuit_lines_keepalive)
        self.clear_output()
        rc = self._ngspice_shared.ngSpice_Circ(circuit_array)
        if rc:  # Fixme: when not 0 ???
            raise NameError("ngSpice_Circ returned {}".format(rc))
        # Fixme: when Ngspice found an error in the circuit, it reports the error in stdout
        # Fixme: https://sourceforge.net/p/ngspice/bugs/496/
        if self._error_in_stdout:
            self._logger.error('\n' + self.stdout)
            raise NgSpiceCircuitError('')
        # for line in circuit_lines:
        #     rc = self._ngspice_shared.ngSpice_Command(('circbyline ' + line).encode('utf8'))
        #     if rc:
        #         raise NameError("ngSpice_Command circbyline returned {}".format(rc))
    ##############################################
    def listing(self):
        command = 'listing'
        return self.exec_command(command)
    ##############################################
    def run(self, background=False):
        """ Run the simulation. """
        #  in the background thread and wait until the simulation is done
        command = 'bg_run' if background else 'run'
        self.exec_command(command)
        if background:
            self._is_running = True
        else:
            self._logger.debug("Simulation is done")
        # time.sleep(.1) # required before to test if the simulation is running
        # while (self._ngspice_shared.ngSpice_running()):
        #     time.sleep(.1)
        #     self._logger.debug("Simulation is done")
    ##############################################
    def halt(self):
        """ Halt the simulation in the background thread. """
        self.exec_command('bg_halt')
    ##############################################
    def resume(self, background=True):
        """ Halt the simulation in the background thread. """
        command = 'bg_resume' if background else 'resume'
        self.exec_command(command)
    ##############################################
    @property
    def plot_names(self):
        """ Return the list of plot names. """
        # Ngspice API: ngSpice_AllPlots
        return self._convert_string_array(self._ngspice_shared.ngSpice_AllPlots())
    ##############################################
    @property
    def last_plot(self):
        """ Return the last plot name. """
        return self.plot_names[0]
    ##############################################
    @staticmethod
    def _flags_to_str(flags):
        # enum dvec_flags {
        #   VF_REAL = (1 << 0),		// The data is real.
        #   VF_COMPLEX = (1 << 1),	// The data is complex.
        #   VF_ACCUM = (1 << 2),	// writedata should save this vector.
        #   VF_PLOT = (1 << 3),		// writedata should incrementally plot it.
        #   VF_PRINT = (1 << 4),	// writedata should print this vector.
        #   VF_MINGIVEN = (1 << 5),	// The v_minsignal value is valid.
        #   VF_MAXGIVEN = (1 << 6),	// The v_maxsignal value is valid.
        #   VF_PERMANENT = (1 << 7)	// Don't garbage collect this vector.
        # };
        if flags & 1:
            return 'real'
        elif flags & 2:
            return 'complex'
        else:
            raise NotImplementedError
    ##############################################
    @staticmethod
    def _vector_is_real(flags):
        return flags & 1
    ##############################################
    @staticmethod
    def _vector_is_complex(flags):
        return flags & 2
    ##############################################
    def plot(self, simulation, plot_name):
        """ Return the corresponding plot. """
        # Ngspice API: ngSpice_AllVecs ngGet_Vec_Info
        # plot_name is for example dc with an integer suffix which is increment for each run
        plot = Plot(simulation, plot_name)
        all_vectors_c = self._ngspice_shared.ngSpice_AllVecs(plot_name.encode('utf8'))
        i = 0
        while True:
            if all_vectors_c[i] == FFI.NULL:
                break
            vector_name = ffi_string_utf8(all_vectors_c[i])
            name = '.'.join((plot_name, vector_name))
            vector_info = self._ngspice_shared.ngGet_Vec_Info(name.encode('utf8'))
            vector_type = self._simulation_type[vector_info.v_type]
            length = vector_info.v_length
            # template = 'vector[{}] {} type {} flags {} length {}'
            # self._logger.debug(template.format(
            #     i,
            #     vector_name,
            #     vector_type,
            #     self._flags_to_str(vector_info.v_flags),
            #     length,
            # ))
            if vector_info.v_compdata == FFI.NULL:
                # for k in range(length):
                #     print("  [{}] {}".format(k, vector_info.v_realdata[k]))
                tmp_array = np.frombuffer(ffi.buffer(vector_info.v_realdata, length*8), dtype=np.float64)
                array = np.array(tmp_array, dtype=tmp_array.dtype)  # copy data
                # import json
                # with open(name + '.json', 'w') as fh:
                #     json.dump(list(array), fh)
            else:
                # for k in range(length):
                #     value = vector_info.v_compdata[k]
                #     print(ffi.addressof(value, field='cx_real'), ffi.addressof(value, field='cx_imag'))
                #     print("  [{}] {} + i {}".format(k, value.cx_real, value.cx_imag))
                tmp_array = np.frombuffer(ffi.buffer(vector_info.v_compdata, length*8*2), dtype=np.float64)
                array = np.array(tmp_array[0::2], dtype=np.complex128)
                array.imag = tmp_array[1::2]
            plot[vector_name] = Vector(self, vector_name, vector_type, array)
            i += 1
        return plot
####################################################################################################
#
# Platform setup
#
NgSpiceShared.setup_platform()
</file>

<file path="PySpice/Spice/NgSpice/Simulation.py">
###################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This modules implements classes to perform simulations.
"""
####################################################################################################
import logging
####################################################################################################
from ..Simulation import CircuitSimulator
from .Server import SpiceServer
from .Shared import NgSpiceShared
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class NgSpiceCircuitSimulator(CircuitSimulator):
    SIMULATOR = 'ngspice'
    ##############################################
    def __init__(self, circuit, **kwargs):
        super().__init__(circuit, **kwargs)
        if kwargs.get('pipe', True):
            self.options('NOINIT')
            self.options(filetype='binary')
####################################################################################################
class NgSpiceSubprocessCircuitSimulator(NgSpiceCircuitSimulator):
    _logger = _module_logger.getChild('NgSpiceSubprocessCircuitSimulator')
    ##############################################
    def __init__(self, circuit, **kwargs):
        super().__init__(circuit, pipe=True, **kwargs)
        # Fixme: to func ?
        server_kwargs = {x:kwargs[x] for x in ('spice_command',) if x in kwargs}
        self._spice_server = SpiceServer(**server_kwargs)
    ##############################################
    def _run(self, analysis_method, *args, **kwargs):
        super()._run(analysis_method, *args, **kwargs)
        raw_file = self._spice_server(spice_input=str(self))
        self.reset_analysis()
        raw_file.simulation = self
        # for field in raw_file.variables:
        #     print field
        return raw_file.to_analysis()
####################################################################################################
class NgSpiceSharedCircuitSimulator(NgSpiceCircuitSimulator):
    _logger = _module_logger.getChild('NgSpiceSharedCircuitSimulator')
    ##############################################
    def __init__(self, circuit, **kwargs):
        super().__init__(circuit, pipe=False, **kwargs)
        ngspice_shared = kwargs.get('ngspice_shared', None)
        if ngspice_shared is None:
            self._ngspice_shared = NgSpiceShared.new_instance()
        else:
            self._ngspice_shared = ngspice_shared
    ##############################################
    @property
    def ngspice(self):
        return self._ngspice_shared
    ##############################################
    def _run(self, analysis_method, *args, **kwargs):
        super()._run(analysis_method, *args, **kwargs)
        self._ngspice_shared.destroy()
        # load circuit and simulation
        # Fixme: Error: circuit not parsed.
        self._ngspice_shared.load_circuit(str(self))
        self._ngspice_shared.run()
        self._logger.debug(str(self._ngspice_shared.plot_names))
        self.reset_analysis()
        plot_name = self._ngspice_shared.last_plot
        if plot_name == 'const':
            raise NameError('Simulation failed')
        return self._ngspice_shared.plot(self, plot_name).to_analysis()
</file>

<file path="PySpice/Spice/NgSpice/SimulationType.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
__all__ = [
    'LAST_VERSION',
    'SIMULATION_TYPE',
]
####################################################################################################
# For a new ngspice relase, we just have to check this file hasn't changed
#   ngspice-xx/src/include/ngspice/sim.h
SIMULATION_TYPE = {}
SIMULATION_TYPE[26] = (
    'no_type',
    'time',
    'frequency',
    'voltage',
    'current',
    'output_n_dens',
    'output_noise',
    'input_n_dens',
    'input_noise',
    'pole',
    'zero',
    's_parameter',
    'temperature',
    'res',
    'impedance',
    'admittance',
    'power',
    'phase',
    'db',
    'capacitance',
    'charge',
)
SIMULATION_TYPE[27] = (
    'no_type',
    'time',
    'frequency',
    'voltage',
    'current',
    'voltage_density',
    'current_density',
    'sqr_voltage_density',
    'sqr_current_density',
    'sqr_voltage',
    'sqr_current',
    'pole',
    'zero',
    's_parameter',
    'temperature',
    'res',
    'impedance',
    'admittance',
    'power',
    'phase',
    'db',
    'capacitance',
    'charge',
)
LAST_VERSION = 34   # released on January 31st, 2021
for version in range(28, LAST_VERSION +1):
    SIMULATION_TYPE[version] = SIMULATION_TYPE[27]
SIMULATION_TYPE['last'] = SIMULATION_TYPE[LAST_VERSION]
</file>

<file path="PySpice/Spice/Xyce/RawFile.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
import os
from ..RawFile import VariableAbc, RawFileAbc
####################################################################################################
"""This module provide tools to read the output of Xyce.
Header
"""
####################################################################################################
import logging
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class Variable(VariableAbc):
    ##############################################
    def is_voltage_node(self):
        name = self.name.lower()
        return name.startswith('v(') or not self.is_branch_current()
    ##############################################
    def is_branch_current(self):
        return self.name.endswith('#branch')
    ##############################################
    @staticmethod
    def to_voltage_name(node):
        return 'v({})'.format(node)
    ##############################################
    @property
    def simplified_name(self):
        name = self.name
        if len(name) > 1 and name[1] == '(':
            return name[2:-1]
        elif name.endswith('#branch'):
            return name[:-7]
        elif '#' in name:
            # Xyce change name of type "output_plus" to "OUTPUT#PLUS"
            return name.replace('#', '_')
        else:
            return self.name
####################################################################################################
class RawFile(RawFileAbc):
    """ This class parse the stdout of ngspice and the raw data output.
    Public Attributes:
      :attr:`data`
      :attr:`date`
      :attr:`flags`
        'real' or 'complex'
      :attr:`number_of_points`
      :attr:`number_of_variables`
      :attr:`plot_name`
        AC Analysis, Operating Point, Sensitivity Analysis, DC transfer characteristic
      :attr:`title`
      :attr:`variables`
    """
    _logger = _module_logger.getChild('RawFile')
    _variable_cls = Variable
    ##############################################
    def __init__(self, output):
        raw_data = self._read_header(output)
        self._read_variable_data(raw_data)
        # self._to_analysis()
        self._simulation = None
    ##############################################
    def _read_header(self, output):
        """ Parse the header """
        # see https://github.com/FabriceSalvaire/PySpice/issues/132
        #   Xyce open the file in binary mode and print using: os << "Binary:" << std::endl;
        #   endl is thus \n
        binary_line = b'Binary:\n'
        binary_location = output.find(binary_line)
        if binary_location < 0:
            raise NameError('Cannot locate binary data')
        raw_data_start = binary_location + len(binary_line)
        self._logger.debug(os.linesep + output[:raw_data_start].decode('utf-8'))
        header_lines = output[:binary_location].splitlines()
        raw_data = output[raw_data_start:]
        header_line_iterator = iter(header_lines)
        self.title = self._read_header_field_line(header_line_iterator, 'Title')
        self.date = self._read_header_field_line(header_line_iterator, 'Date')
        self.plot_name = self._read_header_field_line(header_line_iterator, 'Plotname')
        self.flags = self._read_header_field_line(header_line_iterator, 'Flags')
        self.number_of_variables = int(self._read_header_field_line(header_line_iterator, 'No. Variables'))
        self.number_of_points = int(self._read_header_field_line(header_line_iterator, 'No. Points'))
        self._read_header_field_line(header_line_iterator, 'Variables')
        self._read_header_variables(header_line_iterator)
        return raw_data
    ##############################################
    def fix_case(self):
        """ Ngspice return lower case names. This method fixes the case of the variable names. """
        circuit = self.circuit
        element_translation = {element.upper():element for element in circuit.element_names}
        node_translation = {node.upper():node for node in circuit.node_names}
        for variable in self.variables.values():
            variable.fix_case(element_translation, node_translation)
    ##############################################
    def _to_dc_analysis(self):
        if 'sweep' in self.variables:
            sweep_variable = self.variables['sweep']
        else:
            raise NotImplementedError
        return super()._to_dc_analysis(sweep_variable)
</file>

<file path="PySpice/Spice/Xyce/Server.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This module provides an interface to run xyce and get back the simulation
output.
"""
####################################################################################################
import logging
import os
import shutil
import subprocess
import tempfile
from PySpice.Config import ConfigInstall
from .RawFile import RawFile
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class XyceServer:
    """This class wraps the execution of Xyce and convert the output to a Python data structure.
    Example of usage::
      spice_server = XyceServer(xyce_command='/path/to/Xyce')
      raw_file = spice_server(spice_input)
    It returns a :obj:`PySpice.Spice.RawFile` instance.
    Default Xyce path is set in `XyceServer.XYCE_COMMAND`.
    """
    if ConfigInstall.OS.on_linux:
        XYCE_COMMAND = 'Xyce'
    elif ConfigInstall.OS.on_osx:
        XYCE_COMMAND = 'Xyce'
    elif ConfigInstall.OS.on_windows:
        XYCE_COMMAND = 'C:\\Program Files\\Xyce 6.10 OPENSOURCE\\bin\\Xyce.exe'
    else:
        raise NotImplementedError
    _logger = _module_logger.getChild('XyceServer')
    ##############################################
    def __init__(self, **kwargs):
        self._xyce_command = kwargs.get('xyce_command') or self.XYCE_COMMAND
    ##############################################
    def _parse_stdout(self, stdout):
        """Parse stdout for errors."""
        # log Spice output
        self._logger.info(os.linesep + stdout.decode('utf-8'))
        error_found = False
        simulation_failed = False
        warning_found = False
        lines = stdout.splitlines()
        for line_index, line in enumerate(lines):
            if line.startswith(b'Netlist warning'):
                warning_found = True
                # Fixme: highlight warnings
                self._logger.warning(os.linesep + line.decode('utf-8'))
            elif line.startswith(b'Netlist error'):
                error_found = True
                self._logger.error(os.linesep + line.decode('utf-8'))
            elif b'Transient failure history' in line:
                simulation_failed = True
                self._logger.error(os.linesep + line.decode('utf-8'))
        if error_found:
            raise NameError("Errors was found by Xyce")
        elif simulation_failed:
            raise NameError("Xyce simulation failed")
    ##############################################
    def __call__(self, spice_input):
        """Run SPICE in server mode as a subprocess for the given input and return a
        :obj:`PySpice.RawFile.RawFile` instance.
        """
        self._logger.debug('Start the xyce subprocess')
        tmp_dir = tempfile.mkdtemp()
        input_filename = os.path.join(tmp_dir, 'input.cir')
        output_filename = os.path.join(tmp_dir, 'output.raw')
        with open(input_filename, 'w') as f:
            f.write(str(spice_input))
        command = (self._xyce_command, '-r', output_filename, input_filename)
        self._logger.info('Run {}'.format(' '.join(command)))
        process = subprocess.Popen(
            command,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        stdout, stderr = process.communicate()
        self._parse_stdout(stdout)
        with open(output_filename, 'rb') as f:
            output = f.read()
        # self._logger.debug(output)
        raw_file = RawFile(output)
        shutil.rmtree(tmp_dir)
        return raw_file
</file>

<file path="PySpice/Spice/Xyce/Simulation.py">
###################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This modules implements classes to perform simulations.
"""
####################################################################################################
import logging
####################################################################################################
from ..Simulation import CircuitSimulator
from .Server import XyceServer
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class XyceCircuitSimulator(CircuitSimulator):
    _logger = _module_logger.getChild('XyceCircuitSimulator')
    SIMULATOR = 'xyce'
    ##############################################
    def __init__(self, circuit, **kwargs):
        super().__init__(circuit, **kwargs)
        xyce_command = kwargs.get('xyce_command', None)
        self._xyce_server = XyceServer(xyce_command=xyce_command)
    ##############################################
    def str_options(self):
        return super().str_options(unit=False)
    ##############################################
    def _run(self, analysis_method, *args, **kwargs):
        super()._run(analysis_method, *args, **kwargs)
        raw_file = self._xyce_server(spice_input=str(self))
        self.reset_analysis()
        raw_file.simulation = self
        # for field in raw_file.variables:
        #     print field
        return raw_file.to_analysis()
</file>

<file path="PySpice/Spice/__init__.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
import logging
from . import BasicElement
from . import HighLevelElement
from .Netlist import Netlist, ElementParameterMetaClass
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
def _get_elements(module):
    element_classes = []
    for item  in module.__dict__.values():
        if (type(item) is ElementParameterMetaClass
            and item.PREFIX is not None
           ):
            element_classes.append(item)
    return element_classes
####################################################################################################
#
# Add a method to create elements to the Netlist class
#
spice_elements = _get_elements(BasicElement)
high_level_elements = _get_elements(HighLevelElement)
for element_class in spice_elements + high_level_elements:
    def _make_function(element_class):
        def function(self, *args, **kwargs):
            return element_class(self, *args, **kwargs)
        # Preserve docstrings for element shortcuts
        function.__doc__ = element_class.__doc__
        return function
    func = _make_function(element_class)
    def _set(name):
        # _module_logger.debug("Add device shortcut {} for class {}".format(name, element_class))
        setattr(Netlist, name, func)
    _set(element_class.__name__)
    if element_class in spice_elements:
        if hasattr(element_class, 'ALIAS'):
            _set(element_class.ALIAS)
        if hasattr(element_class, 'LONG_ALIAS'):
            _set(element_class.LONG_ALIAS)
</file>

<file path="PySpice/Spice/BasicElement.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This module implements SPICE circuit elements.
.. warning:: Some elements are partially implemented.
.. warning:: The API documentation generated by Sphinx is perfectible for this module. The source
             code can be more informative.
.. note:: It would be nice to have a useful and working documentation in the interactive environment.
The element's parameters are internally implemented using class attributes and descriptors.
There are two types of parameters, positionals which are required and where the order mater, and
optional parameters which are passed as keyword arguments.
Parameters are registered with more expressive and longer names than their Spice counterparts.  For
optional parameters, we can use both Spice and longer name for convenience.
See Ngspice documentation for details.
+--------------+------------------------------------------------------+
| First letter + Element description                                  |
+--------------+------------------------------------------------------+
| A            + XSPICE code model                                    |
+--------------+------------------------------------------------------+
| B            + Behavioral (arbitrary) source                        |
+--------------+------------------------------------------------------+
| C            + Capacitor                                            |
+--------------+------------------------------------------------------+
| D            + Diode                                                |
+--------------+------------------------------------------------------+
| E            + Voltage-controlled voltage source (VCVS)             |
+--------------+------------------------------------------------------+
| F            + Current-controlled current source (CCCs)             |
+--------------+------------------------------------------------------+
| G            + Voltage-controlled current source (VCCS)             |
+--------------+------------------------------------------------------+
| H            + Current-controlled voltage source (CCVS)             |
+--------------+------------------------------------------------------+
| I            + Current source                                       |
+--------------+------------------------------------------------------+
| J            + Junction field effect transistor (JFET)              |
+--------------+------------------------------------------------------+
| K            + Coupled (Mutual) Inductors                           |
+--------------+------------------------------------------------------+
| L            + Inductor                                             |
+--------------+------------------------------------------------------+
| M            + Metal oxide field effect transistor (MOSFET)         |
+--------------+------------------------------------------------------+
| N            + Numerical device for GSS                             |
+--------------+------------------------------------------------------+
| O            + Lossy transmission line                              |
+--------------+------------------------------------------------------+
| P            + Coupled multiconductor line (CPL)                    |
+--------------+------------------------------------------------------+
| Q            + Bipolar junction transistor (BJT)                    |
+--------------+------------------------------------------------------+
| R            + Resistor                                             |
+--------------+------------------------------------------------------+
| S            + Switch (voltage-controlled)                          |
+--------------+------------------------------------------------------+
| T            + Lossless transmission line                           |
+--------------+------------------------------------------------------+
| U            + Uniformly distributed RC line                        |
+--------------+------------------------------------------------------+
| V            + Voltage source                                       |
+--------------+------------------------------------------------------+
| W            + Switch (current-controlled)                          |
+--------------+------------------------------------------------------+
| X            + Subcircuit                                           |
+--------------+------------------------------------------------------+
| Y            + Single lossy transmission line (TXL)                 |
+--------------+------------------------------------------------------+
| Z            + Metal semiconductor field effect transistor (MESFET) |
+--------------+------------------------------------------------------+
"""
####################################################################################################
import logging
from ..Tools.StringTools import str_spice, join_list, join_dict
from ..Unit import U_m, U_s, U_A, U_V, U_Degree, U_Ω, U_F, U_H, U_Hz
from .Netlist import (Element, AnyPinElement, FixedPinElement, NPinElement, OptionalPin)
from .ElementParameter import (
    # KeyValueParameter,
    BoolKeyParameter,
    ElementNamePositionalParameter,
    ExpressionKeyParameter,
    ExpressionPositionalParameter,
    FlagParameter,
    FloatKeyParameter,
    FloatPairKeyParameter,
    FloatTripletKeyParameter,
    FloatPositionalParameter,
    InitialStatePositionalParameter,
    IntKeyParameter,
    ModelPositionalParameter,
    )
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class DipoleElement(FixedPinElement):
    """This class implements a base class for dipole element."""
    PINS = ('plus', 'minus')
class TwoPortElement(FixedPinElement):
    """This class implements a base class for two-port element."""
    PINS = ('output_plus', 'output_minus', 'input_plus', 'input_minus')
####################################################################################################
class SubCircuitElement(NPinElement):
    """This class implements a sub-circuit.
    Spice syntax:
    .. code-block:: none
        XYYYYYY node1 node2 ... subcircuit_name parameter1=value1 ...
    Attributes:
      :attr:`subcircuit_name`
    .. note:: As opposite to Spice, the circuit's name is specified before the nodes so as to act as `*args`.
    """
    ALIAS = 'X'
    PREFIX = 'X'
    subcircuit_name = ElementNamePositionalParameter(position=0, key_parameter=False)
    ##############################################
    def __init__(self, netlist, name, subcircuit_name, *nodes, **parameters):
        super().__init__(netlist, name, nodes, subcircuit_name)
        # Fixme: match parameters to subcircuit
        self.parameters = parameters
        # Fixme: investigate
        # for key, value in parameters.items():
        #     parameter = KeyValueParameter(key)
        #     parameter.__set__(self, value)
        #     self.optional_parameters[key] = parameter
        #     setattr(self, key, parameter)
    ##############################################
    def copy_to(self, netlist):
        element = self.__class__(netlist, self._name, self.subcircuit_name, *self.node_names, **self.parameters)
        # Element.copy_to(self, element)
        return element
    ##############################################
    def format_spice_parameters(self):
        """ Return the formatted list of parameters. """
        spice_parameters = super().format_spice_parameters()
        if self.parameters:
            spice_parameters += ' ' + join_dict(self.parameters)
        return spice_parameters
####################################################################################################
#
# Elementary devices: Resistor, Capacitor, Inductor, Switch (VCSw/CCSw)
#
####################################################################################################
class Resistor(DipoleElement):
    """This class implements a resistor.
    Spice syntax:
    .. code-block:: none
        RXXXXXXX n+ n- value <ac=val> <m=val> <scale=val> <temp=val> <dtemp=val> <noisy=0|1>
    Keyword Parameters:
      :attr:`ac`
      :attr:`multiplier`
         alias `m`
      :attr:`scale`
      :attr:`temperature`
         alias `temp`
      :attr:`device_temperature`
         alias `dtemp`
      :attr:`noisy`
    Attributes:
      :attr:`resistance`
      :attr:`ac`
      :attr:`multiplier`
      :attr:`scale`
      :attr:`temperature`
      :attr:`device_temperature`
      :attr:`noisy`
    """
    ALIAS = 'R'
    PREFIX = 'R'
    resistance = FloatPositionalParameter(position=0, key_parameter=False, unit=U_Ω)
    ac = FloatKeyParameter('ac', unit=U_Ω)
    multiplier = IntKeyParameter('m')
    scale = FloatKeyParameter('scale')
    temperature = FloatKeyParameter('temp', unit=U_Degree)
    device_temperature = FloatKeyParameter('dtemp', unit=U_Degree)
    noisy = BoolKeyParameter('noisy')
####################################################################################################
class SemiconductorResistor(DipoleElement):
    """This class implements a Semiconductor resistor.
    Spice syntax:
    .. code-block:: none
        RXXXXXXX n+ n- <value> <mname> <l=length> <w=width> <temp=val> <dtemp=val> m=<val> <ac=val> <scale=val> <noisy=0|1>
    Keyword Parameters:
      :attr:`model`
      :attr:`length`
         alias `l`
      :attr:`width`
         alias `w`
      :attr:`temperature`
         alias `temp`
      :attr:`device_temperature`
         alias `dtemp`
      :attr:`multiplier`
         alias `m`
      :attr:`ac`
      :attr:`scale`
      :attr:`noisy`
    Attributes:
      :attr:`resistance`
      :attr:`model`
      :attr:`length`
      :attr:`width`
      :attr:`temperature`
      :attr:`device_temperature`
      :attr:`multiplier`
      :attr:`ac`
      :attr:`scale`
      :attr:`noisy`
    """
    ALIAS = 'SemiconductorResistor'
    PREFIX = 'R'
    resistance = FloatPositionalParameter(position=0, key_parameter=False, unit=U_Ω)
    model = ModelPositionalParameter(position=1, key_parameter=True)
    length = FloatKeyParameter('l', unit=U_m)
    width = FloatKeyParameter('w', unit=U_m)
    temperature = FloatKeyParameter('temp', unit=U_Degree)
    device_temperature = FloatKeyParameter('dtemp', unit=U_Degree)
    multiplier = IntKeyParameter('m')
    ac = FloatKeyParameter('ac', unit=U_Ω)
    scale = FloatKeyParameter('scale')
    noisy = BoolKeyParameter('noisy')
####################################################################################################
class BehavioralResistor(DipoleElement):
    # Behavioral / Behavioural
    """This class implements a behavioral resistor.
    Spice syntax:
    .. code-block:: none
        RXXXXXXX n+ n- 'expression' <tc1=value> <tc2=value>
        Rxxxxxxx n+ n- R='expression' <tc1=value> <tc2=value>
    Keyword Parameters:
      :attr:`tc1`
      :attr:`tc2`
    Attributes:
      :attr:`resistance_expression`
      :attr:`tc1`
      :attr:`tc2`
    """
    ALIAS = 'BehavioralResistor'
    PREFIX = 'R'
    resistance_expression = ExpressionPositionalParameter(position=0, key_parameter=False)
    tc1 = FloatKeyParameter('tc1')
    tc2 = FloatKeyParameter('tc2')
####################################################################################################
class Capacitor(DipoleElement):
    """This class implements a capacitor.
    Spice syntax:
    .. code-block:: none
        CXXXXXXX n+ n- <value> <mname> <m=val> <scale=val> <temp=val> <dtemp=val> <ic=init_condition>
    Keyword Parameters:
      :attr:`model`
      :attr:`multiplier`
         alias `m`
      :attr:`scale`
      :attr:`temperature`
         alias `temp`
      :attr:`device_temperature`
         alias `dtemp`
      :attr:`initial_condition`
         alias `ic`
    Attributes:
      :attr:`capacitance`
      :attr:`model`
      :attr:`multiplier`
      :attr:`scale`
      :attr:`temperature`
      :attr:`device_temperature`
      :attr:`initial_condition`
    """
    ALIAS = 'C'
    PREFIX = 'C'
    capacitance = FloatPositionalParameter(position=0, key_parameter=False, unit=U_F)
    model = ModelPositionalParameter(position=1, key_parameter=True)
    multiplier = IntKeyParameter('m')
    scale = FloatKeyParameter('scale')
    temperature = FloatKeyParameter('temp', unit=U_Degree)
    device_temperature = FloatKeyParameter('dtemp', unit=U_Degree)
    initial_condition = FloatKeyParameter('ic')
####################################################################################################
class SemiconductorCapacitor(DipoleElement):
    """This class implements a semiconductor capacitor.
    Spice syntax:
    .. code-block:: none
        CXXXXXXX n+ n- <value> <mname> <l=length> <w=width> <m=val> <scale=val> <temp=val> <dtemp=val> <ic=init_condition>
    Keyword Parameters:
      :attr:`model`
      :attr:`length`
         alias `l`
      :attr:`width`
         alias `w`
      :attr:`multiplier`
         alias `m`
      :attr:`scale`
      :attr:`temperature`
         alias `temp`
      :attr:`device_temperature`
         alias `dtemp`
      :attr:`initial_condition`
         alias `ic`
    Attributes:
      :attr:`capacitance`
      :attr:`model`
      :attr:`length`
      :attr:`width`
      :attr:`multiplier`
      :attr:`scale`
      :attr:`temperature`
      :attr:`device_temperature`
      :attr:`initial_condition`
    """
    ALIAS = 'SemiconductorCapacitor'
    PREFIX = 'C'
    capacitance = FloatPositionalParameter(position=0, key_parameter=False, unit=U_F)
    model = ModelPositionalParameter(position=1, key_parameter=True)
    length = FloatKeyParameter('l', unit=U_m)
    width = FloatKeyParameter('w', unit=U_m)
    multiplier = IntKeyParameter('m')
    scale = FloatKeyParameter('scale')
    temperature = FloatKeyParameter('temp', unit=U_Degree)
    device_temperature = FloatKeyParameter('dtemp', unit=U_Degree)
    initial_condition = FloatKeyParameter('ic')
####################################################################################################
class BehavioralCapacitor(DipoleElement):
    """This class implements a behavioral capacitor.
    Spice syntax:
    .. code-block:: none
        CXXXXXXX n+ n- 'expression' <tc1=value> <tc2=value>
        CXXXXXXX n+ n- C='expression' <tc1=value> <tc2=value>
    Keyword Parameters:
      :attr:`tc1`
      :attr:`tc2`
    Attributes:
      :attr:`capacitance_expression`
      :attr:`tc1`
      :attr:`tc2`
    """
    ALIAS = 'BehavioralCapacitor'
    PREFIX = 'C'
    capacitance_expression = ExpressionPositionalParameter(position=0, key_parameter=False)
    tc1 = FloatKeyParameter('tc1')
    tc2 = FloatKeyParameter('tc2')
####################################################################################################
class Inductor(DipoleElement):
    """This class implements an inductor.
    Spice syntax:
    .. code-block:: none
        LYYYYYYY n+ n- <value> <mname> <nt=val> <m=val> <scale=val> <temp=val> <dtemp=val> <ic=init_condition>
    Keyword Parameters:
      :attr:`nt`
      :attr:`multiplier`
         alias `m`
      :attr:`scale`
      :attr:`temperature`
         alias `temp`
      :attr:`device_temperature`
         alias `dtemp`
      :attr:`initial_condition`
         alias `ic`
    Attributes:
      :attr:`inductance`
      :attr:`model`
      :attr:`nt`
      :attr:`multiplier`
      :attr:`scale`
      :attr:`temperature`
      :attr:`device_temperature`
      :attr:`initial_condition`
    """
    ALIAS = 'L'
    PREFIX = 'L'
    inductance = FloatPositionalParameter(position=0, key_parameter=False, unit=U_H)
    model = ModelPositionalParameter(position=1, key_parameter=True)
    nt = FloatKeyParameter('nt')
    multiplier = IntKeyParameter('m')
    scale = FloatKeyParameter('scale')
    temperature = FloatKeyParameter('temp', unit=U_Degree)
    device_temperature = FloatKeyParameter('dtemp', unit=U_Degree)
    initial_condition = FloatKeyParameter('ic')
####################################################################################################
class BehavioralInductor(DipoleElement):
    """This class implements a behavioral inductor.
    Spice syntax:
    .. code-block:: none
        LXXXXXXX n+ n- 'expression' <tc1=value> <tc2=value>
        LXXXXXXX n+ n- L='expression' <tc1=value> <tc2=value>
    Keyword Parameters:
      :attr:`tc1`
      :attr:`tc2`
    Attributes:
      :attr:`inductance_expression`
      :attr:`tc1`
      :attr:`tc2`
    """
    ALIAS = 'BehavioralInductor'
    PREFIX = 'L'
    inductance_expression = ExpressionPositionalParameter(position=0, key_parameter=False)
    tc1 = FloatKeyParameter('tc1')
    tc2 = FloatKeyParameter('tc2')
####################################################################################################
class CoupledInductor(AnyPinElement):
    """This class implementss a coupled (mutual) inductors.
    Spice syntax:
    .. code-block:: none
        KXXXXXXX LYYYYYYY LZZZZZZZ value
    Keyword Parameters:
    Attributes:
      :attr:`inductor1`
      :attr:`inductor2`
      :attr:`coupling_factor`
    """
    ALIAS = 'K'
    PREFIX = 'K'
    inductor1 = ElementNamePositionalParameter(position=0, key_parameter=False)
    inductor2 = ElementNamePositionalParameter(position=1, key_parameter=False)
    coupling_factor = FloatPositionalParameter(position=2, key_parameter=False)
    _logger = _module_logger.getChild('CoupledInductor')
 ##############################################
    def __init__(self, name, *args, **kwargs):
        super().__init__(name, *args, **kwargs)
        self._inductors = []
        for inductor in (self.inductor1, self.inductor2):
            try:
                self.netlist.element(inductor)
            except KeyError:
                try:
                    inductor = 'L' + inductor
                    self.netlist.element(inductor)
                    self._logger.info('Prefixed element {}'.format(inductor))
                except KeyError:
                    raise ValueError('Element with name {} not found'.format(inductor))
            # Fixme: str or Element instance ?
            self._inductors.append(inductor)
        self.inductor1, self.inductor2 = self._inductors
####################################################################################################
class VoltageControlledSwitch(TwoPortElement):
    """This class implements a voltage controlled switch.
    Spice syntax:
    .. code-block:: none
        SXXXXXXX n+ n- nc+ nc- model <on> <off>
    Keyword Parameters:
      :attr:`model`
      :attr:`initial_state`
    Attributes:
      :attr:`model`
      :attr:`initial_state`
    """
    ALIAS = 'S'
    LONG_ALIAS = 'VCS'
    PREFIX = 'S'
    model = ModelPositionalParameter(position=0, key_parameter=True)
    initial_state = InitialStatePositionalParameter(position=1, key_parameter=True)
####################################################################################################
class CurrentControlledSwitch(DipoleElement):
    """This class implements a current controlled switch.
    Spice syntax:
    .. code-block:: none
        WYYYYYYY n+ n- vname model <on> <off>
    Keyword Parameters:
      :attr:`source`
      :attr:`model`
      :attr:`initial_state`
    Attributes:
      :attr:`source`
      :attr:`model`
      :attr:`initial_state`
    """
    ALIAS = 'W'
    LONG_ALIAS = 'CCS'
    PREFIX = 'W'
    source = ElementNamePositionalParameter(position=0, key_parameter=True)
    model = ModelPositionalParameter(position=1, key_parameter=True)
    initial_state = InitialStatePositionalParameter(position=2, key_parameter=True)
####################################################################################################
#
# Voltage and Current Sources
#
####################################################################################################
class VoltageSource(DipoleElement):
    """This class implements an independent sources for voltage.
    Spice syntax:
    .. code-block:: none
        VXXXXXXX n+ n- <<dc> dc/tran value> <ac <acmag <acphase>>> <distof1 <f1mag <f1phase>>> <distof2 <f2mag <f2phase>>>
    Keyword Parameters:
    Attributes:
      :attr:`dc_value`
    """
    ALIAS = 'V'
    PREFIX = 'V'
    # Fixme: ngspice manual doesn't describe well the syntax
    dc_value = FloatPositionalParameter(position=0, key_parameter=False, unit=U_V)
####################################################################################################
class CurrentSource(DipoleElement):
    """This class implements an independent sources for current.
    Spice syntax:
    .. code-block:: none
       IYYYYYYY n+ n- <<dc> dc/tran value> <ac <acmag <acphase>>> <distof1 <f1mag <f1phase>>> <distof2 <f2mag <f2phase>>>
    Keyword Parameters:
    Attributes:
      :attr:`dc_value`
    """
    ALIAS = 'I'
    PREFIX = 'I'
    # Fixme: ngspice manual doesn't describe well the syntax
    dc_value = FloatPositionalParameter(position=0, key_parameter=False, unit=U_A)
####################################################################################################
class VoltageControlledCurrentSource(TwoPortElement):
    """This class implements a linear voltage-controlled current sources (VCCS).
    Spice syntax:
    .. code-block:: none
        Gxxx n+ n- nc+ nc- value <m=val>
    Keyword Parameters:
      :attr:`multiplier`
         alias `m`
    Attributes:
      :attr:`transconductance`
    """
    ALIAS = 'VCCS'
    PREFIX = 'G'
    transconductance = ExpressionPositionalParameter(position=0, key_parameter=False)
    multiplier = IntKeyParameter('m')
####################################################################################################
class VoltageControlledVoltageSource(TwoPortElement):
    """This class implements a linear voltage-controlled voltage sources (VCVS).
    Spice syntax:
    .. code-block:: none
        EXXXXXXX n+ n- nc+ nc- value
    Keyword Parameters:
    Attributes:
      :attr:`voltage_gain`
    """
    ALIAS = 'VCVS'
    PREFIX = 'E'
    voltage_gain = ExpressionPositionalParameter(position=0, key_parameter=False)
####################################################################################################
class CurrentControlledCurrentSource(DipoleElement):
    """This class implements a linear current-controlled current sources (CCCS).
    Spice syntax:
    .. code-block:: none
       FXXXXXXX n+ n- vname value <m=val>
    Keyword Parameters:
      :attr:`multiplier`
         alias `m`
    Attributes:
      :attr:`source`
      :attr:`current_gain`
    """
    ALIAS = 'F'
    LONG_ALIAS = 'CCCS'
    PREFIX = 'F'
    source = ElementNamePositionalParameter(position=0, key_parameter=False)
    current_gain = ExpressionPositionalParameter(position=1, key_parameter=False)
    multiplier = IntKeyParameter('m')
####################################################################################################
class CurrentControlledVoltageSource(DipoleElement):
    """This class implements a linear current-controlled voltage sources (CCVS).
    Spice syntax:
    .. code-block:: none
        HXXXXXXX n+ n- vname value
    Keyword Parameters:
    Attributes:
      :attr:`source`
      :attr:`transresistance`
    """
    ALIAS = 'H'
    LONG_ALIAS = 'CCVS'
    PREFIX = 'H'
    source = ElementNamePositionalParameter(position=0, key_parameter=False)
    transresistance = ExpressionPositionalParameter(position=1, key_parameter=False)
####################################################################################################
#
# Non-Linear Dependent Sources (Behavioral Sources)
#
####################################################################################################
class BehavioralSource(DipoleElement):
    """This class implements a behavioral source.
    Spice syntax:
    .. code-block:: none
        BXXXXXXX n+ n- <i=expr> <v=expr> <tc1=value> <tc2=value> <temp=value> <dtemp=value>
    Keyword Parameters:
      :attr:`current_expression`
          alias `i`
      :attr:`voltage_expression`
          alias `v`
      :attr:`tc1`
      :attr:`tc2`
      :attr:`temperature`
         alias `temp`
      :attr:`device_temperature`
         alias `dtemp`
    Attributes:
      :attr:`current_expression`
      :attr:`voltage_expression`
      :attr:`tc1`
      :attr:`tc2`
      :attr:`temperature`
      :attr:`device_temperature`
    """
    ALIAS = 'B'
    PREFIX = 'B'
    current_expression = ExpressionKeyParameter('i')
    voltage_expression = ExpressionKeyParameter('v')
    tc1 = FloatKeyParameter('tc1')
    tc2 = FloatKeyParameter('tc2')
    temperature = FloatKeyParameter('temp', unit=U_Degree)
    device_temperature = FloatKeyParameter('dtemp', unit=U_Degree)
####################################################################################################
class NonLinearVoltageSource(DipoleElement):
    """This class implements a non-linear voltage source.
    .. warning:: Partially implemented
    Spice syntax:
    .. code-block:: none
        Exxx n+ n- vol='expr'
        Exxx n+ n- value={expr}
        Exxx n1 n2 TABLE {expression}=(x0,y0) (x1,y1) (x2,y2)
        Exxx n+ n- ( POLY (nd) ) nc1+ nc1- ( nc2+ nc2- ... ) p0 ( p1 ... )
        Laplace
    Keyword Parameters:
    Attributes:
    """
    ALIAS = 'NonLinearVoltageSource'
    PREFIX = 'E'
    # Fixme:
    VALID_KWARGS = ('expression', 'table')
    ##############################################
    def __init__(self, name, *args, **kwargs):
        super().__init__(name, *args, **kwargs)
        self.expression = kwargs.get('expression', None)
        self.table = kwargs.get('table', None)
    ##############################################
    def __str__(self):
        spice_element = self.format_node_names()
        # Fixme: expression
        if self.table is not None:
            # TABLE {expression} = (x0, y0) (x1, y1) ...
            table = ['({}, {})'.format(str_spice(x), str_spice(y)) for x, y in self.table]
            spice_element += ' TABLE {%s} = %s' % (self.expression, join_list(table))
        return spice_element
####################################################################################################
class NonLinearCurrentSource(DipoleElement):
    """This class implements a non-linear current sources.
    .. warning:: Partially implemented
    Spice syntax:
    .. code-block:: none
        Gxxx n+ n- value={expr}
        Gxxx n1 n2 TABLE {expression}=(x0,y0) (x1,y1) (x2,y2)
        Gxxx n+ n- ( POLY (nd) ) nc1+ nc1- ( nc2+ nc2- ... ) p0 ( p1 ... )
        Laplace
    Keyword Parameters:
    Attributes:
      :attr:`transconductance`
    """
    ALIAS = 'NonLinearCurrentSource'
    PREFIX = 'G'
    transconductance = ExpressionPositionalParameter(position=0, key_parameter=False)
####################################################################################################
#
# Diode
#
####################################################################################################
class Diode(FixedPinElement):
    """This class implements a junction diode.
    Spice syntax:
    .. code-block:: none
        DXXXXXXX n+ n- mname <area=val> <m=val> <pj=val> <off> <ic=vd> <temp=val> <dtemp=val>
    Keyword Parameters:
      :attr:`model`
      :attr:`area`
      :attr:`multiplier`
         alias `m`
      :attr:`pj`
      :attr:`off`
      :attr:`ic`
      :attr:`temperature`
         alias `temp`
      :attr:`device_temperature`
         alias `dtemp`
    Attributes:
      :attr:`model`
      :attr:`area`
      :attr:`multiplier`
      :attr:`pj`
      :attr:`off`
      :attr:`ic`
      :attr:`temperature`
      :attr:`device_temperature`
    """
    ALIAS = 'D'
    PREFIX = 'D'
    PINS = (('cathode', 'plus'), ('anode', 'minus'))
    model = ModelPositionalParameter(position=0, key_parameter=True)
    area = FloatKeyParameter('area')
    multiplier = IntKeyParameter('m')
    pj = FloatKeyParameter('pj')
    off = FlagParameter('off')
    ic = FloatPairKeyParameter('ic')
    temperature = FloatKeyParameter('temp', unit=U_Degree)
    device_temperature = FloatKeyParameter('dtemp', unit=U_Degree)
####################################################################################################
#
# BJTs
#
####################################################################################################
class BipolarJunctionTransistor(FixedPinElement):
    """This class implements a bipolar junction transistor.
    Spice syntax:
    .. code-block:: none
         QXXXXXXX nc nb ne <ns> mname <area=val> <areac=val> <areab=val> <m=val> <off> <ic=vbe,vce> <temp=val> <dtemp=val>
    Keyword Parameters:
      :attr:`model`
      :attr:`area`
      :attr:`areac`
      :attr:`areab`
      :attr:`multiplier`
         alias `m`
      :attr:`off`
      :attr:`ic`
      :attr:`temperature`
         alias `temp`
      :attr:`device_temperature`
         alias `dtemp`
    Attributes:
      :attr:`model`
      :attr:`area`
      :attr:`areac`
      :attr:`areab`
      :attr:`multiplier`
      :attr:`off`
      :attr:`ic`
      :attr:`temperature`
      :attr:`device_temperature`
    """
    # Fixme: off doesn't fit in kwargs !
    ALIAS = 'Q'
    LONG_ALIAS = 'BJT'
    PREFIX = 'Q'
    PINS = ('collector', 'base', 'emitter', OptionalPin('substrate'))
    model = ModelPositionalParameter(position=0, key_parameter=True)
    area = FloatKeyParameter('area')
    areac = FloatKeyParameter('areac')
    areab = FloatKeyParameter('areab')
    multiplier = IntKeyParameter('m')
    off = FlagParameter('off')
    ic = FloatPairKeyParameter('ic')
    temperature = FloatKeyParameter('temp', unit=U_Degree)
    device_temperature = FloatKeyParameter('dtemp', unit=U_Degree)
####################################################################################################
#
# JFETs
#
####################################################################################################
class JfetElement(FixedPinElement):
    PINS = ('drain', 'gate', 'source')
class JunctionFieldEffectTransistor(JfetElement):
    """This class implements a bipolar junction transistor.
    Spice syntax:
    .. code-block:: none
         JXXXXXXX nd ng ns mname <area> <off> <ic=vds,vgs> <temp=t>
    Keyword Parameters:
      :attr:`model`
      :attr:`area`
      :attr:`off`
      :attr:`ic`
      :attr:`temperature`
         alias `temp`
    Attributes:
      :attr:`model`
      :attr:`area`
      :attr:`off`
      :attr:`ic`
      :attr:`temperature`
    """
    # Fixme: off doesn't fit in kwargs !
    ALIAS = 'J'
    LONG_ALIAS = 'JFET'
    PREFIX = 'J'
    model = ModelPositionalParameter(position=0, key_parameter=True)
    area = FloatKeyParameter('area')
    multiplier = IntKeyParameter('m')
    off = FlagParameter('off')
    ic = FloatPairKeyParameter('ic')
    temperature = FloatKeyParameter('temp', unit=U_Degree)
####################################################################################################
#
# MESFETs
#
####################################################################################################
class Mesfet(JfetElement):
    """This class implements a Metal Semiconductor Field Effect Transistor.
    Spice syntax:
    .. code-block:: none
         ZXXXXXXX nd ng ns mname <area> <off> <ic=vds,vgs>
    Keyword Parameters:
      :attr:`model`
      :attr:`area`
      :attr:`off`
      :attr:`ic`
    Attributes:
      :attr:`model`
      :attr:`area`
      :attr:`off`
      :attr:`ic`
    """
    # Fixme: off doesn't fit in kwargs !
    ALIAS = 'Z'
    LONG_ALIAS = 'MESFET'
    PREFIX = 'Z'
    model = ModelPositionalParameter(position=0, key_parameter=True)
    area = FloatKeyParameter('area')
    multiplier = IntKeyParameter('m')
    off = FlagParameter('off')
    ic = FloatPairKeyParameter('ic')
####################################################################################################
#
# MOSFETs
#
####################################################################################################
class Mosfet(FixedPinElement):
    """This class implements a Metal Oxide Field Effect Transistor.
    Spice syntax:
    .. code-block:: none
         MXXXXXXX nd ng ns nb mname <m=val> <l=val> <w=val>
         + <ad=val> <as=val> <pd=val> <ps=val> <nrd=val>
         + <nrs=val> <off> <ic=vds,vgs,vbs> <temp=t>
    Keyword Parameters:
      :attr:`model`
      :attr:`multiplier`
         alias `m`
      :attr:`length`
         alias `l`
      :attr:`width`
         alias `w`
      :attr:`nfin`
        only for Xyce
      :attr:`drain_area`
          alias `ad`
      :attr:`source_area`
          alias `as`
      :attr:`drain_perimeter`
          alias `pd`
      :attr:`source_perimeter`
          alias `ps`
      :attr:`drain_number_square`
          alias `nrd`
      :attr:`source_number_square`
          alias `nrs`
      :attr:`off`
      :attr:`ic`
      :attr:`temperature`
         alias `temp`
    Attributes:
      :attr:`model`
      :attr:`multiplier`
      :attr:`length`
      :attr:`width`
      :attr:`nfin`
        only for Xyce
      :attr:`drain_area`
      :attr:`source_area`
      :attr:`drain_perimeter`
      :attr:`source_perimeter`
      :attr:`drain_number_square`
      :attr:`source_number_square`
      :attr:`off`
      :attr:`ic`
      :attr:`temperature`
    """
    # Fixme: off doesn't fit in kwargs !
    ALIAS = 'M'
    LONG_ALIAS = 'MOSFET'
    PREFIX = 'M'
    PINS = ('drain', 'gate', 'source', ('bulk', 'substrate'))
    model = ModelPositionalParameter(position=0, key_parameter=True)
    multiplier = IntKeyParameter('m')
    length = FloatKeyParameter('l', unit=U_m)
    width = FloatKeyParameter('w', unit=U_m)
    drain_area = FloatKeyParameter('ad')
    source_area = FloatKeyParameter('as')
    drain_perimeter = FloatKeyParameter('pd')
    source_perimeter = FloatKeyParameter('ps')
    drain_number_square = FloatKeyParameter('nrd')
    source_number_square = FloatKeyParameter('nrs')
    off = FlagParameter('off')
    ic = FloatTripletKeyParameter('ic')
    temperature = FloatKeyParameter('temp', unit=U_Degree)
    # only for Xyce
    nfin = IntKeyParameter('nfin')
####################################################################################################
#
# Transmission Lines
#
####################################################################################################
class LosslessTransmissionLine(TwoPortElement):
    """This class implements a lossless transmission line.
    Spice syntax:
    .. code-block:: none
        TXXXXXXX N1 N2 N3 N4 Z0=VALUE <TD=VALUE> <F=FREQ <NL=NRMLEN>> <IC=V1, I1, V2, I2>
    where TD or F, NL must be specified.
    Keyword Parameters:
      :attr:`impedance`
         alias:`Z0`
         is the characteristic impedance
      :attr:`time_delay`
         alias:`TD`
         is the transmission delay
      :attr:`frequency`
         alias:`F`
      :attr:`normalized_length`
         alias:`NL`
    Attributes:
      :attr:`impedance`
      :attr:`time_delay`
      :attr:`frequency`
      :attr:`normalized_length`
    The transmission delay, `td`, may be specified directly (as `td=10ns`, for example).
    Alternatively, a frequency `f` may be given, together with `nl`, the normalized electrical
    length of the transmission line with respect to the wavelength in the line at the frequency
    `f`. If a frequency is specified but `nl` is omitted, 0.25 is assumed (that is, the frequency is
    assumed to be the quarter-wave frequency). Note that although both forms for expressing the line
    length are indicated as optional, one of the two must be specified.
    Note: Either time_delay or frequency must be given.
    """
    ALIAS = 'TransmissionLine'
    PREFIX = 'T'
    impedance = FloatKeyParameter('Z0', default=50, unit=U_Ω)
    time_delay = FloatKeyParameter('TD', unit=U_s)
    frequency = FloatKeyParameter('F', unit=U_Hz)
    normalized_length = FloatKeyParameter('NL')
    ##############################################
    def __init__(self, name, *args, **kwargs):
        super().__init__(name, *args, **kwargs)
        if not (self.has_parameter('time_delay') or
                (self.has_parameter('frequency') and self.has_parameter('normalized_length'))):
            raise NameError('Either TD or F, NL must be specified')
####################################################################################################
class LossyTransmission(TwoPortElement):
    """This class implements lossy transmission lines.
    Spice syntax:
    .. code-block:: none
        OXXXXXXX n1 n2 n3 n4 model
    Attributes:
      :attr:`model`
    .. note:: As opposite to Spice, the model is specified before the nodes so as to act as `*args`.
    """
    ALIAS = 'O'
    PREFIX = 'O'
    model = ModelPositionalParameter(position=0, key_parameter=True)
####################################################################################################
class CoupledMulticonductorLine(NPinElement):
    """This class implements coupled multiconductor lines.
    Spice syntax:
    .. code-block:: none
        PXXXXXXX NI1 NI2 ... NIX GND1 NO1 NO2 ... NOX GND2 model <len=length>
    Attributes:
      :attr:`model`
      :attr:`length`
         alias `len`
         length of the line in meters
    .. note:: As opposite to Spice, the model is specified before the nodes so as to act as `*args`.
    """
    ALIAS = 'P'
    PREFIX = 'P'
    model = ModelPositionalParameter(position=0, key_parameter=True)
    length = FloatKeyParameter('len', unit=U_m)
    ##############################################
    def __init__(self, netlist, name, *nodes, **parameters):
        super().__init__(netlist, name, nodes, **parameters)
####################################################################################################
class UniformDistributedRCLine(FixedPinElement):
    """This class implements uniform distributed RC lines.
    Spice syntax:
    .. code-block:: none
        UXXXXXXX n1 n2 n3 model l=length <n=number_of_lumps>
    Attributes:
      :attr:`model`
      :attr:`length`
         alias `l`
         length of the RC line in meters
      :attr:`number_of_lumps`
         alias `n`
    .. note:: As opposite to Spice, the model is specified before the nodes so as to act as `*args`.
    """
    ALIAS = 'U'
    PREFIX = 'U'
    PINS = ('output', 'input', 'capacitance_node')
    model = ModelPositionalParameter(position=0, key_parameter=True)
    length = FloatKeyParameter('l', unit=U_m)
    number_of_lumps = IntKeyParameter('n')
####################################################################################################
class SingleLossyTransmissionLine(TwoPortElement):
    # Fixme: special TwoPortElement
    """This class implements single lossy transmission lines.
    Spice syntax:
    .. code-block:: none
        YXXXXXXX N1 0 N2 0 model <len=length>
    Attributes:
      :attr:`model`
      :attr:`length`
         alias `len`
         length of the line in meters
    .. note:: As opposite to Spice, the model is specified before the nodes so as to act as `*args`.
    """
    ALIAS = 'Y'
    PREFIX = 'Y'
    model = ModelPositionalParameter(position=0, key_parameter=True)
    length = FloatKeyParameter('len', unit=U_m)
####################################################################################################
#
# XSPICE
#
####################################################################################################
class XSpiceElement(NPinElement):
    """This class implements a sub-circuit.
    Spice syntax:
    .. code-block:: none
        AXXXXXXX <%v ,%i ,%vd ,%id ,%g,%gd ,%h,%hd , or %d>
        + <[> <~><%v ,%i ,%vd ,%id ,%g,%gd ,%h,%hd , or %d>
        + <NIN1 or +NIN1 -NIN1 or "null">
        + <~>...< NIN2 .. <]> >
        + <%v ,%i ,%vd ,%id ,%g,%gd ,%h,%hd ,%d or %vnam >
        + <[> <~><%v ,%i ,%vd ,%id ,%g,%gd ,%h,%hd ,
        or %d>< NOUT1 or +NOUT1 -NOUT1 >
        + <~>...< NOUT2 .. <]>>
        + MODELNAME
        . MODEL MODELNAME MODELTYPE
        + <( PARAMNAME1 = <[> VAL1 <VAL2 ... <]>> PARAMNAME2 ..>)>
    Attributes:
      :attr:`model`
    .. note:: As opposite to Spice, the model is specified before the nodes so as to act as `*args`.
    .. warning:: Partially implemented.
    """
    ALIAS = 'A'
    PREFIX = 'A'
    model = ModelPositionalParameter(position=0, key_parameter=True)
    ##############################################
    def __init__(self, netlist, name, *nodes, **parameters):
        # Fixme: ok ???
        super().__init__(netlist, name, nodes, **parameters)
####################################################################################################
#
# GSS
#
####################################################################################################
class GSSElement(NPinElement):
    """This class implements GSS device.
    .. warning:: Not implemented
    """
    ALIAS = 'N'
    PREFIX = 'N'
    ##############################################
    def __init__(self):
        raise NotImplementedError
</file>

<file path="PySpice/Spice/ElementParameter.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This modules implements the machinery to define element's parameters as descriptors.
"""
####################################################################################################
from ..Unit import Unit
from ..Tools.StringTools import str_spice
####################################################################################################
class ParameterDescriptor:
    """This base class implements a descriptor for element parameters.
    Public Attributes:
      :attr:`attribute_name`
        Name of the attribute in the element's class
      :attr:`default_value`
        The default value
    """
    ##############################################
    def __init__(self, default=None):
        self._default_value = default
        self._attribute_name = None
    ##############################################
    @property
    def default_value(self):
        return self._default_value
    @property
    def attribute_name(self):
        return self._attribute_name
    @attribute_name.setter
    def attribute_name(self, name):
        self._attribute_name = name
    ##############################################
    def __get__(self, instance, owner=None):
        try:
            return getattr(instance, '_' + self._attribute_name)
        except AttributeError:
            return self.default_value
    ##############################################
    def __set__(self, instance, value):
        setattr(instance, '_' + self._attribute_name, value)
    ##############################################
    def __repr__(self):
        return self.__class__.__name__
    ##############################################
    def validate(self, value):
        """Validate the parameter's value."""
        return value
    ##############################################
    def nonzero(self, instance):
        return self.__get__(instance) is not None
    ##############################################
    def to_str(self, instance):
        """Convert the parameter's value to SPICE syntax."""
        raise NotImplementedError
    ##############################################
    def __lt__(self, other):
        return self._attribute_name < other.attribute_name
####################################################################################################
class PositionalElementParameter(ParameterDescriptor):
    """This class implements a descriptor for positional element parameters.
    Public Attributes:
      :attr:`key_parameter`
        Flag to specify if the parameter is passed as key parameter in Python
      :attr:`position`
        Position of the parameter in the element definition
    """
    ##############################################
    def __init__(self, position, default=None, key_parameter=False):
        super().__init__(default)
        self._position = position
        self._key_parameter = key_parameter
    ##############################################
    @property
    def position(self):
        return self._position
    @property
    def key_parameter(self):
        return self._key_parameter
    ##############################################
    def to_str(self, instance):
        return str_spice(self.__get__(instance))
    ##############################################
    def __lt__(self, other):
        return self._position < other.position
####################################################################################################
class ElementNamePositionalParameter(PositionalElementParameter):
    """This class implements an element name positional parameter."""
    ##############################################
    def validate(self, value):
        return str(value)
####################################################################################################
class ExpressionPositionalParameter(PositionalElementParameter):
    """This class implements an expression positional parameter. """
    ##############################################
    def validate(self, value):
        return str(value)
####################################################################################################
class FloatPositionalParameter(PositionalElementParameter):
    """This class implements a float positional parameter."""
    ##############################################
    def __init__(self, position, unit=None, **kwargs):
        super().__init__(position, **kwargs)
        self._unit = unit
    ##############################################
    def validate(self, value):
        if isinstance(value, Unit):
            return value
        else:
            return Unit(value)
####################################################################################################
class InitialStatePositionalParameter(PositionalElementParameter):
    """This class implements an initial state (on, off) positional parameter."""
    ##############################################
    def validate(self, value):
        return bool(value) # Fixme: check KeyParameter
    ##############################################
    def to_str(self, instance):
        if self.__get__(instance):
            return 'on'
        else:
            return 'off'
####################################################################################################
class ModelPositionalParameter(PositionalElementParameter):
    """This class implements a model positional parameter. """
    ##############################################
    def validate(self, value):
        return str(value)
####################################################################################################
class FlagParameter(ParameterDescriptor):
    """This class implements a flag parameter.
    Public Attributes:
      :attr:`spice_name`
        Name of the parameter
    """
    ##############################################
    def __init__(self, spice_name, default=False):
        super().__init__(default)
        self.spice_name = spice_name
    ##############################################
    def nonzero(self, instance):
        return bool(self.__get__(instance))
    ##############################################
    def to_str(self, instance):
        if self.nonzero(instance):
            return 'off'
        else:
            return ''
####################################################################################################
class KeyValueParameter(ParameterDescriptor):
    """This class implements a key value pair parameter.
    Public Attributes:
      :attr:`spice_name`
        Name of the parameter
    """
    ##############################################
    def __init__(self, spice_name, default=None):
        super().__init__(default)
        self.spice_name = spice_name
    ##############################################
    def str_value(self, instance):
        return str_spice(self.__get__(instance))
    ##############################################
    def to_str(self, instance):
        if bool(self):
            return '{}={}'.format(self.spice_name, self.str_value(instance))
        else:
            return ''
####################################################################################################
class BoolKeyParameter(KeyValueParameter):
    """This class implements a boolean key parameter."""
    ##############################################
    def nonzero(self, instance):
        return bool(self.__get__(instance))
    ##############################################
    def str_value(self, instance):
        if self.nonzero(instance):
            return '1'
        else:
            return '0'
####################################################################################################
class ExpressionKeyParameter(KeyValueParameter):
    """This class implements an expression key parameter."""
    ##############################################
    def validate(self, value):
        return str(value)
####################################################################################################
class FloatKeyParameter(KeyValueParameter):
    """This class implements a float key parameter."""
    ##############################################
    def __init__(self, spice_name, unit=None, **kwargs):
        super().__init__(spice_name, **kwargs)
        self._unit = unit
    ##############################################
    def validate(self, value):
        return float(value)
####################################################################################################
class FloatPairKeyParameter(KeyValueParameter):
    """This class implements a float pair key parameter. """
    ##############################################
    def validate(self, pair):
        if len(pair) == 2:
            return (float(pair[0]), float(pair[1]))
        else:
            raise ValueError()
    ##############################################
    def str_value(self, instance):
        return ','.join([str(value) for value in self.__get__(instance)])
####################################################################################################
class FloatTripletKeyParameter(FloatPairKeyParameter):
    """This class implements a triplet key parameter."""
    ##############################################
    def validate(self, uplet):
        if len(uplet) == 3:
            return (float(uplet[0]), float(uplet[1]), float(uplet[2]))
        else:
            raise ValueError()
####################################################################################################
class IntKeyParameter(KeyValueParameter):
    """This class implements an integer key parameter."""
    ##############################################
    def validate(self, value):
        return int(value)
</file>

<file path="PySpice/Spice/HighLevelElement.py">
# -*- coding: utf-8 -*-
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This module implements high level elements built on top of Spice elements."""
# Fixme: check NgSpice for discrepancies
####################################################################################################
from ..Math import rms_to_amplitude, amplitude_to_rms
from ..Tools.StringTools import join_list, join_dict, str_spice, str_spice_list
from ..Unit import as_s, as_V, as_A, as_Hz
from .BasicElement import VoltageSource, CurrentSource
####################################################################################################
class SourceMixinAbc:
    AS_UNIT = None
####################################################################################################
class VoltageSourceMixinAbc:
    AS_UNIT = as_V
####################################################################################################
class CurrentSourceMixinAbc:
    AS_UNIT = as_A
####################################################################################################
class SinusoidalMixin(SourceMixinAbc):
    r"""This class implements a sinusoidal waveform.
    +------+----------------+---------------+-------+
    | Name + Parameter      + Default Value + Units |
    +------+----------------+---------------+-------+
    | Vo   + offset         +               + V, A  |
    +------+----------------+---------------+-------+
    | Va   + amplitude      +               + V, A  |
    +------+----------------+---------------+-------+
    | f    + frequency      + 1 / TStop     + Hz    |
    +------+----------------+---------------+-------+
    | Td   + delay          + 0.0           + sec   |
    +------+----------------+---------------+-------+
    | Df   + damping factor + 0.01          + 1/sec |
    +------+----------------+---------------+-------+
    The shape of the waveform is described by the following formula:
    .. math::
        V(t) = \begin{cases}
          V_o & \text{if}\ 0 \leq t < T_d, \\
          V_o + V_a e^{-D_f(t-T_d)} \sin\left(2\pi f (t-T_d)\right) & \text{if}\ T_d \leq t < T_{stop}.
        \end{cases}
    Spice syntax::
        SIN ( Voffset Vamplitude Freq Tdelay DampingFactor )
    Public Attributes:
      :attr:`ac_magnitude`
      :attr:`amplitude`
      :attr:`damping_factor`
      :attr:`dc_offset`
      :attr:`delay`
      :attr:`frequency`
      :attr:`offset`
    """
    ##############################################
    def __init__(self,
                 dc_offset=0,
                 ac_magnitude=1,
                 offset=0, amplitude=1, frequency=50,
                 delay=0, damping_factor=0):
        self.dc_offset = self.AS_UNIT(dc_offset)
        self.ac_magnitude = self.AS_UNIT(ac_magnitude)
        self.offset = self.AS_UNIT(offset)
        self.amplitude = self.AS_UNIT(amplitude)
        self.frequency = as_Hz(frequency)   # Fixme: protect by setter?
        self.delay = as_s(delay)
        self.damping_factor = as_Hz(damping_factor)
    ##############################################
    @property
    def rms_voltage(self):
        # Fixme: ok ???
        return amplitude_to_rms(self.amplitude * self.ac_magnitude)
    ##############################################
    @property
    def period(self):
        return self.frequency.period
    ##############################################
    def format_spice_parameters(self):
        sin_part = join_list((self.offset, self.amplitude, self.frequency, self.delay, self.damping_factor))
        return join_list((
            'DC {} AC {}'.format(*str_spice_list(self.dc_offset, self.ac_magnitude)),
            'SIN({})'.format(sin_part),
        ))
####################################################################################################
class PulseMixin(SourceMixinAbc):
    """This class implements a pulse waveform.
    Nomenclature:
    +--------+---------------+---------------+-------+
    | Name   + Parameter     + Default Value + Units |
    +--------+---------------+---------------+-------+
    | V1     + initial value +               + V, A  |
    +--------+---------------+---------------+-------+
    | V2     + pulsed value  +               + V, A  |
    +--------+---------------+---------------+-------+
    | Td     + delay time    + 0.0           + sec   |
    +--------+---------------+---------------+-------+
    | Tr     + rise time     + Tstep         + sec   |
    +--------+---------------+---------------+-------+
    | Tf     + fall time     + Tstep         + sec   |
    +--------+---------------+---------------+-------+
    | Pw     + pulse width   + Tstop         + sec   |
    +--------+---------------+---------------+-------+
    | Period + period        + Tstop         + sec   |
    +--------+---------------+---------------+-------+
    | Phase  + phase         + 0.0           + sec   |
    +--------+---------------+---------------+-------+
    Phase is only possible when XSPICE is enabled
    Spice Syntax::
        PULSE ( V1 V2 Td Tr Tf Pw Period Phase )
    A single pulse so specified is described by the following table:
    +-------------+-------+
    | Time        | Value |
    +-------------+-------+
    | 0           | V1    |
    +-------------+-------+
    | Td          | V1    |
    +-------------+-------+
    | Td+Tr       | V2    |
    +-------------+-------+
    | Td+Tr+Pw    | V2    |
    +-------------+-------+
    | Td+Tr+Pw+Tf | V1    |
    +-------------+-------+
    | Tstop       | V1    |
    +-------------+-------+
    Note: default value in Spice for rise and fall time is the simulation transient step, pulse
    width and period is the simulation stop time.
    Public Attributes:
      :attr:`delay_time`
      :attr:`fall_time`
      :attr:`initial_value`
      :attr:`period`
      :attr:`phase`
      :attr:`pulse_width`
      :attr:`pulsed_value`
      :attr:`rise_time`
    """
    ##############################################
    def __init__(self,
                 initial_value, pulsed_value,
                 pulse_width, period,
                 delay_time=0, rise_time=0, fall_time=0,
                 phase=None,
                 dc_offset=0):
        # Fixme: default
        #  rise_time, fall_time = Tstep
        #  pulse_width, period = Tstop
        self.dc_offset = self.AS_UNIT(dc_offset)   # Fixme: -> SourceMixinAbc
        self.initial_value = self.AS_UNIT(initial_value)
        self.pulsed_value = self.AS_UNIT(pulsed_value)
        self.delay_time = as_s(delay_time)
        self.rise_time = as_s(rise_time)
        self.fall_time = as_s(fall_time)
        self.pulse_width = as_s(pulse_width)
        self.period = as_s(period)   # Fixme: protect by setter?
        # XSPICE
        if phase is not None:
            self.phase = as_s(phase)
        else:
            self.phase = None
        # # Fixme: to func?
        # # Check parameters
        # found_none = False
        # for parameter in ('rise_time', 'fall_time', 'pulse_width', 'period'):
        #     parameter_value = getattr(self, parameter)
        #     if found_none:
        #         if parameter_value is not None:
        #             raise ValueError("Parameter {} is set but some previous parameters was not set".format(parameter))
        #     else:
        #         found_none = parameter_value is None
    ##############################################
    @property
    def frequency(self):
        return self.period.frequency
    ##############################################
    def format_spice_parameters(self):
        # if DC is not provided, ngspice complains
        #   Warning: vpulse: no DC value, transient time 0 value used
        # Fixme: to func?
        return join_list((
            'DC {}'.format(str_spice(self.dc_offset)),
            'PULSE(' +
            join_list((self.initial_value, self.pulsed_value, self.delay_time,
                       self.rise_time, self.fall_time, self.pulse_width, self.period,
                       self.phase)) +
            ')'))
####################################################################################################
class ExponentialMixin(SourceMixinAbc):
    r"""This class implements a Exponential waveform.
    Nomenclature:
    +------+--------------------+---------------+-------+
    | Name + Parameter          + Default Value + Units |
    +------+--------------------+---------------+-------+
    | V1   + Initial value      +               + V, A  |
    +------+--------------------+---------------+-------+
    | V2   + pulsed value       +               + V, A  |
    +------+--------------------+---------------+-------+
    | Td1  + rise delay time    + 0.0           + sec   |
    +------+--------------------+---------------+-------+
    | tau1 + rise time constant + Tstep         + sec   |
    +------+--------------------+---------------+-------+
    | Td2  + fall delay time    + Td1+Tstep     + sec   |
    +------+--------------------+---------------+-------+
    | tau2 + fall time constant + Tstep         + sec   |
    +------+--------------------+---------------+-------+
    Spice Syntax::
        EXP ( V1 V2 TD1 TAU1 TD2 TAU2 )
    The shape of the waveform is described by the following formula:
    Let V21 = V2 - V1 and V12 = V1 - V2.
    .. math::
        V(t) = \begin{cases}
          V_1 & \text{if}\ 0 \leq t < T_{d1}, \\
          V_1 + V_{21} ( 1 − e^{-\frac{t-T_{d1}}{\tau_1}} )
          & \text{if}\ T_{d1} \leq t < T_{d2}, \\
          V_1 + V_{21} ( 1 − e^{-\frac{t-T_{d1}}{\tau_1}} ) + V_{12} ( 1 − e^{-\frac{t-T_{d2}}{\tau_2}} )
          & \text{if}\ T_{d2} \leq t < T_{stop}
        \end{cases}
    """
    ##############################################
    def __init__(self,
                 initial_value, pulsed_value,
                 rise_delay_time=.0, rise_time_constant=None,
                 fall_delay_time=None, fall_time_constant=None):
        # Fixme: default
        self.initial_value = self.AS_UNIT(initial_value)
        self.pulsed_value = self.AS_UNIT(pulsed_value)
        self.rise_delay_time = as_s(rise_delay_time)
        self.rise_time_constant = as_s(rise_time_constant)
        self.fall_delay_time = as_s(fall_delay_time)
        self.fall_time_constant = as_s(fall_time_constant)
    ##############################################
    def format_spice_parameters(self):
        # Fixme: to func?
        return ('EXP(' +
                join_list((self.initial_value, self.pulsed_value,
                           self.rise_delay_time, self.rise_time_constant,
                           self.fall_delay_time, self.fall_time_constant,
                           )) +
                ')')
####################################################################################################
class PieceWiseLinearMixin(SourceMixinAbc):
    r"""This class implements a Piece-Wise Linear waveform.
    Spice Syntax::
        PWL( T1 V1 <T2 V2 T3 V3 T4 V4 ... > ) <r=value> <td=value>
    Each pair of values (Ti , Vi) specifies that the value of the source is Vi (in Volts or Amps) at
    time = Ti . The value of the source at intermediate values of time is determined by using linear
    interpolation on the input values. The parameter r determines a repeat time point. If r is not
    given, the whole sequence of values (Ti , Vi ) is issued once, then the output stays at its
    final value. If r = 0, the whole sequence from time = 0 to time = Tn is repeated forever. If r =
    10ns, the sequence between 10ns and 50ns is repeated forever. the r value has to be one of the
    time points T1 to Tn of the PWL sequence. If td is given, the whole PWL sequence is delayed by a
    delay time time = td. The current source still needs to be patched, td and r are not yet
    available.
    `values` should be given as a list of (`Time`, `Value`)-tuples, e.g.::
        PieceWiseLinearVoltageSource(
            circuit,
            'pwl1', '1', '0',
            values=[(0, 0), (10@u_ms, 0), (11@u_ms, 5@u_V), (20@u_ms, 5@u_V)],
        )
    """
    ##############################################
    def __init__(self, values, repeat_time=None, delay_time=None, dc=None):
        self.values = sum(([as_s(t), self.AS_UNIT(x)] for (t, x) in values), [])
        self.repeat_time = as_s(repeat_time, none=True)
        self.delay_time = as_s(delay_time, none=True)
        self.dc = self.AS_UNIT(dc, none=True)
    ##############################################
    def format_spice_parameters(self):
        # Fixme: to func?
        d = {}
        if self.repeat_time is not None:
            d["r"] = self.repeat_time
        if self.delay_time is not None:
            d["td"] = self.delay_time
        _ = ""
        if self.dc is not None:
            _ += "DC {} ".format(str_spice(self.dc))
        _ += "PWL(" + join_list(self.values)
        if d:
            _ += " " + join_dict(d)   # OrderedDict(
        _ += ")"
        return _
####################################################################################################
class SingleFrequencyFMMixin(SourceMixinAbc):
    r"""This class implements a Single-Frequency FM waveform.
    Spice Syntax::
        SFFM (VO VA FC MDI FS )
   +------+-------------------+---------------+-------+
   | Name + Parameter         + Default Value + Units |
   +------+-------------------+---------------+-------+
   | Vo   + offset            +               + V, A  |
   +------+-------------------+---------------+-------+
   | Va   + amplitude         +               + V, A  |
   +------+-------------------+---------------+-------+
   | Fc   + carrier frequency + 1 / Tstop     + Hz    |
   +------+-------------------+---------------+-------+
   | Mdi  + modulation index  +               +       |
   +------+-------------------+---------------+-------+
   | Fs   + signal frequency  + 1 / Tstop     + Hz    |
   +------+-------------------+---------------+-------+
    The shape of the waveform is described by the following equation:
    .. math::
        V(t) = V_o + V_a \sin (2\pi F_c\, t + M_{di} \sin (2\pi F_s\,t))
    """
    ##############################################
    def __init__(self, offset, amplitude, carrier_frequency, modulation_index, signal_frequency):
        self.offset = self.AS_UNIT(offset)
        self.amplitude = self.AS_UNIT(amplitude)
        self.carrier_frequency = as_Hz(carrier_frequency)
        self.modulation_index = modulation_index
        self.signal_frequency = as_Hz(signal_frequency)
    ##############################################
    def format_spice_parameters(self):
        # Fixme: to func?
        return ('SFFM(' +
                join_list((self.offset, self.amplitude, self.carrier_frequency,
                           self.modulation_index, self.signal_frequency)) +
                ')')
####################################################################################################
class AmplitudeModulatedMixin(SourceMixinAbc):
    r"""This class implements a Amplitude Modulated source.
    +------+----------------------+---------------+-------+
    | Name + Parameter            + Default Value + Units |
    +------+----------------------+---------------+-------+
    | Vo   + offset               +               + V, A  |
    +------+----------------------+---------------+-------+
    | Va   + amplitude            +               + V, A  |
    +------+----------------------+---------------+-------+
    | Mf   + modulating frequency +               + Hz    |
    +------+----------------------+---------------+-------+
    | Fc   + carrier frequency    + 1 / Tstop     + Hz    |
    +------+----------------------+---------------+-------+
    | Td   + signal delay         +               + s     |
    +------+----------------------+---------------+-------+
    Spice Syntax::
        AM(VA VO MF FC TD)
    The shape of the waveform is described by the following equation:
    .. math::
        V(t) = V_a (V_o + \sin (2\pi M_f\,t)) \sin (2\pi F_c\,t)
    """
    ##############################################
    def __init__(self, offset, amplitude, modulating_frequency, carrier_frequency, signal_delay):
        # Fixme: default
        self.offset = self.AS_UNIT(offset)
        self.amplitude = self.AS_UNIT(amplitude)
        self.carrier_frequency = as_Hz(carrier_frequency)
        self.modulating_frequency = as_Hz(modulating_frequency)
        self.signal_delay = as_s(signal_delay)
    ##############################################
    def format_spice_parameters(self):
        # Fixme: to func?
        return ('AM(' +
                join_list((self.offset, self.amplitude, self.carrier_frequency,
                           self.modulating_frequency, self.signal_delay)) +
                ')')
####################################################################################################
class RandomMixin(SourceMixinAbc):
    r"""This class implements a Random Voltage source.
    The TRRANDOM option yields statistically distributed voltage values, derived from the ngspice
    random number generator. These values may be used in the transient simulation directly within a
    circuit, e.g. for generating a specific noise voltage, but especially they may be used in the
    control of behavioral sources (B, E, G sources, voltage controllable A sources, capacitors,
    inductors, or resistors) to simulate the circuit dependence on statistically varying device
    parameters. A Monte-Carlo simulation may thus be handled in a single simulation run.
    Spice Syntax::
        TRRANDOM( TYPE TS <TD <PARAM1 <PARAM2> > >)
    TYPE determines the random variates generated: 1 is uniformly distributed, 2 Gaussian, 3
    exponential, 4 Poisson. TS is the duration of an individual voltage value. TD is a time delay
    with 0 V output before the random voltage values start up. PARAM1 and PARAM2 depend on the type
    selected.
    +-------------+---------------+---------+-------------+---------+
    | Type        + Parameter 1   + Default + Parameter 2 + Default |
    +-------------+---------------+---------+-------------+---------+
    | uniform     + range         + 1       + offset      + 0       |
    +-------------+---------------+---------+-------------+---------+
    | gaussian    + standard dev. + 1       + mean        + 0       |
    +-------------+---------------+---------+-------------+---------+
    | exponential + mean          + 1       + offset      + 0       |
    +-------------+---------------+---------+-------------+---------+
    | poisson     + lambda        + 1       + offset      + 0       |
    +-------------+---------------+---------+-------------+---------+
    """
    ##############################################
    def __init__(self, random_type, duration=0, time_delay=0, parameter1=1, parameter2=0):
        # Fixme: random_type and parameters
        self.random_type = random_type
        self.duration = as_s(duration)
        self.time_delay = as_s(time_delay)
        self.parameter1 = parameter1
        self.parameter2 = parameter2
    ##############################################
    def format_spice_parameters(self):
        if self.random_type == 'uniform':
            random_type = 1
        elif self.random_type == 'exponential':
            random_type = 2
        elif self.random_type == 'gaussian':
            random_type = 3
        elif self.random_type == 'poisson':
            random_type = 4
        else:
            raise ValueError("Wrong random type {}".format(self.random_type))
        # Fixme: to func?
        return ('TRRANDOM(' +
                join_list((random_type, self.duration, self.time_delay,
                           self.parameter1, self.parameter2)) +
                ')')
####################################################################################################
class SinusoidalVoltageSource(VoltageSource, VoltageSourceMixinAbc, SinusoidalMixin):
    r"""This class implements a sinusoidal waveform voltage source.
    See :class:`SinusoidalMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        VoltageSource.__init__(self, netlist, name, node_plus, node_minus)
        SinusoidalMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = SinusoidalMixin.format_spice_parameters
####################################################################################################
class SinusoidalCurrentSource(CurrentSource, CurrentSourceMixinAbc, SinusoidalMixin):
    r"""This class implements a sinusoidal waveform current source.
    See :class:`SinusoidalMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        CurrentSource.__init__(self, netlist, name, node_plus, node_minus)
        SinusoidalMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = SinusoidalMixin.format_spice_parameters
####################################################################################################
class AcLine(SinusoidalVoltageSource):
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, rms_voltage=230, frequency=50):
        super().__init__(netlist, name, node_plus, node_minus,
                         amplitude=rms_to_amplitude(rms_voltage),
                         frequency=frequency)
####################################################################################################
class PulseVoltageSource(VoltageSource, VoltageSourceMixinAbc, PulseMixin):
    r"""This class implements a pulse waveform voltage source.
    See :class:`PulseMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        VoltageSource.__init__(self, netlist, name, node_plus, node_minus)
        PulseMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = PulseMixin.format_spice_parameters
####################################################################################################
class PulseCurrentSource(CurrentSource, CurrentSourceMixinAbc, PulseMixin):
    r"""This class implements a pulse waveform current source.
    See :class:`PulseMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        CurrentSource.__init__(self, netlist, name, node_plus, node_minus)
        PulseMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = PulseMixin.format_spice_parameters
####################################################################################################
class ExponentialVoltageSource(VoltageSource, VoltageSourceMixinAbc, ExponentialMixin):
    r"""This class implements a exponential waveform voltage source.
    See :class:`ExponentialMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        VoltageSource.__init__(self, netlist, name, node_plus, node_minus)
        ExponentialMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = ExponentialMixin.format_spice_parameters
####################################################################################################
class ExponentialCurrentSource(CurrentSource, CurrentSourceMixinAbc, ExponentialMixin):
    r"""This class implements a exponential waveform current source.
    See :class:`ExponentialMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        CurrentSource.__init__(self, netlist, name, node_plus, node_minus)
        ExponentialMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = ExponentialMixin.format_spice_parameters
####################################################################################################
class PieceWiseLinearVoltageSource(VoltageSource, VoltageSourceMixinAbc, PieceWiseLinearMixin):
    r"""This class implements a piece wise linear waveform voltage source.
    See :class:`PieceWiseLinearMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        VoltageSource.__init__(self, netlist, name, node_plus, node_minus)
        PieceWiseLinearMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = PieceWiseLinearMixin.format_spice_parameters
####################################################################################################
class PieceWiseLinearCurrentSource(CurrentSource, CurrentSourceMixinAbc, PieceWiseLinearMixin):
    r"""This class implements a piece wise linear waveform current source.
    See :class:`PieceWiseLinearMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        CurrentSource.__init__(self, netlist, name, node_plus, node_minus)
        PieceWiseLinearMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = PieceWiseLinearMixin.format_spice_parameters
####################################################################################################
class SingleFrequencyFMVoltageSource(VoltageSource, VoltageSourceMixinAbc, SingleFrequencyFMMixin):
    r"""This class implements a single frequency FM waveform voltage source.
    See :class:`SingleFrequencyFMMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        VoltageSource.__init__(self, netlist, name, node_plus, node_minus)
        SingleFrequencyFMMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = SingleFrequencyFMMixin.format_spice_parameters
####################################################################################################
class SingleFrequencyFMCurrentSource(CurrentSource, CurrentSourceMixinAbc, SingleFrequencyFMMixin):
    r"""This class implements a single frequency FM waveform current source.
    See :class:`SingleFrequencyFMMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        CurrentSource.__init__(self, netlist, name, node_plus, node_minus)
        SingleFrequencyFMMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = SingleFrequencyFMMixin.format_spice_parameters
####################################################################################################
class AmplitudeModulatedVoltageSource(VoltageSource, VoltageSourceMixinAbc, AmplitudeModulatedMixin):
    r"""This class implements a amplitude modulated waveform voltage source.
    See :class:`AmplitudeModulatedMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        VoltageSource.__init__(self, netlist, name, node_plus, node_minus)
        AmplitudeModulatedMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = AmplitudeModulatedMixin.format_spice_parameters
####################################################################################################
class AmplitudeModulatedCurrentSource(CurrentSource, CurrentSourceMixinAbc, AmplitudeModulatedMixin):
    r"""This class implements a amplitude modulated waveform current source.
    See :class:`AmplitudeModulatedMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        CurrentSource.__init__(self, netlist, name, node_plus, node_minus)
        AmplitudeModulatedMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = AmplitudeModulatedMixin.format_spice_parameters
####################################################################################################
class RandomVoltageSource(VoltageSource, VoltageSourceMixinAbc, RandomMixin):
    r"""This class implements a random waveform voltage source.
    See :class:`RandomMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        VoltageSource.__init__(self, netlist, name, node_plus, node_minus)
        RandomMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = RandomMixin.format_spice_parameters
####################################################################################################
class RandomCurrentSource(CurrentSource, CurrentSourceMixinAbc, RandomMixin):
    r"""This class implements a random waveform current source.
    See :class:`RandomMixin` for documentation.
    """
    ##############################################
    def __init__(self, netlist, name, node_plus, node_minus, *args, **kwargs):
        CurrentSource.__init__(self, netlist, name, node_plus, node_minus)
        RandomMixin.__init__(self, *args, **kwargs)
    ##############################################
    format_spice_parameters = RandomMixin.format_spice_parameters
</file>

<file path="PySpice/Spice/Library.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
import logging
import re
####################################################################################################
from ..Tools.File import Directory
from .Parser import SpiceParser
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class SpiceLibrary:
    """This class implements a Spice sub-circuits and models library.
    A library is a directory which is recursively scanned for '.lib' file and parsed for sub-circuit
    and models definitions.
    Example of usage::
        spice_library = SpiceLibrary('/some/path/')
    If the directory hierarchy contains a file that define a 1N4148 sub-circuit then we can retrieve
    the file path using::
        spice_library['1N4148']
    """
    _logger = _module_logger.getChild('Library')
    EXTENSIONS = (
        '.spice',
        '.lib',
        '.mod',
        '.lib@xyce',
        '.mod@xyce',
    )
    ##############################################
    def __init__(self, root_path, recurse=False, section=None):
        self._directory = Directory(root_path).expand_vars_and_user()
        self._subcircuits = {}
        self._models = {}
        for path in self._directory.iter_file():
            extension = path.extension.lower()
            if extension in self.EXTENSIONS:
                self._logger.debug("Parse {}".format(path))
                try:
                    spice_parser = SpiceParser(path=path, recurse=recurse, section=section)
                    for lib in spice_parser.incl_libs:
                        self._subcircuits.update(lib._subcircuits)
                        self._models.update(lib._models)
                except Exception as e:
                    # Parse problem with this file, so skip it and keep going.
                    self._logger.warn("Problem parsing {path} - {e}".format(**locals()))
                    continue
                if spice_parser.is_only_subcircuit():
                    for subcircuit in spice_parser.subcircuits:
                        name = self._suffix_name(subcircuit.name, extension)
                        self._subcircuits[name] = path
                elif spice_parser.is_only_model():
                    for model in spice_parser.models:
                        name = self._suffix_name(model.name, extension)
                        self._models[name] = path
    ##############################################
    @staticmethod
    def _suffix_name(name, extension):
        if extension.endswith('@xyce'):
            name += '@xyce'
        return name
    ##############################################
    def __getitem__(self, name):
        if name in self._subcircuits:
            return self._subcircuits[name]
        elif name in self._models:
            return self._models[name]
        else:
            # print('Library {} not found in {}'.format(name, self._directory))
            # self._logger.warn('Library {} not found in {}'.format(name, self._directory))
            raise KeyError(name)
    ##############################################
    @property
    def subcircuits(self):
        """ Dictionary of sub-circuits """
        return iter(self._subcircuits)
    @property
    def models(self):
        """ Dictionary of models """
        return iter(self._models)
    # ##############################################
    # def iter_on_subcircuits(self):
    #     return self._subcircuits.itervalues()
    # ##############################################
    # def iter_on_models(self):
    #     return self._models.itervalues()
    # ##############################################
    def search(self, s):
        """ Return dict of all models/subcircuits with names matching regex s. """
        matches = {}
        models_subcircuits = {**self._models, **self._subcircuits}
        for name, mdl_subckt in models_subcircuits.items():
            if re.search(s, name):
                matches[name] = mdl_subckt
        return matches
</file>

<file path="PySpice/Spice/Netlist.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This modules implements circuit and subcircuit.
The definition of a netlist follows the same conventions as SPICE. For example this SPICE netlist
is translated to Python like this:
.. code-block:: spice
    .title Voltage Divider
    Vinput in 0 10V
    R1 in out 9k
    R2 out 0 1k
    .end
.. code-block:: python3
    circuit = Circuit('Voltage Divider')
   circuit.V('input', 'in', circuit.gnd, 10)
    circuit.R(1, 'in', 'out', kilo(9))
    circuit.R(2, 'out', circuit.gnd, kilo(1))
or as a class definition:
.. code-block:: python3
      class VoltageDivider(Circuit):
          def __init__(self, **kwargs):
              super().__init__(title='Voltage Divider', **kwargs)
              self.V('input', 'in', self.gnd, '10V')
              self.R(1, 'in', 'out', kilo(9))
              self.R(2, 'out', self.gnd, kilo(1))
The circuit attribute :attr:`gnd` represents the ground of the circuit or subcircuit, usually set to
0.
We can get an element or a model using its name using these two possibilities::
    circuit['R1'] # dictionary style
    circuit.R1    # attribute style
The dictionary style always works, but the attribute only works if it complies with the Python
syntax, i.e. the element or model name is a valide attribute name (identifier), i.e. starting by a
letter and not a keyword like 'in', cf. `Python Language Reference
<https://docs.python.org/2/reference/lexical_analysis.html>`_.
We can update an element parameter like this::
    circuit.R1.resistance = kilo(1)
To simulate the circuit, we must create a simulator instance using the :meth:`Circuit.simulator`::
    simulator = circuit.simulator()
"""
####################################################################################################
from collections import OrderedDict
from pathlib import Path
import keyword
import logging
import os
# import networkx
####################################################################################################
from ..Tools.StringTools import join_lines, join_list, join_dict
from .ElementParameter import (
    ParameterDescriptor,
    PositionalElementParameter,
    FlagParameter, KeyValueParameter,
)
from .Simulation import CircuitSimulator
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class DeviceModel:
    """This class implements a device model.
    Ngspice model types:
    +------+-------------------------------+
    | Code + Model Type                    |
    +------+-------------------------------+
    | R    + Semiconductor resistor model  |
    +------+-------------------------------+
    | C    + Semiconductor capacitor model |
    +------+-------------------------------+
    | L    + Inductor model                |
    +------+-------------------------------+
    | SW   + Voltage controlled switch     |
    +------+-------------------------------+
    | CSW  + Current controlled switch     |
    +------+-------------------------------+
    | URC  + Uniform distributed RC model  |
    +------+-------------------------------+
    | LTRA + Lossy transmission line model |
    +------+-------------------------------+
    | D    + Diode model                   |
    +------+-------------------------------+
    | NPN  + NPN BJT model                 |
    +------+-------------------------------+
    | PNP  + PNP BJT model                 |
    +------+-------------------------------+
    | NJF  + N-channel JFET model          |
    +------+-------------------------------+
    | PJF  + P-channel JFET model          |
    +------+-------------------------------+
    | NMOS + N-channel MOSFET model        |
    +------+-------------------------------+
    | PMOS + P-channel MOSFET model        |
    +------+-------------------------------+
    | NMF  + N-channel MESFET model        |
    +------+-------------------------------+
    | PMF  + P-channel MESFET model        |
    +------+-------------------------------+
    """
    ##############################################
    def __init__(self, name, modele_type, **parameters):
        self._name = str(name)
        self._model_type = str(modele_type)
        self._parameters = {}
        for key, value in parameters.items():
            if key.endswith('_'):
                key = key[:-1]
            self._parameters[key] = value
    ##############################################
    def clone(self):
        # Fixme: clone parameters ???
        return self.__class__(self._name, self._model_type, self._parameters)
    ##############################################
    @property
    def name(self):
        return self._name
    @property
    def model_type(self):
        return self._model_type
    @property
    def parameters(self):
        return self._parameters.keys()
    ##############################################
    def __getitem__(self, name):
        return self._parameters[name]
    ##############################################
    def __getattr__(self, name):
        try:
            return self._parameters[name]
        except KeyError:
            if name.endswith('_'):
                return self._parameters[name[:-1]]
            # Fixme: else
    ##############################################
    def __repr__(self):
        return str(self.__class__) + ' ' + self.name
    ##############################################
    def __str__(self):
        return ".model {0._name} {0._model_type} ({1})".format(self, join_dict(self._parameters))
####################################################################################################
class PinDefinition:
    """This class defines a pin of an element."""
    ##############################################
    def __init__(self, position, name=None, alias=None, optional=False):
        self._position = position
        self._name = name
        self._alias = alias
        self._optional = optional
    ##############################################
    def clone(self):
        # Fixme: self.__class__ ???
        return PinDefinition(self._position, self._name, self._alias, self._optional)
    ##############################################
    @property
    def position(self):
        return self._position
    @property
    def name(self):
        return self._name
    @property
    def alias(self):
        return self._alias
    @property
    def optional(self):
        return self._optional
####################################################################################################
class OptionalPin:
    def __init__(self, name):
        self._name = name
    @property
    def name(self):
        return self._name
####################################################################################################
class Pin(PinDefinition):
    """This class implements a pin of an element. It stores a reference to the element, the name of the
    pin and the node.
    """
    _logger = _module_logger.getChild('Pin')
    ##############################################
    def __init__(self, element, pin_definition, node):
        super().__init__(pin_definition.position, pin_definition.name, pin_definition.alias)
        self._element = element
        self._node = node
        node.connect(self)
    ##############################################
    @property
    def element(self):
        return self._element
    @property
    def node(self):
        return self._node
    ##############################################
    def __repr__(self):
        return "Pin {} of {} on node {}".format(self._name, self._element.name, self._node)
    ##############################################
    def disconnect(self):
        self._node.disconnect(self)
        self._node = None
    ##############################################
    def add_current_probe(self, circuit):
        """Add a current probe between the node and the pin.
        The ammeter is named *ElementName_PinName*.
        """
        # Fixme: require a reference to circuit
        # Fixme: add it to a list
        node = self._node
        self._node = '_'.join((self._element.name, self._name))
        circuit.V(self._node, node, self._node, '0')
####################################################################################################
class ElementParameterMetaClass(type):
    # Metaclass to implements the element node and parameter machinery.
    """Metaclass to customise the element classes when they are created and to register SPICE prefix.
    Element classes are of type :class:`ElementParameterMetaClass` instead of :class:`type`
    .. code-block:: none
        class Resistor(metaclass=ElementParameterMetaClass):
        <=>
        Resistor = ElementParameterMetaClass('Foo', ...)
    """
    #: Dictionary for SPICE prefix -> [cls,]
    _classes = {}
    _logger = _module_logger.getChild('ElementParameterMetaClass')
    ##############################################
    def __new__(meta_cls, class_name, base_classes, namespace):
        # __new__ is called for the creation of a class depending of this metaclass, i.e. at module loading
        # It customises the namespace of the new class
        # Collect positional and optional parameters from class attribute dict
        positional_parameters = {}
        parameters = {}
        for attribute_name, obj in namespace.items():
            if isinstance(obj, ParameterDescriptor):
                obj.attribute_name = attribute_name
                if isinstance(obj, PositionalElementParameter):
                    d = positional_parameters
                elif isinstance(obj, (FlagParameter, KeyValueParameter)):
                    d = parameters
                # else:
                #     raise NotImplementedError
                d[attribute_name] = obj
        # Dictionary for positional parameters : attribute_name -> parameter
        namespace['_positional_parameters'] = OrderedDict(
            sorted(list(positional_parameters.items()), key=lambda t: t[1]))
        # Dictionary for optional parameters
        #   order is not required for SPICE, but for unit test
        namespace['_optional_parameters'] = OrderedDict(
            sorted(list(parameters.items()), key=lambda t: t[0]))
        # Positional parameter array
        namespace['_parameters_from_args'] = [
            parameter
            for parameter in sorted(positional_parameters.values())
            if not parameter.key_parameter]
        # Implement alias for parameters: spice name -> parameter
        namespace['_spice_to_parameters'] = {
            parameter.spice_name:parameter
            for parameter in namespace['_optional_parameters'].values()}
        for parameter in namespace['_spice_to_parameters'].values():
            if (parameter.spice_name in namespace
                and parameter.spice_name != parameter.attribute_name):
                _module_logger.error("Spice parameter '{}' clash with namespace".format(parameter.spice_name))
        # Initialise pins
        def make_pin_getter(position):
            def getter(self):
                return self._pins[position]
            return getter
        def make_optional_pin_getter(position):
            def getter(self):
                return self._pins[position] if position < len(self._pins) else None
            return getter
        if 'PINS' in namespace and namespace['PINS'] is not None:
            number_of_optional_pins = 0
            pins = []
            for position, pin_definition in enumerate(namespace['PINS']):
                # ensure pin_definition is a tuple
                if isinstance(pin_definition, OptionalPin):
                    optional = True
                    number_of_optional_pins += 1
                    pin_definition = (pin_definition.name,)
                    pin_getter = make_optional_pin_getter(position)
                else:
                    optional = False
                    pin_getter = make_pin_getter(position)
                if not isinstance(pin_definition, tuple):
                    pin_definition = (pin_definition,)
                for name in pin_definition:
                    # Check for name clash
                    if name in namespace:
                        raise NameError("Pin {} of element {} clashes with another attribute".format(name, class_name))
                    # Add a pin getter in element class
                    namespace[name] = property(pin_getter)
                # Add pin
                pin = PinDefinition(position, *pin_definition, optional=optional)
                pins.append(pin)
            namespace['PINS'] = pins
            namespace['__number_of_optional_pins__'] = number_of_optional_pins
        else:
            _module_logger.debug("{} don't define a PINS attribute".format(class_name))
        return type.__new__(meta_cls, class_name, base_classes, namespace)
    ##############################################
    def __init__(meta_cls, class_name, base_classes, namespace):
        # __init__ is called after the class is created (__new__)
        type.__init__(meta_cls, class_name, base_classes, namespace)
        # Collect basic element classes
        if 'PREFIX' in namespace:
            prefix = namespace['PREFIX']
            if prefix is not None:
                classes = ElementParameterMetaClass._classes
                if prefix in classes:
                    classes[prefix].append(meta_cls)
                else:
                    classes[prefix] = [meta_cls]
    ##############################################
    # Note: These properties are only available from the class object
    #       e.g. Resistor.number_of_pins or Resistor.__class__.number_of_pins
    @property
    def number_of_pins(cls):
        #! Fixme: many pins ???
        number_of_pins = len(cls.PINS)
        if cls.__number_of_optional_pins__:
            return slice(number_of_pins - cls.__number_of_optional_pins__, number_of_pins +1)
        else:
            return number_of_pins
    @property
    def number_of_positional_parameters(cls):
        return len(cls._positional_parameters)
    @property
    def positional_parameters(cls):
        return cls._positional_parameters
    @property
    def optional_parameters(cls):
        return cls._optional_parameters
    @property
    def parameters_from_args(cls):
        return cls._parameters_from_args
    @property
    def spice_to_parameters(cls):
        return cls._spice_to_parameters
####################################################################################################
class Element(metaclass=ElementParameterMetaClass):
    """This class implements a base class for an element.
    It use a metaclass machinery for the declaration of the parameters.
    """
    # These class attributes are defined in subclasses or via the metaclass.
    PINS = None
    _positional_parameters = None
    _optional_parameters = None
    _parameters_from_args = None
    _spice_to_parameters = None
    #: SPICE element prefix
    PREFIX = None
    ##############################################
    def __init__(self, netlist, name, *args, **kwargs):
        self._netlist = netlist
        self._name = str(name)
        self.raw_spice = ''
        self.enabled = True
        # Process remaining args
        if len(self._parameters_from_args) < len(args):
            raise NameError("Number of args mismatch")
        for parameter, value in zip(self._parameters_from_args, args):
            setattr(self, parameter.attribute_name, value)
        # Process kwargs
        for key, value in kwargs.items():
            if key == 'raw_spice':
                self.raw_spice = value
            elif (key in self._positional_parameters or
                  key in self._optional_parameters or
                  key in self._spice_to_parameters):
                setattr(self, key, value)
            elif hasattr(self, 'VALID_KWARGS') and key in self.VALID_KWARGS:
                pass # cf. NonLinearVoltageSource
            else:
                raise ValueError('Unknown argument {}={}'.format(key, value))
        self._pins = ()
        netlist._add_element(self)
    ##############################################
    def has_parameter(self, name):
        return hasattr(self, '_' + name)
    ##############################################
    def copy_to(self, element):
        for parameter_dict in self._positional_parameters, self._optional_parameters:
            for parameter in parameter_dict.values():
                if hasattr(self, parameter.attribute_name):
                    value = getattr(self, parameter.attribute_name)
                    setattr(element, parameter.attribute_name, value)
        if hasattr(self, 'raw_spice'):
            element.raw_spice = self.raw_spice
    ##############################################
    @property
    def netlist(self):
        return self._netlist
    @property
    def name(self):
        return self.PREFIX + self._name
    @property
    def pins(self):
        return self._pins
    ##############################################
    def detach(self):
        for pin in self._pins:
            pin.disconnect()
        self._netlist._remove_element(self)
        self._netlist = None
        return self
    ##############################################
    @property
    def nodes(self):
        return [pin.node for pin in self._pins]
    @property
    def node_names(self):
        return [str(x) for x in self.nodes]
    ##############################################
    def __repr__(self):
        return self.__class__.__name__ + ' ' + self.name
    ##############################################
    def __setattr__(self, name, value):
        # Implement alias for parameters
        if name in self._spice_to_parameters:
            parameter = self._spice_to_parameters[name]
            object.__setattr__(self, parameter.attribute_name, value)
        else:
            object.__setattr__(self, name, value)
    ##############################################
    def __getattr__(self, name):
        # Implement alias for parameters
        if name in self._spice_to_parameters:
            parameter = self._spice_to_parameters[name]
            return object.__getattribute__(self, parameter.attribute_name)
        else:
            raise AttributeError(name)
    ##############################################
    def format_node_names(self):
        """ Return the formatted list of nodes. """
        return join_list((self.name, join_list(self.nodes)))
    ##############################################
    def parameter_iterator(self):
        """ This iterator returns the parameter in the right order. """
        # Fixme: .parameters ???
        for parameter_dict in self._positional_parameters, self._optional_parameters:
            for parameter in parameter_dict.values():
                if parameter.nonzero(self):
                    yield parameter
    ##############################################
    # @property
    # def parameters(self):
    #     return self._parameters
    ##############################################
    def format_spice_parameters(self):
        """ Return the formatted list of parameters. """
        return join_list([parameter.to_str(self) for parameter in self.parameter_iterator()])
    ##############################################
    def __str__(self):
        """ Return the SPICE element definition. """
        return join_list((self.format_node_names(), self.format_spice_parameters(), self.raw_spice))
####################################################################################################
class AnyPinElement(Element):
    PINS = ()
    ##############################################
    def copy_to(self, netlist):
        element = self.__class__(netlist, self._name)
        super().copy_to(element)
        return element
####################################################################################################
class FixedPinElement(Element):
    ##############################################
    def __init__(self, netlist, name, *args, **kwargs):
        # Get nodes
        # Usage: if pins are passed using keywords then args must be empty
        #        optional pins are passed as keyword
        pin_definition_nodes = []
        number_of_args = len(args)
        if number_of_args:
            expected_number_of_pins = self.__class__.number_of_pins   # Fixme:
            if isinstance(expected_number_of_pins, slice):
                expected_number_of_pins = expected_number_of_pins.start
            if number_of_args < expected_number_of_pins:
                raise NameError("Incomplete node list for element {}".format(self.name))
            else:
                nodes = args[:expected_number_of_pins]
                args = args[expected_number_of_pins:]
                pin_definition_nodes = zip(self.PINS, nodes)
        else:
            for pin_definition in self.PINS:
                if pin_definition.name in kwargs:
                    node = kwargs[pin_definition.name]
                    del kwargs[pin_definition.name]
                elif pin_definition.alias is not None and pin_definition.alias in kwargs:
                    node = kwargs[pin_definition.alias]
                    del kwargs[pin_definition.alias]
                elif pin_definition.optional:
                    continue
                else:
                    raise NameError("Node '{}' is missing for element {}".format(pin_definition.name, self.name))
                pin_definition_nodes.append((pin_definition, node))
        super().__init__(netlist, name, *args, **kwargs)
        self._pins = [Pin(self, pin_definition, netlist.get_node(node, True))
                      for pin_definition, node in pin_definition_nodes]
    ##############################################
    def copy_to(self, netlist):
        element = self.__class__(netlist, self._name, *self.nodes)
        super().copy_to(element)
        return element
####################################################################################################
class NPinElement(Element):
    PINS = '*'
    ##############################################
    def __init__(self, netlist, name, nodes, *args, **kwargs):
        super().__init__(netlist, name, *args, **kwargs)
        self._pins = [Pin(self, PinDefinition(position), netlist.get_node(node, True))
                      for position, node in enumerate(nodes)]
    ##############################################
    def copy_to(self, netlist):
        nodes = [str(x) for x in self.nodes]
        element = self.__class__(netlist, self._name, nodes)
        super().copy_to(element)
        return element
####################################################################################################
class Node:
    """This class implements a node in the circuit. It stores a reference to the pins connected to
    the node.
    """
    _logger = _module_logger.getChild('Node')
    ##############################################
    def __init__(self, netlist, name):
        if keyword.iskeyword(name):
            self._logger.warning("Node name '{}' is a Python keyword".format(name))
        self._netlist = netlist
        self._name = str(name)
        self._pins = set()
    ##############################################
    def __repr__(self):
        return 'Node {}'.format(self._name)
    def __str__(self):
        return self._name
    ##############################################
    @property
    def netlist(self):
        return self._netlist
    @property
    def name(self):
        return self._name
    @name.setter
    def name(self, value):
        self._netlist._update_node_name(self, value)   # update nodes dict
        self._name = value
    @property
    def pins(self):
        return self._pins
    ##############################################
    @property
    def is_ground_node(self):
        return self._name in ('0', 'gnd')
    ##############################################
    def __bool__(self):
        return bool(self._pins)
    ##############################################
    def __iter__(self):
        return iter(self._pins)
    ##############################################
    def connect(self, pin):
        if pin not in self._pins:
            self._pins.add(pin)
        else:
            raise ValueError("Pin {} is already connected to node {}".format(pin, self))
    ##############################################
    def disconnect(self, pin):
        self._pins.remove(pin)
####################################################################################################
class Netlist:
    """This class implements a base class for a netlist.
    .. note:: This class is completed with element shortcuts when the module is loaded.
    """
    _logger = _module_logger.getChild('Netlist')
    ##############################################
    def __init__(self):
        self._ground_name = 0
        self._nodes = {}
        self._ground_node = self._add_node(self._ground_name)
        self._subcircuits = OrderedDict()   # to keep the declaration order
        self._elements = OrderedDict()   # to keep the declaration order
        self._models = {}
        self.raw_spice = ''
        # self._graph = networkx.Graph()
    ##############################################
    def copy_to(self, netlist):
        for subcircuit in self.subcircuits:
            netlist.subcircuit(subcircuit)
        for element in self.elements:
            element.copy_to(netlist)
        for name, model in self._models.items():
            netlist._models[name] = model.clone()
        netlist.raw_spice = str(self.raw_spice)
        return netlist
    ##############################################
    @property
    def gnd(self):
        return self._ground
    @property
    def nodes(self):
        return self._nodes.values()
    @property
    def node_names(self):
        return self._nodes.keys()
    @property
    def elements(self):
        return self._elements.values()
    @property
    def element_names(self):
        return self._elements.keys()
    @property
    def models(self):
        return self._models.values()
    @property
    def model_names(self):
        return self._models.keys()
    @property
    def subcircuits(self):
        return self._subcircuits.values()
    @property
    def subcircuit_names(self):
        return self._subcircuits.keys()
    ##############################################
    def element(self, name):
        return self._elements[name]
    def model(self, name):
        return self._models[name]
    def node(self, name):
        return self._nodes[name]
    ##############################################
    def __getitem__(self, attribute_name):
        if attribute_name in self._elements:
            return self.element(attribute_name)
        elif attribute_name in self._models:
            return self.model(attribute_name)
        # Fixme: subcircuits
        elif attribute_name in self._nodes:
            return self.node(attribute_name)
        else:
            raise IndexError(attribute_name)   # KeyError
    ##############################################
    def __getattr__(self, attribute_name):
        try:
            return self.__getitem__(attribute_name)
        except IndexError:
            raise AttributeError(attribute_name)
    ##############################################
    def _add_node(self, node_name):
        node_name = str(node_name)
        if node_name not in self._nodes:
            node = Node(self, node_name)
            self._nodes[node_name] = node
            return node
        else:
            raise ValueError("Node {} is already defined".format(node_name))
    ##############################################
    def _update_node_name(self, node, new_name):
        if node.name not in self._nodes:
            # should not happen
            raise ValueError("Unknown node")
        del self._nodes[node.name]
        self._nodes[new_name] = node
    ##############################################
    def get_node(self, node, create=False):
        if isinstance(node, Node):
            return node
        else:
            str_node = str(node)
            if str_node in self._nodes:
                return self._nodes[str_node]
            elif create:
                return self._add_node(str_node)
            else:
                raise KeyError("Node {} doesn't exists".format(node))
    ##############################################
    def has_ground_node(self):
        return bool(self._ground_node)
    ##############################################
    def _add_element(self, element):
        """Add an element."""
        if element.name not in self._elements:
            self._elements[element.name] = element
        else:
            raise NameError("Element name {} is already defined".format(element.name))
    ##############################################
    def _remove_element(self, element):
        try:
            del self._elements[element.name]
        except KeyError:
            raise NameError("Cannot remove undefined element {}".format(element))
    ##############################################
    def model(self, name, modele_type, **parameters):
        """Add a model."""
        model = DeviceModel(name, modele_type, **parameters)
        if model.name not in self._models:
            self._models[model.name] = model
        else:
            raise NameError("Model name {} is already defined".format(name))
        return model
    ##############################################
    def subcircuit(self, subcircuit):
        """Add a sub-circuit."""
        # Fixme: subcircuit is a class
        self._subcircuits[str(subcircuit.name)] = subcircuit
    ##############################################
    def __str__(self):
        """ Return the formatted list of element and model definitions. """
        # Fixme: order ???
        netlist = self._str_raw_spice()
        netlist += self._str_subcircuits() # before elements
        netlist += self._str_elements()
        netlist += self._str_models()
        return netlist
    ##############################################
    def _str_elements(self):
        elements = [element for element in self.elements if element.enabled]
        return join_lines(elements) + os.linesep
    ##############################################
    def _str_models(self):
        if self._models:
            return join_lines(self.models) + os.linesep
        else:
            return ''
    ##############################################
    def _str_subcircuits(self):
        if self._subcircuits:
            return join_lines(self.subcircuits)
        else:
            return ''
    ##############################################
    def _str_raw_spice(self):
        netlist = self.raw_spice
        if netlist and not netlist.endswith(os.linesep):
            netlist += os.linesep
        return netlist
####################################################################################################
class SubCircuit(Netlist):
    """This class implements a sub-cicuit netlist."""
    ##############################################
    def __init__(self, name, *nodes, **kwargs):
        if len(set(nodes)) != len(nodes):
            raise ValueError("Duplicated nodes in {}".format(nodes))
        super().__init__()
        self._name = str(name)
        self._external_nodes = nodes
        # Fixme: ok ?
        self._ground = kwargs.get('ground', 0)
        if 'ground' in kwargs:
            del kwargs['ground']
        self._parameters = kwargs
    ##############################################
    def clone(self, name=None):
        if name is None:
            name = self._name
        # Fixme: clone parameters ???
        kwargs = dict(self._parameters)
        kwargs['ground'] = self._ground
        subcircuit = self.__class__(name, list(self._external_nodes), **kwargs)
        self.copy_to(subcircuit)
    ##############################################
    @property
    def name(self):
        return self._name
    @property
    def external_nodes(self):
        return self._external_nodes
    @property
    def parameters(self):
        """Parameters"""
        return self._parameters
    ##############################################
    def check_nodes(self):
        """Check for dangling nodes in the subcircuit."""
        nodes = self._external_nodes
        connected_nodes = set()
        for element in self.elements:
            connected_nodes.add(nodes & element.nodes)
        not_connected_nodes = nodes - connected_nodes
        if not_connected_nodes:
            raise NameError("SubCircuit Nodes {} are not connected".format(not_connected_nodes))
    ##############################################
    def __str__(self):
        """Return the formatted subcircuit definition."""
        nodes = join_list(self._external_nodes)
        parameters = join_list(['{}={}'.format(key, value)
                                for key, value in self._parameters.items()])
        netlist = '.subckt ' + join_list((self._name, nodes, parameters)) + os.linesep
        netlist += super().__str__()
        netlist += '.ends ' + self._name + os.linesep
        return netlist
####################################################################################################
class SubCircuitFactory(SubCircuit):
    NAME = None
    NODES = None
    ##############################################
    def __init__(self, **kwargs):
        super().__init__(self.NAME, *self.NODES, **kwargs)
####################################################################################################
class Circuit(Netlist):
    """This class implements a cicuit netlist.
    To get the corresponding Spice netlist use::
       circuit = Circuit()
       ...
       str(circuit)
    """
    _logger = _module_logger.getChild('Circuit')
    ##############################################
    def __init__(self, title,
                 ground=0,   # Fixme: gnd = 0
                 global_nodes=(),
                 ):
        super().__init__()
        self.title = str(title)
        self._ground = ground
        self._global_nodes = set(global_nodes)   # .global
        self._includes = []   # .include
        self._libs = []   # .lib, contains a (name, section) tuple
        self._parameters = {}   # .param
        # Fixme: not implemented
        #  .csparam
        #  .func
        #  .if
    ##############################################
    def clone(self, title=None):
        if title is None:
            title = self.title
        circuit = self.__class__(title, self._ground, set(self._global_nodes))
        self.copy_to(circuit)
        for include in self._includes:
            circuit.include(include)
        for name, value in self._parameters.items():
            self.parameter(name, value)
        return circuit
    ##############################################
    def include(self, path):
        """Include a file."""
        if path not in self._includes:
            self._includes.append(path)
        else:
            self._logger.warn("Duplicated include")
    ##############################################
    def lib(self, name, section=None):
        """Load a library."""
        v = (name, section)
        if v not in self._libs:
            self._libs.append(v)
        else:
            self._logger.warn(f"Duplicated lib {v}")
    ##############################################
    def parameter(self, name, expression):
        """Set a parameter."""
        self._parameters[str(name)] = str(expression)
    ##############################################
    def str(self, simulator=None):
        """Return the formatted desk."""
        # if not self.has_ground_node():
        #     raise NameError("Circuit don't have ground node")
        netlist = self._str_title()
        netlist += self._str_includes(simulator)
        netlist += self._str_libs(simulator)
        netlist += self._str_globals()
        netlist += self._str_parameters()
        netlist += super().__str__()
        return netlist
    ##############################################
    def _str_title(self):
        return '.title {}'.format(self.title) + os.linesep
    ##############################################
    def _str_includes(self, simulator=None):
        if self._includes:
            # ngspice don't like // in path, thus ensure we write real paths
            real_paths = []
            for path in self._includes:
                path = Path(str(path)).resolve()
                if simulator:
                    path_flavour = Path(str(path) + '@' + simulator)
                    if path_flavour.exists():
                        path = path_flavour
                real_paths.append(path)
            return join_lines(real_paths, prefix='.include ') + os.linesep
        else:
            return ''
    ##############################################
    def _str_libs(self, simulator=None):
        if self._libs:
            libs = []
            for lib, section in self._libs:
                lib = Path(str(lib)).resolve()
                if simulator:
                    lib_flavour = Path(f"{lib}@{simulator}")
                    if lib_flavour.exists():
                        lib = lib_flavour
                s = f".lib {lib}"
                if section:
                    s += f" {section}"
                libs.append(s)
            return os.linesep.join(libs) + os.linesep
        else:
            return ''
    ##############################################
    def _str_globals(self):
        if self._global_nodes:
            return '.global ' + join_list(self._global_nodes) + os.linesep
        else:
            return ''
    ##############################################
    def _str_parameters(self):
        if self._parameters:
            return ''.join([f'.param {key}={value}' + os.linesep
                            for key, value in self._parameters.items()])
        else:
            return ''
    ##############################################
    def __str__(self):
        return self.str(simulator=None)
    ##############################################
    def str_end(self):
        return str(self) + '.end' + os.linesep
    ##############################################
    def simulator(self, *args, **kwargs):
        return CircuitSimulator.factory(self, *args, **kwargs)
</file>

<file path="PySpice/Spice/Parser_jmgc.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2020 jmgc / Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
"""This module implements a partial SPICE netlist parser.
See the :command:`cir2py` tool for an example of usage of the parser.
It would be difficult to implement a full parser for Ngspice since the syntax is mainly contextual.
SPICE is case insensitive.
"""
####################################################################################################
from collections import OrderedDict
import logging
import os
import regex
####################################################################################################
from .ElementParameter import FlagParameter
from .Netlist import ElementParameterMetaClass, Circuit, SubCircuit
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class ParseError(NameError):
    pass
####################################################################################################
class PrefixData:
    """This class represents a device prefix."""
    ##############################################
    def __init__(self, prefix, classes):
        self.prefix = prefix
        self.classes = classes
        number_of_positionals_min = 1000
        number_of_positionals_max = 0
        has_optionals = False
        for element_class in classes:
            number_of_positionals = element_class.number_of_positional_parameters
            number_of_positionals_min = min(number_of_positionals_min, number_of_positionals)
            number_of_positionals_max = max(number_of_positionals_max, number_of_positionals)
            has_optionals = max(has_optionals, bool(element_class.optional_parameters))
        self.number_of_positionals_min = number_of_positionals_min
        self.number_of_positionals_max = number_of_positionals_max
        self.has_optionals = has_optionals
        self.multi_devices = len(classes) > 1
        self.has_variable_number_of_pins = prefix in ('Q', 'X')  # NPinElement, Q has 3 to 4 pins
        if self.has_variable_number_of_pins:
            self.number_of_pins = None
        else:
            # Q and X are single
            self.number_of_pins = classes[0].number_of_pins
        self.has_flag = False
        for element_class in classes:
            for parameter in element_class.optional_parameters.values():
                if isinstance(parameter, FlagParameter):
                    self.has_flag = True
    ##############################################
    def __len__(self):
        return len(self.classes)
    ##############################################
    def __iter__(self):
        return iter(self.classes)
    ##############################################
    @property
    def single(self):
        if not self.multi_devices:
            return self.classes[0]
        else:
            raise NameError()
####################################################################################################
_prefix_cache = {}
for prefix, classes in ElementParameterMetaClass._classes.items():
    prefix_data = PrefixData(prefix, classes)
    _prefix_cache[prefix] = prefix_data
    _prefix_cache[prefix.lower()] = prefix_data
# for prefix_data in sorted(_prefix_cache.values(), key=lambda x: len(x)):
#     print(prefix_data.prefix,
#           len(prefix_data),
#           prefix_data.number_of_positionals_min, prefix_data.number_of_positionals_max,
#           prefix_data.has_optionals)
# Single:
# B 0 True
# D 1 True
# F 2 False
# G 1 False
# H 2 False
# I 1 False
# J 1 True
# K 3 False
# M 1 True
# S 2 False
# V 1 False
# W 3 False
# Z 1 True
# Two:
# E 0 1 False
# L 1 2 True
# Three:
# C 1 2 True
# R 1 2 True
# NPinElement:
# Q 1 1 True
# X 1 1 False
####################################################################################################
class Statement:
    """This base class implements a statement, in fact a line in a Spice netlist."""
    ##############################################
    def __init__(self, line, statement=None):
        self._line = line
        if statement is not None:
            self._line.lower_case_statement(statement)
    ##############################################
    def __repr__(self):
        return '{} {}'.format(self.__class__.__name__, repr(self._line))
    ##############################################
    def value_to_python(self, x):
        if x:
            if str(x)[0].isdigit():
                return str(x)
            else:
                return "'{}'".format(x)
        else:
            return ''
    ##############################################
    def values_to_python(self, values):
        return [self.value_to_python(x) for x in values]
    ##############################################
    def kwargs_to_python(self, kwargs):
        return ['{}={}'.format(key, self.value_to_python(value))
                for key, value in kwargs.items()]
    ##############################################
    def join_args(self, args):
        return ', '.join(args)
####################################################################################################
class Comment(Statement):
    pass
####################################################################################################
class Title(Statement):
    """This class implements a title definition."""
    ##############################################
    def __init__(self, line):
        super().__init__(line, statement='title')
        self._title = self._line.right_of('.title')
    ##############################################
    def __str__(self):
        return self._title
    ##############################################
    def __repr__(self):
        return 'Title {}'.format(self._title)
####################################################################################################
class Include(Statement):
    """This class implements a include definition."""
    ##############################################
    def __init__(self, line):
        super().__init__(line, statement='include')
        self._include = self._line.right_of('.include')
    ##############################################
    def __str__(self):
        return self._include
    ##############################################
    def __repr__(self):
        return 'Include {}'.format(self._include)
    ##############################################
    def to_python(self, netlist_name):
        return '{}.include({})'.format(netlist_name, self._include) + os.linesep
####################################################################################################
class Model(Statement):
    """This class implements a model definition.
    Spice syntax::
        .model mname type(pname1=pval1 pname2=pval2 ... )
    """
    ##############################################
    def __init__(self, line):
        super().__init__(line, statement='model')
        base, self._parameters = line.split_keyword('.model')
        self._name, self._model_type = base
        self._name = self._name.lower()
    ##############################################
    @property
    def name(self):
        """Name of the model"""
        return self._name
    ##############################################
    def __repr__(self):
        return 'Model {} {} {}'.format(self._name, self._model_type, self._parameters)
    ##############################################
    def to_python(self, netlist_name):
        args = self.values_to_python((self._name, self._model_type))
        kwargs = self.kwargs_to_python(self._parameters)
        return '{}.model({})'.format(netlist_name, self.join_args(args + kwargs)) + os.linesep
    ##############################################
    def build(self, circuit):
        return circuit.model(self._name, self._model_type, **self._parameters)
####################################################################################################
class Parameter(Statement):
    """This class implements a parameter definition.
    Spice syntax::
        .param name=expr
    """
    ##############################################
    def __init__(self, line):
        super().__init__(line, statement='param')
        text = line.right_of('.param').strip().lower()  # Fixme: lower ???
        idx = text.find('=')
        self._name = text[:idx].strip()
        self._value = text[idx + 1:].strip()
    ##############################################
    @property
    def name(self):
        """Name of the model"""
        return self._name
    ##############################################
    def __repr__(self):
        return 'Param {}={}'.format(self._name, self._value)
    ##############################################
    def to_python(self, netlist_name):
        args = self.values_to_python((self._name, self._value))
        # Fixme: linesep here ???
        return '{}.param({})'.format(netlist_name, self.join_args(args)) + os.linesep
    ##############################################
    def build(self, circuit):
        circuit.parameter(self._name, self._value)
####################################################################################################
# Review: HERE
class CircuitStatement(Statement):
    # Review: jmgc
    """This class implements a circuit definition.
    Spice syntax::
        Title ...
    """
    ##############################################
    def __init__(self, title):
        super().__init__(title, statement='title')
        # Review: Title
        title_statement = '.title '
        self._title = str(title)
        if self._title.startswith(title_statement):
            self._title = self._title[len(title_statement):]
        self._statements = []
        self._subcircuits = []
        self._models = []
        self._required_subcircuits = set()
        self._required_models = set()
        self._params = []
    ##############################################
    @property
    def title(self):
        """Title of the circuit."""
        return self._title
    @property
    def name(self):
        """Name of the circuit."""
        return self._title
    @property
    def models(self):
        """Models of the circuit."""
        return self._models
    @property
    def subcircuits(self):
        """Subcircuits of the circuit."""
        return self._subcircuits
    @property
    def params(self):
        """Parameters of the circuit."""
        return self._params
    ##############################################
    def __repr__(self):
        text = 'Circuit {}'.format(self._title) + os.linesep
        text += os.linesep.join([repr(model) for model in self._models]) + os.linesep
        text += os.linesep.join([repr(subcircuit) for subcircuit in self._subcircuits]) + os.linesep
        text += os.linesep.join(['  ' + repr(statement) for statement in self._statements])
        return text
    ##############################################
    def __iter__(self):
        """Return an iterator on the statements."""
        return iter(self._models + self._subcircuits + self._statements)
    ##############################################
    def append(self, statement):
        """Append a statement to the statement's list."""
        self._statements.append(statement)
    ##############################################
    def append_model(self, statement):
        """Append a model to the statement's list."""
        self._models.append(statement)
    ##############################################
    def append_param(self, statement):
        """Append a param to the statement's list."""
        self._params.append(statement)
    ##############################################
    def append_subcircuit(self, statement):
        """Append a subcircuit to the statement's list."""
        self._subcircuits.append(statement)
    ##############################################
    def to_python(self, ground=0):
        subcircuit_name = 'subcircuit_' + self._name
        args = self.values_to_python([subcircuit_name] + self._nodes)
        source_code = ''
        source_code += '{} = SubCircuit({})'.format(subcircuit_name, self.join_args(args)) + os.linesep
        source_code += SpiceParser.netlist_to_python(subcircuit_name, self, ground)
        return source_code
    ##############################################
    def build(self, ground=0):
        circuit = Circuit(self._title)
        for statement in self._params:
            statement.build(circuit)
        for statement in self._models:
            model = statement.build(circuit)
        for statement in self._subcircuits:
            subckt = statement.build(ground)  # Fixme: ok ???
            circuit.subcircuit(subckt)
        for statement in self._statements:
            if isinstance(statement, Element):
                statement.build(circuit, ground)
        return circuit
####################################################################################################
class SubCircuitStatement(Statement):
    """This class implements a sub-circuit definition.
    Spice syntax::
        .SUBCKT name node1 ... param1=value1 ...
    """
    ##############################################
    def __init__(self, line):
        super().__init__(line, statement='subckt')
        # Fixme
        parameters, dict_parameters = self._line.split_keyword('.subckt')
        # Review: syntax ???
        if parameters[-1].lower() == 'params:':
            parameters = parameters[:-1]
        self._name, self._nodes = parameters[0], parameters[1:]
        self._name = self._name.lower()
        self._parameters = dict_parameters
        self._statements = []
        self._subcircuits = []
        self._models = []
        self._required_subcircuits = set()
        self._required_models = set()
        self._params = []
    ##############################################
    @property
    def name(self):
        """Name of the sub-circuit."""
        return self._name
    @property
    def nodes(self):
        """Nodes of the sub-circuit."""
        return self._nodes
    @property
    def models(self):
        """Models of the sub-circuit."""
        return self._models
    @property
    def params(self):
        """Params of the sub-circuit."""
        return self._params
    @property
    def subcircuits(self):
        """Subcircuits of the sub-circuit."""
        return self._subcircuits
    ##############################################
    def __repr__(self):
        if self._parameters:
            text = 'SubCircuit {} {} Parameters: {}'.format(self._name, self._nodes, self._parameters) + os.linesep
        else:
            text = 'SubCircuit {} {}'.format(self._name, self._nodes) + os.linesep
        text += os.linesep.join([repr(model) for model in self._models]) + os.linesep
        text += os.linesep.join([repr(subcircuit) for subcircuit in self._subcircuits]) + os.linesep
        text += os.linesep.join(['  ' + repr(statement) for statement in self._statements])
        return text
    ##############################################
    def __iter__(self):
        """Return an iterator on the statements."""
        return iter(self._models + self._subcircuits + self._statements)
    ##############################################
    def append(self, statement):
        """Append a statement to the statement's list."""
        self._statements.append(statement)
    ##############################################
    def append_model(self, statement):
        """Append a model to the statement's list."""
        self._models.append(statement)
    ##############################################
    def append_param(self, statement):
        """Append a param to the statement's list."""
        self._params.append(statement)
    ##############################################
    def append_subcircuit(self, statement):
        """Append a model to the statement's list."""
        self._subcircuits.append(statement)
    ##############################################
    def to_python(self, ground=0):
        subcircuit_name = 'subcircuit_' + self._name
        args = self.values_to_python([subcircuit_name] + self._nodes)
        source_code = ''
        source_code += '{} = SubCircuit({})'.format(subcircuit_name, self.join_args(args)) + os.linesep
        source_code += SpiceParser.netlist_to_python(subcircuit_name, self, ground)
        return source_code
    ##############################################
    def build(self, ground=0, parent=None):
        subcircuit = SubCircuit(self._name, *self._nodes, **self._parameters)
        subcircuit.parent = parent
        for statement in self._params:
            statement.build(subcircuit)
        for statement in self._models:
            model = statement.build(subcircuit)
        for statement in self._subcircuits:
            subckt = statement.build(ground, parent=subcircuit)  # Fixme: ok ???
            subcircuit.subcircuit(subckt)
        for statement in self._statements:
            if isinstance(statement, Element):
                statement.build(subcircuit, ground)
        return subcircuit
####################################################################################################
class Element(Statement):
    """This class implements an element definition.
    "{ expression }" are allowed in device line.
    """
    _logger = _module_logger.getChild('Element')
    ##############################################
    def __init__(self, line):
        super().__init__(line)
        line_str = str(line)
        # self._logger.debug(os.linesep + line_str)
        # Retrieve device prefix
        prefix = line_str[0]
        if prefix.isalpha():
            self._prefix = prefix
        else:
            raise ParseError("Not an element prefix: " + prefix)
        prefix_data = _prefix_cache[self._prefix]
        # Retrieve device name
        args, kwargs = line.split_element(prefix)
        self._name = args.pop(0)
        self._nodes = []
        self._parameters = []
        self._dict_parameters = {}
        # Read nodes
        if not prefix_data.has_variable_number_of_pins:
            number_of_pins = prefix_data.number_of_pins
            if number_of_pins:
                self._nodes = args[:number_of_pins]
                args = args[number_of_pins:]
        else:  # Q or X
            if prefix_data.prefix == 'Q':
                self._nodes = args[:3]
                args = args[3:]
                # Fixme: optional node
            else:  # X
                if args[-1].lower() == 'params:':
                    args.pop()
                self._parameters.append(args.pop())
                self._nodes = args
                args = []
        # Read positionals
        number_of_positionals = prefix_data.number_of_positionals_min
        if number_of_positionals and (len(args) > 0) and (prefix_data.prefix != 'X'):  # model is optional
            self._parameters = args[:number_of_positionals]
            args = args[number_of_positionals:]
        if prefix_data.multi_devices and (len(args) > 0):
            remaining = args
            args = []
            self._parameters.extend(remaining)
        if prefix_data.prefix in ('V', 'I') and (len(args) > 0):
            # merge remaining
            self._parameters[-1] += " " + " ".join(args)
            self._dict_parameters = kwargs
        # Read optionals
        if (prefix_data.has_optionals or (prefix_data.prefix == 'X')) and (len(kwargs) > 0):
            for key in kwargs:
                self._dict_parameters[key] = kwargs[key]
        if prefix_data.multi_devices:
            for element_class in prefix_data:
                if len(self._parameters) == element_class.number_of_positional_parameters:
                    break
        else:
            element_class = prefix_data.single
        self.factory = element_class
        # Move positionals passed as kwarg
        to_delete = []
        for parameter in element_class.positional_parameters.values():
            if parameter.key_parameter:
                idx = parameter.position
                if idx < len(self._parameters):
                    self._dict_parameters[parameter.attribute_name] = self._parameters[idx]
                    to_delete.append(idx - len(to_delete))
        for idx in to_delete:
            self._parameters.pop(idx)
        # self._logger.debug(os.linesep + self.__repr__())
    ##############################################
    @property
    def name(self):
        """Name of the element"""
        return self._name
    ##############################################
    def __repr__(self):
        return 'Element {0._prefix} {0._name} {0._nodes} {0._parameters} {0._dict_parameters}'.format(self)
    ##############################################
    def translate_ground_node(self, ground):
        nodes = []
        for node in self._nodes:
            if str(node) == str(ground):
                node = 0
            nodes.append(node)
        return nodes
    ##############################################
    def to_python(self, netlist_name, ground=0):
        nodes = self.translate_ground_node(ground)
        args = [self._name]
        if self._prefix != 'X':
            args += nodes + self._parameters
        else:  # != Spice
            args += self._parameters + nodes
        args = self.values_to_python(args)
        kwargs = self.kwargs_to_python(self._dict_parameters)
        return '{}.{}({})'.format(netlist_name, self._prefix, self.join_args(args + kwargs)) + os.linesep
    ##############################################
    def _check_params(self, elements=1):
        params = []
        for param in self._parameters:
            values = param.replace(',', ' ')
            if values[0] == '(' and values[-1] == ')':
                values = values[1: -1].split()
                if len(values) > elements:
                    raise IndexError('Incorrect number of elements for (%r): %s' % (self, param))
                params.extend(values)
            else:
                params.extend(values.split())
        self._parameters = params
    ##############################################
    def _voltage_controlled_nodes(self, poly_arg):
        result = ['v(%s,%s)' % nodes
                  for nodes in zip(self._parameters[:(2 * poly_arg):2],
                                   self._parameters[1:(2 * poly_arg):2])]
        result += self._parameters[2 * poly_arg:]
        return ' '.join(result)
    ##############################################
    def _current_controlled_nodes(self, poly_arg):
        result = ['i(%s)' % node
                  for node in self._parameters[:poly_arg]]
        result += self._parameters[poly_arg:]
        return ' '.join(result)
    ##############################################
    def _manage_controlled_sources(self, nodes):
        try:
            idx = self._nodes.index('POLY')
            if idx == 2:
                poly_arg = self._nodes[3]
                if poly_arg[0] == '(' and poly_arg[-1] == ')':
                    poly_arg = poly_arg[1:-1]
                try:
                    poly_arg = int(poly_arg)
                except TypeError as te:
                    raise TypeError('Not valid poly argument: %s' % poly_arg, te)
                self._nodes = self._nodes[:2]
                nodes = nodes[:2]
                if self._prefix in 'EG':
                    self._check_params(2)
                    values = self._voltage_controlled_nodes(poly_arg)
                    if self._prefix == 'E':
                        key = 'v'
                    else:
                        key = 'i'
                else:
                    self._check_params(1)
                    values = self._current_controlled_nodes(poly_arg)
                    if self._prefix == 'F':
                        key = 'v'
                    else:
                        key = 'i'
                poly_str = '{ POLY (%d) %s }' % (poly_arg, values)
                self._dict_parameters[key] = poly_str
                self._parameters.clear()
                self._name = self._prefix + self._name
                self._prefix = 'B'
                prefix_data = _prefix_cache[self._prefix]
                self.factory = prefix_data.single
                return nodes
            raise IndexError('Incorrect position of POLY: %r' % self)
        except ValueError:
            pass
        _correction = []
        correction = []
        for _node, node in zip(self._nodes, nodes):
            _values = _node.replace(',', ' ')
            try:
                values = node.replace(',', ' ')
            except AttributeError:
                values = str(node)
            if _values[0] == '(' and _values[-1] == ')':
                _values = _values[1: -1]
            if values[0] == '(' and values[-1] == ')':
                values = values[1: -1]
            _correction.extend(_values.split())
            correction.extend(values.split())
        self._parameters = correction[len(self._nodes):] + self._parameters
        self._nodes = _correction[:len(self._nodes)]
        parameters = self._parameters
        correction = correction[:len(self._nodes)]
        if self._prefix in 'EG':
            if len(correction) + len(parameters) == 5:
                parameters = correction[2:] + parameters
                self._nodes = _correction[:2]
                value = '{v(%s, %s) * %s}' % tuple(parameters)
                if self._prefix == 'E':
                    key = 'v'
                else:
                    key = 'i'
                self._dict_parameters[key] = value
                self._parameters.clear()
                self._name = self._prefix + self._name
                self._prefix = 'B'
                prefix_data = _prefix_cache[self._prefix]
                self.factory = prefix_data.single
        else:
            if len(correction) + len(parameters) == 4:
                parameters = correction[2:] + parameters
                self._nodes = _correction[:2]
                value = '{i(%s) * %s}' % tuple(parameters)
                if self._prefix == 'F':
                    key = 'v'
                else:
                    key = 'i'
                self._dict_parameters[key] = value
                self._parameters.clear()
                self._name = self._prefix + self._name
                self._prefix = 'B'
                prefix_data = _prefix_cache[self._prefix]
                self.factory = prefix_data.single
        return correction[:len(self._nodes)]
    ##############################################
    def build(self, circuit, ground=0):
        nodes = self.translate_ground_node(ground)
        if self._prefix != 'X':
            if self._prefix in ('EFGH'):
                nodes = self._manage_controlled_sources(nodes)
            args = nodes + self._parameters
        else:  # != Spice
            args = self._parameters + nodes
        factory = getattr(circuit, self.factory.__alias__)
        kwargs = self._dict_parameters
        message = ' '.join([str(x) for x in (self._prefix, self._name, args,
                                             self._dict_parameters)])
        self._logger.debug(message)
        return factory(self._name, *args, **kwargs)
####################################################################################################
class Line:
    """This class implements a line in the netlist."""
    _logger = _module_logger.getChild('Line')
    ##############################################
    def __init__(self, line, line_range, end_of_line_comment):
        self._end_of_line_comment = end_of_line_comment
        text, comment, self._is_comment = self._split_comment(line)
        self._text = text
        self._comment = comment
        self._line_range = line_range
    ##############################################
    def __repr__(self):
        return '{0._line_range}: {0._text} // {0._comment}'.format(self)
    ##############################################
    def __str__(self):
        return self._text
    ##############################################
    @property
    def comment(self):
        return self._comment
    @property
    def is_comment(self):
        return self._is_comment
    ##############################################
    def _split_comment(self, line):
        line = str(line)
        if line.startswith('*'):
            is_comment = True
            text = ''
            comment = line[1:].strip()
        else:
            is_comment = False
            # remove end of line comment
            location = -1
            for marker in self._end_of_line_comment:
                _location = line.find(marker)
                if _location != -1:
                    if location == -1:
                        location = _location
                    else:
                        location = min(_location, location)
            if location != -1:
                text = line[:location].strip()
                comment = line[location:].strip()
            else:
                text = line
                comment = ''
        return text, comment, is_comment
    ##############################################
    def append(self, line):
        text, comment, is_comment = self._split_comment(line)
        if text:
            if not self._text.endswith(' ') or text.startswith(' '):
                self._text += ' '
            self._text += text
        if comment:
            self._comment += ' // ' + comment
        _slice = self._line_range
        self._line_range = slice(_slice.start, _slice.stop + 1)
    ##############################################
    def lower_case_statement(self, statement):
        """Lower case the statement"""
        # statement without . prefix
        if self._text:
            lower_statement = statement.lower()
            _slice = slice(1, len(statement) + 1)
            _statement = self._text[_slice]
            if _statement.lower() == lower_statement:
                self._text = '.' + lower_statement + self._text[_slice.stop:]
    ##############################################
    def right_of(self, text):
        return self._text[len(text):].strip()
    ##############################################
    def read_words(self, start_location, number_of_words):
        """Read a fixed number of words separated by space."""
        words = []
        stop_location = None
        line_str = self._text
        number_of_words_read = 0
        while number_of_words_read < number_of_words:  # and start_location < len(line_str)
            if line_str[start_location] == '{':
                stop_location = line_str.find('}', start_location)
                if stop_location > start_location:
                    stop_location += 1
            else:
                stop_location = line_str.find(' ', start_location)
            if stop_location == -1:
                stop_location = None  # read until end
            word = line_str[start_location:stop_location].strip()
            if word:
                number_of_words_read += 1
                words.append(word)
            if stop_location is None:  # we should stop
                if number_of_words_read != number_of_words:
                    template = 'Bad element line, looking for word {}/{}:' + os.linesep
                    message = (template.format(number_of_words_read, number_of_words) +
                               line_str + os.linesep +
                               ' ' * start_location + '^')
                    self._logger.warning(message)
                    raise ParseError(message)
            else:
                if start_location < stop_location:
                    start_location = stop_location
                else:  # we have read a space
                    start_location += 1
        return words, stop_location
    ##############################################
    def split_words(self, start_location, until=None):
        stop_location = None
        line_str = self._text
        if until is not None:
            location = line_str.find(until, start_location)
            if location != -1:
                stop_location = location
                location = line_str.rfind(' ', start_location, stop_location)
                if location != -1:
                    stop_location = location
                else:
                    raise NameError('Bad element line, missing key? ' + line_str)
        line_str = line_str[start_location:stop_location]
        words = [x for x in line_str.split(' ') if x]
        result = []
        expression = 0
        begin_idx = 0
        for idx, word in enumerate(words):
            if expression == 0:
                begin_idx = idx
            expression += word.count('{') - word.count('}')
            if expression == 0:
                if begin_idx < idx:
                    result.append(' '.join(words[begin_idx:idx + 1]))
                else:
                    result.append(word)
        return result, stop_location
    ##############################################
    @staticmethod
    def get_kwarg(text):
        dict_parameters = {}
        parts = []
        for part in text.split():
            if '=' in part and part != '=':
                left, right = [x for x in part.split('=')]
                parts.append(left)
                parts.append('=')
                if right:
                    parts.append(right)
            else:
                parts.append(part)
        i = 0
        i_stop = len(parts)
        while i < i_stop:
            if i + 1 < i_stop and parts[i + 1] == '=':
                key, value = parts[i], parts[i + 2]
                dict_parameters[key] = value
                i += 3
            else:
                raise ParseError("Bad kwarg: {}".format(text))
        return dict_parameters
    ##############################################
    @staticmethod
    def _partition(text):
        parts = []
        values = text.replace(',', ' ')
        for part in values.split():
            if '=' in part and part != '=':
                left, right = [x for x in part.split('=')]
                parts.append(left)
                parts.append('=')
                if right:
                    parts.append(right)
            else:
                parts.append(part)
        return parts
    ##############################################
    @staticmethod
    def _partition_parentheses(text):
        p = regex.compile(r'\(([^\(\)]|(?R))*?\)')
        parts = []
        previous_start = 0
        for m in regex.finditer(p, text):
            parts.extend(Line._partition(text[previous_start:m.start()]))
            parts.append(m.group())
            previous_start = m.end()
        parts.extend(Line._partition(text[previous_start:]))
        return parts
    ##############################################
    @staticmethod
    def _partition_braces(text):
        p = regex.compile(r'\{([^\{\}]|(?R))*?\}')
        parts = []
        previous_start = 0
        for m in regex.finditer(p, text):
            parts.extend(Line._partition_parentheses(text[previous_start:m.start()]))
            parts.append(m.group())
            previous_start = m.end()
        parts.extend(Line._partition_parentheses(text[previous_start:]))
        return parts
    ##############################################
    @staticmethod
    def _check_parameters(parts):
        parameters = []
        dict_parameters = {}
        i = 0
        i_stop = len(parts)
        while i < i_stop:
            if i + 1 < i_stop and parts[i + 1] == '=':
                key, value = parts[i], parts[i + 2]
                dict_parameters[key] = value
                i += 3
            else:
                parameters.append(parts[i])
                i += 1
        return parameters, dict_parameters
    ##############################################
    def split_keyword(self, keyword):
        """Split the line according to the following pattern::
            keyword parameter1 parameter2 ( key1=value1 key2=value2 )
        Return the list of parameters and the dictionary.
        The parenthesis can be omitted.
        """
        text = self.right_of(keyword)
        p = regex.compile(r'\(([^\(\)]|(?R))*?\)')
        b = regex.compile(r'\{([^\{\}]|(?R))*?\}')
        parts = []
        mp = regex.search(p, text)
        mb = regex.search(b, text)
        if mb is not None:
            if mp is not None:
                if (mb.start() > mp.start()) and (mb.end() < mp.end()):
                    parts.extend(Line._partition(text[:mp.start()]))
                    parts.extend(Line._partition_braces(mp.group()[1:-1]))
                elif (mb.start() < mp.start()) and (mb.end() > mp.end()):
                    parts.extend(Line._partition_braces(text))
                else:
                    raise ValueError("Incorrect format {}".format(text))
            else:
                parts.extend(Line._partition_braces(text))
        else:
            if mp is not None:
                parts.extend(Line._partition(text[:mp.start()]))
                parts.extend(Line._partition(mp.group()[1:-1]))
            else:
                parts.extend(Line._partition(text))
        return Line._check_parameters(parts)
    ##############################################
    def split_element(self, prefix):
        """Split the line according to the following pattern::
            keyword parameter1 parameter2 ... key1=value1 key2=value2 ...
        Return the list of parameters and the dictionary.
        """
        # Fixme: cf. get_kwarg
        parameters = []
        dict_parameters = {}
        text = self.right_of(prefix)
        parts = Line._partition_braces(text)
        return Line._check_parameters(parts)
####################################################################################################
class SpiceParser:
    """This class parse a Spice netlist file and build a syntax tree.
    Public Attributes:
      :attr:`circuit`
      :attr:`models`
      :attr:`subcircuits`
    """
    _logger = _module_logger.getChild('SpiceParser')
    ##############################################
    def __init__(self, path=None, source=None, end_of_line_comment=('$', '//', ';')):
        # Fixme: empty source
        if path is not None:
            with open(str(path), 'r') as fh:
                raw_lines = fh.readlines()  # Fixme: cf. jmgc
        elif source is not None:
            raw_lines = source.split(os.linesep)
        else:
            raise ValueError
        self._end_of_line_comment = end_of_line_comment
        lines = self._merge_lines(raw_lines)
        self._title = None
        self._statements = self._parse(lines)
    ##############################################
    def _merge_lines(self, raw_lines):
        """Merge broken lines and return a new list of lines.
        A line starting with "+" continues the preceding line.
        """
        lines = []
        current_line = None
        for line_index, line_string in enumerate(raw_lines):
            if line_string.startswith('+'):
                current_line.append(line_string[1:].strip('\r\n'))
            else:
                line_string = line_string.strip(' \t\r\n')
                if line_string:
                    _slice = slice(line_index, line_index + 1)
                    line = Line(line_string, _slice, self._end_of_line_comment)
                    lines.append(line)
                    # handle case with comment before line continuation
                    if not line_string.startswith('*'):
                        current_line = line
        return lines
    ##############################################
    @staticmethod
    def _check_models(circuit, available_models=set()):
        p_available_models = available_models.copy()
        p_available_models.update([model.name for model in circuit._models])
        for subcircuit in circuit._subcircuits:
            SpiceParser._check_models(subcircuit, p_available_models)
        for model in circuit._required_models:
            if model not in p_available_models:
                raise ValueError("model (%s) not available in (%s)" % (model, circuit.name))
    ##############################################
    @staticmethod
    def _sort_subcircuits(circuit, available_subcircuits=set()):
        p_available_subcircuits = available_subcircuits.copy()
        names = [subcircuit.name for subcircuit in circuit._subcircuits]
        p_available_subcircuits.update(names)
        dependencies = dict()
        for subcircuit in circuit._subcircuits:
            required = SpiceParser._sort_subcircuits(subcircuit, p_available_subcircuits)
            dependencies[subcircuit] = required
        for subcircuit in circuit._required_subcircuits:
            if subcircuit not in p_available_subcircuits:
                raise ValueError("subcircuit (%s) not available in (%s)" % (subcircuit, circuit.name))
        items = sorted(dependencies.items(), key=lambda item: len(item[1]))
        result = list()
        result_names = list()
        previous = len(items) + 1
        while 0 < len(items) < previous:
            previous = len(items)
            remove = list()
            for item in items:
                subckt, depends = item
                for name in depends:
                    if name not in result_names:
                        break
                else:
                    result.append(subckt)
                    result_names.append(subckt.name)
                    remove.append(item)
            for item in remove:
                items.remove(item)
        if len(items) > 0:
            raise ValueError("Crossed dependencies (%s)" % [(key.name, value) for key, value in items])
        circuit._subcircuits = result
        return circuit._required_subcircuits - set(names)
    ##############################################
    def _parse(self, lines):
        """Parse the lines and return a list of statements."""
        # The first line in the input file must be the title, which is the only comment line that does
        # not need any special character in the first place.
        #
        # The last line must be .end
        if len(lines) <= 1:
            raise NameError('Netlist is empty')
        # if lines[-1] != '.end':
        #     raise NameError('".end" is expected at the end of the netlist')
        circuit = CircuitStatement(lines[0])
        stack = []
        scope = circuit
        for line in lines[1:]:
            # print('>', repr(line))
            text = str(line)
            lower_case_text = text.lower()  # !
            if line.is_comment:
                scope.append(Comment(line))
            elif lower_case_text.startswith('.'):
                lower_case_text = lower_case_text[1:]
                if lower_case_text.startswith('subckt'):
                    stack.append(scope)
                    scope = SubCircuitStatement(line)
                elif lower_case_text.startswith('ends'):
                    parent = stack.pop()
                    parent.append_subcircuit(scope)
                    scope = parent
                elif lower_case_text.startswith('title'):
                    # override fist line
                    self._title = Title(line)
                    scope.append(self._title)
                elif lower_case_text.startswith('end'):
                    pass
                elif lower_case_text.startswith('model'):
                    model = Model(line)
                    scope.append_model(model)
                elif lower_case_text.startswith('include'):
                    include = Include(line)
                    scope.append(include)
                elif lower_case_text.startswith('param'):
                    param = Parameter(line)
                    scope.append_param(param)
                else:
                    # options param ...
                    # .global
                    # .lib filename libname
                    # .func .csparam .temp .if
                    # { expr } are allowed in .model lines and in device lines.
                    self._logger.warn('Parser ignored: {}'.format(line))
            else:
                try:
                    element = Element(line)
                    scope.append(element)
                    if hasattr(element, '_prefix') and (element._prefix == "X"):
                        name = element._parameters[0].lower()
                        scope._required_subcircuits.add(name)
                    elif hasattr(element, '_dict_parameters') and 'model' in element._dict_parameters:
                        name = element._dict_parameters['model'].lower()
                        scope._required_models.add(name)
                except ParseError:
                    pass
        SpiceParser._check_models(circuit)
        SpiceParser._sort_subcircuits(circuit)
        return circuit
    ##############################################
    @property
    def circuit(self):
        """Circuit statements."""
        return self._statements
    @property
    def models(self):
        """Models of the sub-circuit."""
        return self._statements.models
    @property
    def subcircuits(self):
        """Subcircuits of the sub-circuit."""
        return self._statements.subcircuits
    ##############################################
    def is_only_subcircuit(self):
        return bool(not self.circuit and self.subcircuits)
    ##############################################
    def is_only_model(self):
        return bool(not self.circuit and not self.subcircuits and self.models)
    ##############################################
    @staticmethod
    def _build_circuit(circuit, statements, ground):
        for statement in statements:
            if isinstance(statement, Include):
                circuit.include(str(statement))
        for statement in statements:
            if isinstance(statement, Element):
                statement.build(circuit, ground)
            elif isinstance(statement, Model):
                statement.build(circuit)
            elif isinstance(statement, SubCircuit):
                subcircuit = statement.build(ground)  # Fixme: ok ???
                circuit.subcircuit(subcircuit)
    ##############################################
    def build_circuit(self, ground=0):
        """Build a :class:`Circuit` instance.
        Use the *ground* parameter to specify the node which must be translated to 0 (SPICE ground node).
        """
        # circuit = Circuit(str(self._title))
        circuit = self.circuit.build(str(ground))
        return circuit
    ##############################################
    @staticmethod
    def netlist_to_python(netlist_name, statements, ground=0):
        source_code = ''
        for statement in statements:
            if isinstance(statement, Element):
                source_code += statement.to_python(netlist_name, ground)
            elif isinstance(statement, Include):
                pass
            elif isinstance(statement, Model):
                source_code += statement.to_python(netlist_name)
            elif isinstance(statement, SubCircuitStatement):
                source_code += statement.to_python(netlist_name)
            elif isinstance(statement, Include):
                source_code += statement.to_python(netlist_name)
        return source_code
    ##############################################
    def to_python_code(self, ground=0):
        ground = str(ground)
        source_code = ''
        if self.circuit:
            source_code += "circuit = Circuit('{}')".format(self._title) + os.linesep
        source_code += self.netlist_to_python('circuit', self._statements, ground)
        return source_code
</file>

<file path="PySpice/Spice/Parser.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
"""This module implements a partial SPICE netlist parser.
See the :command:`cir2py` tool for an example of usage of the parser.
It would be difficult to implement a full parser for Ngspice since the syntax is mainly contextual.
"""
####################################################################################################
import logging
import os
####################################################################################################
from .BasicElement import SubCircuitElement
from .ElementParameter import FlagParameter
from .Netlist import ElementParameterMetaClass, Circuit, SubCircuit
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class ParseError(NameError):
    pass
####################################################################################################
class PrefixData:
    """This class represents a device prefix."""
    ##############################################
    def __init__(self, prefix, classes):
        self.prefix = prefix
        self.classes = classes
        number_of_positionals_min = 1000
        number_of_positionals_max = 0
        has_optionals = False
        for element_class in classes:
            number_of_positionals = element_class.number_of_positional_parameters
            number_of_positionals_min = min(number_of_positionals_min, number_of_positionals)
            number_of_positionals_max = max(number_of_positionals_max, number_of_positionals)
            has_optionals = max(has_optionals, bool(element_class.optional_parameters))
        self.number_of_positionals_min = number_of_positionals_min
        self.number_of_positionals_max = number_of_positionals_max
        self.has_optionals = has_optionals
        self.multi_devices = len(classes) > 1
        self.has_variable_number_of_pins = prefix in ('Q', 'X') # NPinElement, Q has 3 to 4 pins
        if self.has_variable_number_of_pins:
            self.number_of_pins = None
        else:
            # Q and X are single
            self.number_of_pins = classes[0].number_of_pins
        self.has_flag = False
        for element_class in classes:
            for parameter in element_class.optional_parameters.values():
                if isinstance(parameter, FlagParameter):
                    self.has_flag = True
    ##############################################
    def __len__(self):
        return len(self.classes)
    ##############################################
    def __iter__(self):
        return iter(self.classes)
    ##############################################
    @property
    def single(self):
        if not self.multi_devices:
            return self.classes[0]
        else:
            raise NameError()
####################################################################################################
_prefix_cache = {}
for prefix, classes in ElementParameterMetaClass._classes.items():
    prefix_data = PrefixData(prefix, classes)
    _prefix_cache[prefix] = prefix_data
    _prefix_cache[prefix.lower()] = prefix_data
# for prefix_data in sorted(_prefix_cache.values(), key=lambda x: len(x)):
#     print(prefix_data.prefix,
#           len(prefix_data),
#           prefix_data.number_of_positionals_min, prefix_data.number_of_positionals_max,
#           prefix_data.has_optionals)
# Single:
# B 0 True
# D 1 True
# F 2 False
# G 1 False
# H 2 False
# I 1 False
# J 1 True
# K 3 False
# M 1 True
# S 2 False
# V 1 False
# W 3 False
# Z 1 True
# Two:
# E 0 1 False
# L 1 2 True
# Three:
# C 1 2 True
# R 1 2 True
# NPinElement:
# Q 1 1 True
# X 1 1 False
####################################################################################################
class Statement:
    """ This class implements a statement, in fact a line in a Spice netlist. """
    ##############################################
    def __init__(self, line, statement=None):
        self._line = line
        if statement is not None:
            self._line.lower_case_statement(statement)
    ##############################################
    def __repr__(self):
        return '{} {}'.format(self.__class__.__name__, repr(self._line))
    ##############################################
    def value_to_python(self, x):
        if x:
            if str(x)[0].isdigit():
                return str(x)
            else:
                return "'{}'".format(x)
        else:
            return ''
    ##############################################
    def values_to_python(self, values):
        return [self.value_to_python(x) for x in values]
    ##############################################
    def kwargs_to_python(self, kwargs):
        return ['{}={}'.format(key, self.value_to_python(value))
                for key, value in kwargs.items()]
    ##############################################
    def join_args(self, args):
        return ', '.join(args)
####################################################################################################
class Comment(Statement):
    pass
####################################################################################################
class Title(Statement):
    """ This class implements a title definition. """
    ##############################################
    def __init__(self, line):
        super().__init__(line, statement='title')
        self._title = self._line.right_of('.title')
    ##############################################
    def __str__(self):
        return self._title
    ##############################################
    def __repr__(self):
        return 'Title {}'.format(self._title)
####################################################################################################
class Lib(Statement):
    """ This class implements a library definition. """
    ##############################################
    def __init__(self, line):
        super().__init__(line, statement='lib')
        self._lib = self._line.right_of('.lib')
    ##############################################
    def __str__(self):
        return self._lib
    ##############################################
    def __repr__(self):
        return 'Lib {}'.format(self._lib)
    ##############################################
    def to_python(self, netlist_name):
        return '{}.lib({})'.format(netlist_name, self._lib) + os.linesep
####################################################################################################
class Include(Statement):
    """ This class implements a include definition. """
    ##############################################
    def __init__(self, line):
        super().__init__(line, statement='include')
        self._include = self._line.right_of('.include').strip('"')
    ##############################################
    def __str__(self):
        return self._include
    ##############################################
    def __repr__(self):
        return 'Include {}'.format(self._include)
    ##############################################
    def to_python(self, netlist_name):
        return '{}.include({})'.format(netlist_name, self._include) + os.linesep
####################################################################################################
class Model(Statement):
    """ This class implements a model definition.
    Spice syntax::
        .model mname type (pname1=pval1 pname2=pval2)
    """
    ##############################################
    def __init__(self, line):
        super().__init__(line, statement='model')
        text = line.right_of('.model').strip()
        import re
        mtch = re.match('\s*([^ \t]+)\s*([^ \t(]+)(.*)', text)
        self._name = mtch[1]
        self._model_type = mtch[2]
        params = mtch[3]
        params = params.strip('() ')
        self._parameters = Line.get_kwarg(params)
    ##############################################
    @property
    def name(self):
        """ Name of the model """
        return self._name
    ##############################################
    def __repr__(self):
        return 'Model {} {} {}'.format(self._name, self._model_type, self._parameters)
    ##############################################
    def to_python(self, netlist_name):
        args = self.values_to_python((self._name, self._model_type))
        kwargs = self.kwargs_to_python(self._parameters)
        return '{}.model({})'.format(netlist_name, self.join_args(args + kwargs)) + os.linesep
    ##############################################
    def build(self, circuit):
        circuit.model(self._name, self._model_type, **self._parameters)
####################################################################################################
class SubCircuitStatement(Statement):
    """ This class implements a sub-circuit definition.
    Spice syntax::
        .SUBCKT name node1 ... param1=value1 ...
    """
    ##############################################
    def __init__(self, line):
        super().__init__(line, statement='subckt')
        # Fixme
        parameters, dict_parameters = self._line.split_line('.subckt')
        self._name, self._nodes = parameters[0], parameters[1:]
        self._statements = []
    ##############################################
    @property
    def name(self):
        """ Name of the sub-circuit. """
        return self._name
    @property
    def nodes(self):
        """ Nodes of the sub-circuit. """
        return self._nodes
    ##############################################
    def __repr__(self):
        text = 'SubCircuit {} {}'.format(self._name, self._nodes) + os.linesep
        text += os.linesep.join(['  ' + repr(statement) for statement in self._statements])
        return text
    ##############################################
    def __iter__(self):
        """ Return an iterator on the statements. """
        return iter(self._statements)
    ##############################################
    def append(self, statement):
        """ Append a statement to the statement's list. """
        self._statements.append(statement)
    ##############################################
    def to_python(self, ground=0):
        subcircuit_name = 'subcircuit_' + self._name
        args = self.values_to_python([subcircuit_name] + self._nodes)
        source_code = ''
        source_code += '{} = SubCircuit({})'.format(subcircuit_name, self.join_args(args)) + os.linesep
        source_code += SpiceParser.netlist_to_python(subcircuit_name, self, ground)
        return source_code
    ##############################################
    def build(self, ground=0):
        subcircuit = SubCircuit(self._name, *self._nodes)
        SpiceParser._build_circuit(subcircuit, self._statements, ground)
        return subcircuit
####################################################################################################
class Element(Statement):
    """ This class implements an element definition.
    "{ expression }" are allowed in device line.
    """
    _logger = _module_logger.getChild('Element')
    ##############################################
    def __init__(self, line):
        super().__init__(line)
        line_str = str(line)
        # self._logger.debug(os.linesep + line_str)
        # Retrieve device prefix
        self._prefix = line_str[0]
        prefix_data = _prefix_cache[self._prefix]
        # Retrieve device name
        start_location = 1
        stop_location = line_str.find(' ')
        # Fixme: if stop_location == -1:
        self._name = line_str[start_location:stop_location]
        self._nodes = []
        self._parameters = []
        self._dict_parameters = {}
        # Read nodes
        if not prefix_data.has_variable_number_of_pins:
            number_of_pins = prefix_data.number_of_pins
            if number_of_pins:
                self._nodes, stop_location = self._line.read_words(stop_location, number_of_pins)
        else: # Q or X
            if prefix_data.prefix == 'Q':
                self._nodes, stop_location = self._line.read_words(stop_location, 3)
                # Fixme: optional node
            else: # X
                args, stop_location = self._line.split_words(stop_location, until='=')
                self._nodes = args[:-1]
                self._parameters.append(args[-1]) # model name
        # Read positionals
        number_of_positionals = prefix_data.number_of_positionals_min
        if number_of_positionals and stop_location is not None: # model is optional
            self._parameters, stop_location = self._line.read_words(stop_location, number_of_positionals)
        if prefix_data.multi_devices and stop_location is not None:
            remaining, stop_location = self._line.split_words(stop_location, until='=')
            self._parameters.extend(remaining)
        if prefix_data.prefix in ('V', 'I') and stop_location is not None:
            # merge remaining
            self._parameters[-1] += line_str[stop_location:]
        # Read optionals
        if prefix_data.has_optionals and stop_location is not None:
            kwargs, stop_location = self._line.split_words(stop_location)
            for kwarg in kwargs:
                try:
                    key, value = kwarg.split('=')
                    self._dict_parameters[key.lower()] = value
                except ValueError:
                    if kwarg in ('off',) and prefix_data.has_flag:
                        self._dict_parameters['off'] = True
                    else:
                        # Fixme: warning -> debug due to spam ...
                        self._logger.debug(line_str)
                        # raise NameError('Bad element line:', line_str)
        if prefix_data.multi_devices:
            for element_class in prefix_data:
                if len(self._parameters) == element_class.number_of_positional_parameters:
                    break
        else:
            element_class = prefix_data.single
        self.factory = element_class
        # Move positionals passed as kwarg
        to_delete = []
        for parameter in element_class.positional_parameters.values():
            if parameter.key_parameter:
                i = parameter.position
                self._dict_parameters[parameter.attribute_name] = self._parameters[i]
                to_delete.append(i)
        for i in to_delete:
            del self._parameters[i]
        # self._logger.debug(os.linesep + self.__repr__())
    ##############################################
    @property
    def name(self):
        """ Name of the element """
        return self._name
    ##############################################
    def __repr__(self):
        return 'Element {0._prefix} {0._name} {0._nodes} {0._parameters} {0._dict_parameters}'.format(self)
    ##############################################
    def translate_ground_node(self, ground):
        nodes = []
        for node in self._nodes:
            if str(node) == str(ground):
                node = 0
            nodes.append(node)
        return nodes
    ##############################################
    def to_python(self, netlist_name, ground=0):
        nodes = self.translate_ground_node(ground)
        args = [self._name]
        if self._prefix != 'X':
            args += nodes + self._parameters
        else: # != Spice
            args += self._parameters + nodes
        args = self.values_to_python(args)
        kwargs = self.kwargs_to_python(self._dict_parameters)
        return '{}.{}({})'.format(netlist_name, self._prefix, self.join_args(args + kwargs)) + os.linesep
    ##############################################
    def build(self, circuit, ground=0):
        factory = getattr(circuit, self.factory.ALIAS)
        nodes = self.translate_ground_node(ground)
        if self._prefix != 'X':
            args = nodes + self._parameters
        else: # != Spice
            args = self._parameters + nodes
        kwargs = self._dict_parameters
        if self._logger.isEnabledFor(logging.DEBUG):
            message = ' '.join([str(x) for x in (self._prefix, self._name, nodes,
                                                 self._parameters, self._dict_parameters)])
            self._logger.debug(message)
        factory(self._name, *args, **kwargs)
####################################################################################################
class Line:
    """ This class implements a line in the netlist. """
    _logger = _module_logger.getChild('Element')
    ##############################################
    def __init__(self, line, line_range, end_of_line_comment):
        self._end_of_line_comment = end_of_line_comment
        text, comment, self._is_comment = self._split_comment(line)
        self._text = text
        self._comment = comment
        self._line_range = line_range
    ##############################################
    def __repr__(self):
        return '{0._line_range}: {0._text} // {0._comment}'.format(self)
    ##############################################
    def __str__(self):
        return self._text
    ##############################################
    @property
    def comment(self):
        return self._comment
    @property
    def is_comment(self):
        return self._is_comment
    ##############################################
    def _split_comment(self, line):
        line = str(line)
        if line.startswith('*'):
            is_comment = True
            text = ''
            comment = line[1:].strip()
        else:
            is_comment = False
            # remove end of line comment
            location = -1
            for marker in self._end_of_line_comment:
                _location = line.find(marker)
                if _location != -1:
                    if location == -1:
                        location = _location
                    else:
                        location = min(_location, location)
            if location != -1:
                text = line[:location].strip()
                comment = line[location:].strip()
            else:
                text = line
                comment = ''
        return text, comment, is_comment
    ##############################################
    def append(self, line):
        text, comment, is_comment = self._split_comment(line)
        if text:
            if not self._text.endswith(' ') or text.startswith(' '):
                self._text += ' '
            self._text += text
        if comment:
            self._comment += ' // ' + comment
        _slice = self._line_range
        self._line_range = slice(_slice.start, _slice.stop + 1)
    ##############################################
    def lower_case_statement(self, statement):
        """Lower case the statement"""
        # statement without . prefix
        if self._text:
            lower_statement = statement.lower()
            _slice = slice(1, len(statement) + 1)
            _statement = self._text[_slice]
            if _statement.lower() == lower_statement:
                self._text = '.' + lower_statement + self._text[_slice.stop:]
    ##############################################
    def right_of(self, text):
        return self._text[len(text):].strip()
    ##############################################
    def read_words(self, start_location, number_of_words):
        """Read a fixed number of words separated by space."""
        words = []
        stop_location = None
        line_str = self._text
        number_of_words_read = 0
        while number_of_words_read < number_of_words: # and start_location < len(line_str)
            stop_location = line_str.find(' ', start_location)
            if stop_location == -1:
                stop_location = None # read until end
            word = line_str[start_location:stop_location].strip()
            if word:
                number_of_words_read += 1
                words.append(word)
            if stop_location is None: # we should stop
                if number_of_words_read != number_of_words:
                    template = 'Bad element line, looking for word {}/{}:' + os.linesep
                    message = (template.format(number_of_words_read, number_of_words) +
                               line_str + os.linesep +
                               ' '*start_location + '^')
                    self._logger.warning(message)
                    raise ParseError(message)
            else:
                if start_location < stop_location:
                    start_location = stop_location
                else: # we have read a space
                    start_location += 1
        return words, stop_location
    ##############################################
    def split_words(self, start_location, until=None):
        stop_location = None
        line_str = self._text
        if until is not None:
            location = line_str.find(until, start_location)
            if location != -1:
                stop_location = location
                location = line_str.rfind(' ', start_location, stop_location)
                if location != -1:
                    stop_location = location
                else:
                    raise NameError('Bad element line, missing key? ' + line_str)
        line_str = line_str[start_location:stop_location]
        words = [x for x in line_str.split(' ') if x]
        return words, stop_location
    ##############################################
    @staticmethod
    def get_kwarg(text):
        dict_parameters = {}
        parts = []
        for part in text.split():
            if '=' in part and part != '=':
                left, right = [x for x in part.split('=')]
                parts.append(left)
                parts.append('=')
                if right:
                    parts.append(right)
            else:
                parts.append(part)
        i = 0
        i_stop = len(parts)
        while i < i_stop:
            if i + 1 < i_stop and parts[i + 1] == '=':
                key, value = parts[i], parts[i + 2]
                dict_parameters[key] = value
                i += 3
            else:
                raise ParseError("Bad kwarg: {}".format(text))
        return dict_parameters
    ##############################################
    def split_line(self, keyword):
        """Split the line according to the following pattern::
            keyword parameter1 parameter2 ... key1=value1 key2=value2 ...
        Return the list of parameters and the dictionary.
        """
        # Fixme: cf. get_kwarg
        parameters = []
        dict_parameters = {}
        text = self.right_of(keyword)
        parts = []
        for part in text.split():
            if '=' in part and part != '=':
                left, right = [x for x in part.split('=')]
                parts.append(left)
                parts.append('=')
                if right:
                    parts.append(right)
            else:
                parts.append(part)
        i = 0
        i_stop = len(parts)
        while i < i_stop:
            if i + 1 < i_stop and parts[i + 1] == '=':
                key, value = parts[i], parts[i + 2]
                dict_parameters[key] = value
                i += 3
            else:
                parameters.append(parts[i])
                i += 1
        return parameters, dict_parameters
####################################################################################################
class SpiceParser:
    """ This class parse a Spice netlist file and build a syntax tree.
    Public Attributes:
      :attr:`circuit`
      :attr:`models`
      :attr:`subcircuits`
      :attr:`incl_libs`
    """
    _logger = _module_logger.getChild('SpiceParser')
    ##############################################
    def __init__(self, path=None, source=None, end_of_line_comment=('$', '//', ';'), recurse=False, section=None):
        # Fixme: empty source
        self._path = path  # For use by _parse() when recursing through files.
        if path is not None:
            with open(str(path), 'r') as f:
                raw_lines = f.readlines()
        elif source is not None:
            raw_lines = source.split(os.linesep)
        else:
            raise ValueError
        self._end_of_line_comment = end_of_line_comment
        lines = self._merge_lines(raw_lines)
        self._title = None
        self._statements = self._parse(lines=lines, recurse=recurse, section=section)
        self._find_sections()
    ##############################################
    def _merge_lines(self, raw_lines):
        """Merge broken lines and return a new list of lines.
        A line starting with "+" continues the preceding line.
        """
        lines = []
        current_line = None
        for line_index, line_string in enumerate(raw_lines):
            line_string = line_string.lstrip(' ')
            if line_string.startswith('+'):
                current_line.append(line_string[1:].strip('\r\n'))
            else:
                line_string = line_string.strip('\r\n')
                if line_string:
                    _slice = slice(line_index, line_index +1)
                    line = Line(line_string, _slice, self._end_of_line_comment)
                    lines.append(line)
                    # handle case with comment before line continuation
                    if not line_string.startswith('*'):
                        current_line = line
        return lines
    ##############################################
    def _parse(self, lines, recurse=False, section=None):
        """ Parse the lines and return a list of statements. """
        # The first line in the input file must be the title, which is the only comment line that does
        # not need any special character in the first place.
        #
        # The last line must be .end
        if len(lines) <= 1:
            self._logger.warning('Empty Spice file: {self._path}'.format(**locals()))
            # raise NameError('Netlist is empty')
        # if lines[-1] != '.end':
        #     raise NameError('".end" is expected at the end of the netlist')
        title_statement = '.title '
        self._title = str(lines[0])
        if self._title.startswith(title_statement):
            self._title = self._title[len(title_statement):]
        # SUBCKT and MODEL files often start with their commands as the
        # first line so they'll parse incorrectly if that line is removed.
        # For everything else, assume the first line is a TITLE line and
        # remove it.
        if str(lines[0]).startswith(('.model', '.subckt')):
            start_index = 0
        else:
            start_index = 1
        statements = []
        skip_lines = [False]  # True on top of stack means skip lines.
        sub_circuit = None
        scope = statements
        self.incl_libs = []  # Libraries found during recursive descent into includes.
        for line in lines[start_index:]:
            # print('>', repr(line))
            text = str(line)
            lower_case_text = text.lower() # !
            if skip_lines[-1]:
                if lower_case_text.startswith('.endl'):
                    skip_lines.pop()
            elif line.is_comment:
                scope.append(Comment(line))
            elif lower_case_text.startswith('.'):
                lower_case_text = lower_case_text[1:]
                if lower_case_text.startswith('subckt'):
                    sub_circuit = SubCircuitStatement(line)
                    statements.append(sub_circuit)
                    scope = sub_circuit
                elif lower_case_text.startswith('ends'):
                    sub_circuit = None
                    scope = statements
                elif lower_case_text.startswith('title'):
                    # override first line
                    self._title = Title(line)
                    scope.append(self._title)
                elif lower_case_text.startswith('end'):
                    pass
                elif lower_case_text.startswith('model'):
                    model = Model(line)
                    scope.append(model)
                elif lower_case_text.startswith('include'):
                    incl = Include(line)
                    scope.append(incl)
                    if recurse:
                        from .Library import SpiceLibrary
                        incl_path = os.path.join(str(self._path.directory_part()), str(incl))
                        self.incl_libs.append(SpiceLibrary(root_path=incl_path, recurse=recurse))
                elif lower_case_text.startswith('lib'):
                    lib = Lib(line)
                    if section and str(lib) != section.lower():
                        # If the .lib statement is only followed by the name of a section,
                        # then skip any lines in a library section whose name does not match
                        # the library section argument.
                        skip_lines.append(True)
                    else:
                        scope.append(lib)
                else:
                    # options param ...
                    # .global
                    # .lib filename libname
                    # .param
                    # .func .csparam .temp .if
                    # { expr } are allowed in .model lines and in device lines.
                    # self._logger.warning('Parser ignored: {}'.format(line))
                    pass
            else:
                try:
                    element = Element(line)
                    scope.append(element)
                except ParseError:
                    self._logger.warning('Parse error on:\n{}'.format(line))
        return statements
    ##############################################
    def _find_sections(self):
        """ Look for model, sub-circuit and circuit definitions in the statement list. """
        self.circuit = None
        self.subcircuits = []
        self.models = []
        for statement in self._statements:
            if isinstance(statement, Title):
                if self.circuit is None:
                    self.circuit = statement
                else:
                    raise NameError('More than one title')
            elif isinstance(statement, SubCircuitStatement):
                self.subcircuits.append(statement)
            elif isinstance(statement, Model):
                self.models.append(statement)
    ##############################################
    def is_only_subcircuit(self):
        return bool(not self.circuit and self.subcircuits)
    ##############################################
    def is_only_model(self):
        return bool(not self.circuit and not self.subcircuits and self.models)
    ##############################################
    @staticmethod
    def _build_circuit(circuit, statements, ground):
        for statement in statements:
            if isinstance(statement, Include):
                circuit.include(str(statement))
        for statement in statements:
            if isinstance(statement, Element):
                statement.build(circuit, ground)
            elif isinstance(statement, Model):
                statement.build(circuit)
            elif isinstance(statement, SubCircuit):
                subcircuit = statement.build(ground) # Fixme: ok ???
                circuit.subcircuit(subcircuit)
    ##############################################
    def build_circuit(self, ground=0):
        """Build a :class:`Circuit` instance.
        Use the *ground* parameter to specify the node which must be translated to 0 (SPICE ground node).
        """
        circuit = Circuit(str(self._title))
        self._build_circuit(circuit, self._statements, ground)
        return circuit
    ##############################################
    @staticmethod
    def netlist_to_python(netlist_name, statements, ground=0):
        source_code = ''
        for statement in statements:
            if isinstance(statement, Element):
                source_code += statement.to_python(netlist_name, ground)
            elif isinstance(statement, Include):
                pass
            elif isinstance(statement, Model):
                source_code += statement.to_python(netlist_name)
            elif isinstance(statement, SubCircuitStatement):
                source_code += statement.to_python(netlist_name)
            elif isinstance(statement, Include):
                source_code += statement.to_python(netlist_name)
        return source_code
    ##############################################
    def to_python_code(self, ground=0):
        ground = str(ground)
        source_code = ''
        if self.circuit:
            source_code += "circuit = Circuit('{}')".format(self._title) + os.linesep
        source_code += self.netlist_to_python('circuit', self._statements, ground)
        return source_code
</file>

<file path="PySpice/Spice/RawFile.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
import os
####################################################################################################
"""This module provide tools to read raw output.
"""
####################################################################################################
from PySpice.Unit import u_Degree, u_V, u_A, u_s, u_Hz
####################################################################################################
import logging
import numpy as np
####################################################################################################
from PySpice.Probe.WaveForm import (OperatingPoint, SensitivityAnalysis,
                                    DcAnalysis, AcAnalysis, TransientAnalysis,
                                    WaveForm)
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class VariableAbc:
    """This class implements a variable or probe in a SPICE simulation output.
    Public Attributes:
      :attr:`index`
        index in the array
      :attr:`name`
      :attr:`unit`
    """
    ##############################################
    def __init__(self, index, name, unit):
        # Fixme: self._ ?
        self._index = int(index)
        self.name = str(name)
        self._unit = unit # could be guessed from name also for voltage node and branch current
        self.data = None
    ##############################################
    @property
    def index(self):
        return self._index
    # @property
    # def name(self):
    #     return self._name
    # @name.setter
    # def name(self, value):
    #     self._name = value
    ##############################################
    def __repr__(self):
        return 'variable[{0._index}]: {0.name} [{0._unit}]'.format(self)
    ##############################################
    def is_voltage_node(self):
        raise NotImplementedError
    ##############################################
    def is_branch_current(self):
        raise NotImplementedError
    ##############################################
    @property
    def is_interval_parameter(self):
        return self.name.startswith('@') # Fixme: Xyce ???
    ##############################################
    @staticmethod
    def to_voltage_name(node):
        return 'v({})'.format(node)
    ##############################################
    @staticmethod
    def to_branch_name(element):
        return 'i({})'.format(element)
    ##############################################
    def fix_case(self, element_translation, node_translation):
        """ Update the name to the right case. """
        if self.is_branch_current():
            if self.simplified_name in element_translation:
                self.name = self.to_branch_name(element_translation[self.simplified_name])
        elif self.is_voltage_node():
            if self.simplified_name in node_translation:
                self.name = self.to_voltage_name(node_translation[self.simplified_name])
    ##############################################
    @property
    def simplified_name(self):
        raise NotImplementedError
    ##############################################
    def to_waveform(self, abscissa=None, to_real=False, to_float=False):
        """ Return a :obj:`PySpice.Probe.WaveForm` instance. """
        data = self.data
        if to_real:
            data = data.real
        # Fixme: else UnitValue instead of UnitValues
        # if to_float:
        #     data = float(data[0])
        if self._unit is not None:
            return WaveForm.from_unit_values(self.simplified_name, self._unit(data), abscissa=abscissa)
        else:
            return WaveForm.from_array(self.simplified_name, data, abscissa=abscissa)
####################################################################################################
class RawFileAbc:
    """ This class parse the stdout of ngspice and the raw data output.
    """
    _logger = _module_logger.getChild('RawFileAbc')
    ##############################################
    @property
    def simulation(self):
        if self._simulation is not None:
            return self._simulation
        else:
            raise NameError('Simulation is undefined')
    @simulation.setter
    def simulation(self, value):
        self._simulation = value
    ##############################################
    @property
    def circuit(self):
        return self._simulation.circuit
    ##############################################
    _name_to_unit = {
        'time': u_s,
        'voltage': u_V,
        'current': u_A,
        'frequency': u_Hz,
    }
    ##############################################
    def _read_line(self, header_line_iterator):
        """ Return the next line """
        # Fixme: self._header_line_iterator, etc.
        line = None
        while not line:
            line = next(header_line_iterator)
        return line.decode('utf-8')
    ##############################################
    def _read_header_line(self, header_line_iterator, head_line):
        """ Read an header line and check it starts with *head_line*. """
        line = self._read_line(header_line_iterator)
        self._logger.debug(line)
        if line.startswith(head_line):
            return line
        else:
            raise NameError("Unexpected line: %s" % (line))
    ##############################################
    def _read_header_field_line(self, header_line_iterator, expected_label, has_value=True):
        """ Read an header line and check it starts with *expected_label*.
        Return the values next to the label if the flag *has_value* is set.
        """
        line = self._read_line(header_line_iterator)
        self._logger.debug(line)
        if has_value:
            # a title can have ': ' after 'title: '
            location = line.find(': ') # first occurence
            label, value = line[:location], line[location+2:]
        else:
            label = line[:-1]
        if label != expected_label:
            raise NameError("Expected label %s instead of %s" % (expected_label, label))
        if has_value:
            return value.strip()
    ##############################################
    def _read_temperature_line(self, header_line_iterator):
        # Doing analysis at TEMP = 25.000000 and TNOM = 25.000000
        line = self._read_header_line(header_line_iterator, 'Doing analysis at TEMP')
        pattern1 = 'TEMP = '
        pattern2 = ' and TNOM = '
        pos1 = line.find(pattern1)
        pos2 = line.find(pattern2)
        if pos1 != -1 and pos2 != -1:
            part1 = line[pos1+len(pattern1):pos2]
            part2 = line[pos2+len(pattern2):].strip()
            temperature = u_Degree(float(part1))
            nominal_temperature = u_Degree(float(part2))
        else:
            temperature = None
            nominal_temperature = None
        return temperature, nominal_temperature
    ##############################################
    def _read_header_variables(self, header_line_iterator):
        self.variables = {}
        for i in range(self.number_of_variables):
            line = (next(header_line_iterator)).decode('utf-8')
            self._logger.debug(line)
            items = [x.strip() for x in line.split('\t') if x]
            # 0 frequency frequency grid=3
            index, name, unit = items[:3]
            #  unit = time, voltage, current
            unit = self._name_to_unit[unit] # convert to Unit
            self.variables[name] = self._variable_cls(index, name, unit)
        # self._read_header_field_line(header_line_iterator, 'Binary', has_value=False)
    ##############################################
    def _read_variable_data(self, raw_data):
        """ Read the raw data and set the variable values. """
        if self.flags == 'real':
            number_of_columns = self.number_of_variables
        elif self.flags == 'complex':
            number_of_columns = 2*self.number_of_variables
        else:
            raise NotImplementedError
        input_data = np.fromstring(raw_data, count=number_of_columns*self.number_of_points, dtype='f8')
        input_data = input_data.reshape((self.number_of_points, number_of_columns))
        input_data = input_data.transpose()
        # np.savetxt('raw.txt', input_data)
        if self.flags == 'complex':
            raw_data = input_data
            input_data = np.array(raw_data[0::2], dtype='complex128')
            input_data.imag = raw_data[1::2]
        for variable in self.variables.values():
            variable.data = input_data[variable.index]
    ##############################################
    def nodes(self, to_float=False, abscissa=None):
        return [variable.to_waveform(abscissa, to_float=to_float)
                for variable in self.variables.values()
                if variable.is_voltage_node()]
    ##############################################
    def branches(self, to_float=False, abscissa=None):
        return [variable.to_waveform(abscissa, to_float=to_float)
                for variable in self.variables.values()
                if variable.is_branch_current()]
    ##############################################
    def internal_parameters(self, to_float=False, abscissa=None):
        return [variable.to_waveform(abscissa, to_float=to_float)
                for variable in self.variables.values()
                if variable.is_interval_parameter]
    ##############################################
    def elements(self, abscissa=None):
        return [variable.to_waveform(abscissa, to_float=True)
                for variable in self.variables.values()]
    ##############################################
    def to_analysis(self):
        self.fix_case()
        if self.plot_name == 'Operating Point':
            return self._to_operating_point_analysis()
        elif self.plot_name == 'Sensitivity Analysis':
            return self._to_sensitivity_analysis()
        elif self.plot_name == 'DC transfer characteristic':
            return self._to_dc_analysis()
        elif self.plot_name == 'AC Analysis':
            return self._to_ac_analysis()
        elif self.plot_name == 'Transient Analysis':
            return self._to_transient_analysis()
        else:
            raise NotImplementedError("Unsupported plot name {}".format(self.plot_name))
    ##############################################
    def _to_operating_point_analysis(self):
        return OperatingPoint(
            simulation=self.simulation,
            nodes=self.nodes(to_float=True),
            branches=self.branches(to_float=True),
        )
    ##############################################
    def _to_sensitivity_analysis(self):
        # Fixme: test .SENS I (VTEST)
        # Fixme: separate v(vinput), analysis.R2.m
        return SensitivityAnalysis(
            simulation=self.simulation,
            elements=self.elements(),
        )
    ##############################################
    def _to_dc_analysis(self, sweep_variable):
        sweep = sweep_variable.to_waveform()
        return DcAnalysis(
            simulation=self.simulation,
            sweep=sweep,
            nodes=self.nodes(),
            branches=self.branches(),
            internal_parameters=self.internal_parameters(),
        )
    ##############################################
    def _to_ac_analysis(self):
        frequency = self.variables['frequency'].to_waveform(to_real=True)
        return AcAnalysis(
            simulation=self.simulation,
            frequency=frequency,
            nodes=self.nodes(),
            branches=self.branches(),
            internal_parameters=self.internal_parameters(),
        )
    ##############################################
    def _to_transient_analysis(self):
        time = self.variables['time'].to_waveform(to_real=True)
        return TransientAnalysis(
            simulation=self.simulation,
            time=time,
            nodes=self.nodes(abscissa=time),
            branches=self.branches(abscissa=time),
            internal_parameters=self.internal_parameters(),
        )
</file>

<file path="PySpice/Spice/Simulation.py">
###################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
"""This modules implements classes to perform simulations.
"""
####################################################################################################
import logging
import os
####################################################################################################
from ..Config import ConfigInstall
from ..Tools.StringTools import join_list, join_dict, str_spice
from ..Unit import Unit, as_V, as_A, as_s, as_Hz, as_Degree, u_Degree
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class AnalysisParameters:
    """Base class for analysis parameters"""
    ANALYSIS_NAME = None
    ##############################################
    @property
    def analysis_name(self):
        return self.ANALYSIS_NAME
    ##############################################
    def to_list(self):
        return ()
    ##############################################
    def __str__(self):
        return '.{0.analysis_name} {1}'.format(self, join_list(self.to_list()))
####################################################################################################
class OperatingPointAnalysisParameters(AnalysisParameters):
    """This class defines analysis parameters for operating point analysis."""
    ANALYSIS_NAME = 'op'
####################################################################################################
class DcSensitivityAnalysisParameters(AnalysisParameters):
    """This class defines analysis parameters for DC sensitivity analysis."""
    ANALYSIS_NAME = 'sens'
    ##############################################
    def __init__(self, output_variable):
        self._output_variable = output_variable
    ##############################################
    @property
    def output_variable(self):
        return self._output_variable
    ##############################################
    def to_list(self):
        return (self._output_variable,)
####################################################################################################
class AcSensitivityAnalysisParameters(AnalysisParameters):
    """This class defines analysis parameters for AC sensitivity analysis."""
    ANALYSIS_NAME = 'sens'
    ##############################################
    def __init__(self, output_variable, variation, number_of_points, start_frequency, stop_frequency):
        if variation not in ('dec', 'oct', 'lin'):
            raise ValueError("Incorrect variation type")
        self._output_variable = output_variable
        self._variation = variation
        self._number_of_points = number_of_points
        self._start_frequency = as_Hz(start_frequency)
        self._stop_frequency = as_Hz(stop_frequency)
    ##############################################
    @property
    def output_variable(self):
        return self._output_variable
    @property
    def variation(self):
        return self._variation
    @property
    def number_of_points(self):
        return self._number_of_points
    @property
    def start_frequency(self):
        return self._start_frequency
    @property
    def stop_frequency(self):
        return self._stop_frequency
    ##############################################
    def to_list(self):
        return (
            self._output_variable,
            self._variation,
            self._number_of_points,
            self._start_frequency,
            self._stop_frequency
        )
####################################################################################################
class DCAnalysisParameters(AnalysisParameters):
    """This class defines analysis parameters for DC analysis."""
    ANALYSIS_NAME = 'dc'
    ##############################################
    def __init__(self, **kwargs):
        self._parameters = []
        for variable, value_slice in kwargs.items():
            variable_lower = variable.lower()
            if variable_lower[0] in ('v', 'i', 'r') or variable_lower == 'temp':
                self._parameters += [variable, value_slice.start, value_slice.stop, value_slice.step]
            else:
                raise NameError('Sweep variable must be a voltage/current source, '
                                'a resistor or the circuit temperature')
    ##############################################
    @property
    def parameters(self):
        return self._parameters
    ##############################################
    def to_list(self):
        return self._parameters
####################################################################################################
class ACAnalysisParameters(AnalysisParameters):
    """This class defines analysis parameters for AC analysis."""
    ANALYSIS_NAME = 'ac'
    ##############################################
    def __init__(self, variation, number_of_points, start_frequency, stop_frequency):
        # Fixme: use mixin
        if variation not in ('dec', 'oct', 'lin'):
            raise ValueError("Incorrect variation type")
        self._variation = variation
        self._number_of_points = number_of_points
        self._start_frequency = as_Hz(start_frequency)
        self._stop_frequency = as_Hz(stop_frequency)
    ##############################################
    @property
    def variation(self):
        return self._variation
    @property
    def number_of_points(self):
        return self._number_of_points
    @property
    def start_frequency(self):
        return self._start_frequency
    @property
    def stop_frequency(self):
        return self._stop_frequency
    ##############################################
    def to_list(self):
        return (
            self._variation,
            self._number_of_points,
            self._start_frequency,
            self._stop_frequency
        )
####################################################################################################
class TransientAnalysisParameters(AnalysisParameters):
    """This class defines analysis parameters for transient analysis."""
    ANALYSIS_NAME = 'tran'
    ##############################################
    def __init__(self, step_time, end_time, start_time=0, max_time=None, use_initial_condition=False):
        self._step_time = as_s(step_time)
        self._end_time = as_s(end_time)
        self._start_time = as_s(start_time)
        self._max_time = as_s(max_time, none=True)
        self._use_initial_condition = use_initial_condition
    ##############################################
    @property
    def step_time(self):
        return self._step_time
    @property
    def end_time(self):
        return self._end_time
    @property
    def start_time(self):
        return self._start_time
    @property
    def max_time(self):
        return self._max_time
    @property
    def use_initial_condition(self):
        return self._use_initial_condition
    ##############################################
    def to_list(self):
        return (
            self._step_time,
            self._end_time,
            self._start_time,
            self._max_time,
            'uic' if self._use_initial_condition else None,
        )
####################################################################################################
class MeasureParameters(AnalysisParameters):
    """This class defines measurements on analysis.
    """
    ANALYSIS_NAME = 'meas'
    ##############################################
    def __init__(self, analysis_type, name, *args):
        _analysis_type = str(analysis_type).upper()
        if _analysis_type not in ('AC', 'DC', 'OP', 'TRAN', 'TF', 'NOISE'):
            raise ValueError('Incorrect analysis type {}'.format(analysis_type))
        self._parameters = [_analysis_type, name, *args]
    ##############################################
    @property
    def parameters(self):
        return self._parameters
    ##############################################
    def to_list(self):
        return self._parameters
####################################################################################################
class PoleZeroAnalysisParameters(AnalysisParameters):
    """This class defines analysis parameters for pole-zero analysis."""
    ANALYSIS_NAME = 'pz'
    ##############################################
    def __init__(self, node1, node2, node3, node4, tf_type, pz_type):
        self._nodes = (node1, node2, node3, node4)
        self._tf_type = tf_type   # transfert_function
        self._pz_type = pz_type   # pole_zero
    ##############################################
    @property
    def node1(self):
        return self._nodes[0]
    @property
    def node2(self):
        return self._nodes[1]
    def node3(self):
        return self._nodes[2]
    @property
    def node4(self):
        return self._nodes[3]
    @property
    def tf_type(self):
        return self._tf_type
    @property
    def pz_type(self):
        return self._pz_type
    ##############################################
    def to_list(self):
        return list(self._nodes) + [self._tf_type, self._pz_type]
####################################################################################################
class NoiseAnalysisParameters(AnalysisParameters):
    """This class defines analysis parameters for noise analysis."""
    ANALYSIS_NAME = 'noise'
    ##############################################
    def __init__(self, output, src, variation, points, start_frequency, stop_frequency, points_per_summary):
        self._output = output
        self._src = src
        self._variation = variation
        self._points = points
        self._start_frequency = start_frequency
        self._stop_frequency = stop_frequency
        self._points_per_summary = points_per_summary
    ##############################################
    @property
    def output(self):
        return self._output
    @property
    def src(self):
        return self._src
    @property
    def variation(self):
        return self._variation
    @property
    def points(self):
        return self._points
    # Fixme: mixin
    @property
    def start_frequency(self):
        return self._start_frequency
    @property
    def stop_frequency(self):
        return self._stop_frequency
    @property
    def points_per_summary(self):
        return self._points_per_summary
    ##############################################
    def to_list(self):
        parameters = [
            self._output,
            self._src,
            self._variation,
            self._points,
            self._start_frequency,
            self._stop_frequency,
        ]
        if self._points_per_summary:
            parameters.append(self._points_per_summary)
        return parameters
####################################################################################################
class DistortionAnalysisParameters(AnalysisParameters):
    """This class defines analysis parameters for distortion analysis."""
    ANALYSIS_NAME = 'disto'
    ##############################################
    def __init__(self, variation, points, start_frequency, stop_frequency, f2overf1):
        self._variation = variation
        self._points = points
        self._start_frequency = start_frequency
        self._stop_frequency = stop_frequency
        self._f2overf1 = f2overf1
    ##############################################
    @property
    def variation(self):
        return self._variation
    @property
    def points(self):
        return self._points
    @property
    def start_frequency(self):
        return self._start_frequency
    @property
    def stop_frequency(self):
        return self._stop_frequency
    @property
    def f2overf1(self):
        return self._f2overf1
    ##############################################
    def to_list(self):
        parameters = [
            self._variation,
            self._points,
            self._start_frequency,
            self._stop_frequency,
        ]
        if self._f2overf1:
            parameters.append(self._f2overf1)
        return parameters
####################################################################################################
class TransferFunctionAnalysisParameters(AnalysisParameters):
    """This class defines analysis parameters for transfer function (.tf) analysis."""
    ANALYSIS_NAME = 'tf'
    ##############################################
    def __init__(self, outvar, insrc):
        self._outvar = outvar
        self._insrc = insrc
    ##############################################
    @property
    def outvar(self):
        return self._outvar
    @property
    def insrc(self):
        return self._insrc
    ##############################################
    def to_list(self):
        return (self._outvar, self._insrc)
####################################################################################################
class CircuitSimulation:
    """Define and generate the spice instruction to perform a circuit simulation.
    .. warning:: In some cases NgSpice can perform several analyses one after the other. This case
      is partially supported.
    """
    _logger = _module_logger.getChild('CircuitSimulation')
    ##############################################
    def __init__(self, circuit, **kwargs):
        self._circuit = circuit
        self._options = {}   # .options
        self._measures = []   # .measure
        self._initial_condition = {}   # .ic
        self._node_set = {}   # .nodeset
        self._saved_nodes = set()
        self._analyses = {}
        self.temperature = kwargs.get('temperature', u_Degree(27))
        self.nominal_temperature = kwargs.get('nominal_temperature', u_Degree(27))
    ##############################################
    @property
    def circuit(self):
        return self._circuit
    ##############################################
    def options(self, *args, **kwargs):
        for item in args:
            self._options[str(item)] = None
        for key, value in kwargs.items():
            self._options[str(key)] = str_spice(value)
    ##############################################
    @property
    def temperature(self):
        return self._options['TEMP']
    @temperature.setter
    def temperature(self, value):
        self._options['TEMP'] = as_Degree(value)
    ##############################################
    @property
    def nominal_temperature(self):
        return self._options['TNOM']
    @nominal_temperature.setter
    def nominal_temperature(self, value):
        self._options['TNOM'] = as_Degree(value)
    ##############################################
    @staticmethod
    def _make_initial_condition_dict(kwargs):
        return {f"V({key})": str_spice(value) for key, value in kwargs.items()}
    ##############################################
    def initial_condition(self, **kwargs):
        """Set initial condition for voltage nodes.
        Usage::
            simulator.initial_condition(node_name=value, ...)
        General form::
            .ic v(node_name)=value ...
        The `.ic` line is for setting transient initial conditions.  It has two different
        interpretations, depending on whether the uic parameter is specified on the `.tran` control
        line, or not.  One should not confuse this line with the `.nodeset` line.  The `.nodeset`
        line is only to help DC convergence, and does not affect the final bias solution (except for
        multi-stable circuits).  The two indicated interpretations of this line are as follows:
        1. When the uic parameter is specified on the `.tran` line, the node voltages specified on
           the `.ic` control line are used to compute the capacitor, diode, BJT, JFET, and MOSFET
           initial conditions.  This is equivalent to specifying the `ic=...` parameter on each
           device line, but is much more convenient.  The `ic=...` parameter can still be specified
           and takes precedence over the `.ic` values.  Since no dc bias (initial transient)
           solution is computed before the transient analysis, one should take care to specify all
           dc source voltages on the `.ic` control line if they are to be used to compute device
           initial conditions.
        2. When the uic parameter is not specified on the `.tran` control line, the DC bias (initial
           transient) solution is computed before the transient analysis. In this case, the node
           voltages specified on the `.ic` control lines are forced to the desired initial values
           during the bias solution.  During transient analysis, the constraint on these node
           voltages is removed.  This is the preferred method since it allows Ngspice to compute a
           consistent dc solution.
        """
        d = self._make_initial_condition_dict(kwargs)
        self._initial_condition.update(d)
    ##############################################
    def node_set(self, **kwargs):
        """Specify initial node voltage guesses.
        Usage::
            simulator.node_set(node_name=value, ...)
        General form::
            .nodeset v(node_name)=value ...
            .nodeset all=val
        The `.nodeset` line helps the program find the DC or initial transient solution by making a
        preliminary pass with the specified nodes held to the given voltages.  The restrictions are
        then released and the iteration continues to the true solution.  The `.nodeset` line may be
        necessary for convergence on bistable or astable circuits. `.nodeset all=val` sets all
        starting node voltages (except for the ground node) to the same value.  In general, the
        `.nodeset` line should not be necessary.
        """
        d = self._make_initial_condition_dict(kwargs)
        self._node_set.update(d)
    ##############################################
    def save(self, *args):
        # Fixme: pass Node for voltage node, Element for source branch current, ...
        """Set the list of saved vectors.
        If no *.save* line is given, then the default set of vectors is saved (node voltages and
        voltage source branch currents). If *.save* lines are given, only those vectors specified
        are saved.
        Node voltages may be saved by giving the node_name or *v(node_name)*. Currents through an
        independent voltage source (including inductor) are given by *i(source_name)* or
        *source_name#branch*. Internal device data are accepted as *@dev[param]*.
        If you want to save internal data in addition to the default vector set, add the parameter
        *all* to the additional vectors to be saved.
        """
        self._saved_nodes |= set(*args)
    ##############################################
    def save_internal_parameters(self, *args):
        """This method is similar to`save` but assume *all*."""
        # Fixme: ok ???
        self.save(list(args) + ['all'])
    ##############################################
    @property
    def save_currents(self):
        """ Save all currents. """
        return self._options.get('SAVECURRENTS', False)
    @save_currents.setter
    def save_currents(self, value):
        if value:
            self._options['SAVECURRENTS'] = True
        else:
            del self._options['SAVECURRENTS']
    ##############################################
    def reset_analysis(self):
        self._analyses.clear()
    ##############################################
    def analysis_iter(self):
        return self._analyses.values()
    ##############################################
    def _add_analysis(self, analysis_parameters):
        self._analyses[analysis_parameters.analysis_name] = analysis_parameters
    ##############################################
    def _add_measure(self, measure_parameters):
        self._measures.append(measure_parameters)
    ##############################################
    def operating_point(self):
        """Compute the operating point of the circuit with capacitors open and inductors shorted."""
        self._add_analysis(OperatingPointAnalysisParameters())
    ##############################################
    def dc_sensitivity(self, output_variable):
        """Compute the sensitivity of the DC operating point of a node voltage or voltage-source
        branch current to all non-zero device parameters.
        Examples of usage::
            analysis = simulator.dc_sensitivity('v(out)')
        Spice syntax:
        .. code:: spice
            .sens outvar
        Examples:
        .. code:: spice
            .sens V(1, OUT)
            .sens I(VTEST)
        """
        self._add_analysis(DcSensitivityAnalysisParameters(output_variable))
    ##############################################
    def ac_sensitivity(self, output_variable, variation, number_of_points, start_frequency, stop_frequency):
        """Compute the sensitivity of the AC values of a node voltage or voltage-source branch
        current to all non-zero device parameters.
        Examples of usage::
            analysis = simulator.ac_sensitivity(...)
        Spice syntax:
        .. code::
            .sens outvar ac dec nd fstart fstop
            .sens outvar ac oct no fstart fstop
            .sens outvar ac lin np fstart fstop
        Spice examples:
        .. code::
            .sens V(OUT) AC DEC 10 100 100 k
        """
        self._add_analysis(
            AcSensitivityAnalysisParameters(
                output_variable,
                variation, number_of_points, start_frequency, stop_frequency
            ))
    ##############################################
    def dc(self, **kwargs):
        """Compute the DC transfer fonction of the circuit with capacitors open and inductors shorted.
        Examples of usage::
            analysis = simulator.dc(Vinput=slice(-2, 5, .01))
            analysis = simulator.dc(Ibase=slice(0, 100e-6, 10e-6))
            analysis = simulator.dc(Vcollector=slice(0, 5, .1), Ibase=slice(micro(10), micro(100), micro(10))) # broken ???
        Spice syntax:
        .. code:: spice
            .dc src_name vstart vstop vincr [ src2 start2 stop2 incr2 ]
        *src_name* is the name of an independent voltage or a current source, a resistor or the
        circuit temperature.
        *vstart*, *vstop*, and *vincr* are the starting, final, and incrementing values respectively.
        A second source (*src2*) may optionally be specified with associated sweep parameters. In
        this case, the first source is swept over its range for each value of the second source.
        Spice examples:
        .. code:: spice
            .dc VIN 0 .2 5 5.0 0.25
            .dc VDS 0 10 .5 VGS 0 5 1
            .dc VCE 0 10 .2 5 IB 0 10U 1U
            .dc RLoad 1k 2k 100
            .dc TEMP -15 75 5
        """
        self._add_analysis(DCAnalysisParameters(**kwargs))
    ##############################################
    def ac(self, variation, number_of_points, start_frequency, stop_frequency):
        # fixme: concise keyword ?
        """Perform a small-signal AC analysis of the circuit where all non-linear devices are linearized
        around their actual DC operating point.
        Examples of usage::
            analysis = simulator.ac(start_frequency=10@u_kHz, stop_frequency=1@u_GHz, number_of_points=10,  variation='dec')
        Note that in order for this analysis to be meaningful, at least one independent source must
        have been specified with an AC value. Typically it does not make much sense to specify more
        than one AC source. If you do, the result will be a superposition of all sources, thus
        difficult to interpret.
        Spice examples:
        .. code::
            .ac dec nd fstart fstop
            .ac oct no fstart fstop
            .ac lin np fstart fstop
        The parameter *variation* must be either `dec`, `oct` or `lin`.
        """
        self._add_analysis(
            ACAnalysisParameters(
                variation, number_of_points, start_frequency, stop_frequency
            ))
    ##############################################
    def measure(self, analysis_type, name, *args):
        """Add a measure in the circuit.
        Examples of usage::
            simulator.measure('TRAN', 'tdiff', 'TRIG AT=10m', 'TARG v(n1) VAL=75.0 CROSS=1')
            simulator.measure('tran', 'tdiff', 'TRIG AT=0m', f"TARG par('v(n1)-v(derate)') VAL=0 CROSS=1")
        Note: can be used with the .options AUTOSTOP to stop the simulation at Trigger.
        Spice syntax:
        .. code:: spice
            .meas tran tdiff TRIG AT=0m TARG v(n1) VAL=75.0 CROSS=1
        """
        self._add_measure(MeasureParameters(analysis_type, name, *args))
    ##############################################
    def transient(self, step_time, end_time, start_time=0, max_time=None, use_initial_condition=False):
        """Perform a transient analysis of the circuit.
        Examples of usage::
            analysis = simulator.transient(step_time=1@u_us, end_time=500@u_us)
            analysis = simulator.transient(step_time=source.period/200, end_time=source.period*2)
        Spice syntax:
        .. code:: spice
            .tran tstep tstop <tstart <tmax>> <uic>
        """
        self._add_analysis(
            TransientAnalysisParameters(
                step_time, end_time, start_time, max_time,
                use_initial_condition
            ))
    ##############################################
    def polezero(self, node1, node2, node3, node4, tf_type, pz_type):
        """Perform a Pole-Zero analysis of the circuit.
        node1, node2 - Input node pair.
        node3, node4 - Output node pair
        tf_type - should be `cur` for current or `vol` for voltage
        pz_type - should be `pol` for pole, `zer` for zero, or `pz` for combined pole zero analysis.
        See section 15.3.6 of ngspice manual.
        Spice syntax:
        .. code:: spice
            .tran tstep tstop <tstart <tmax>> <uic>
            .pz node1 node2 node3 node4 cur pol
            .pz node1 node2 node3 node4 cur zer
            .pz node1 node2 node3 node4 cur pz
            .pz node1 node2 node3 node4 vol pol
            .pz node1 node2 NODE3 node4 vol zer
            .pz node1 node2 node3 node4 vol pz
        Examples:
        .. code:: spice
            .pz 1 0 3 0 cur pol
            .pz 2 3 5 0 vol zer
            .pz 4 1 4 1 cur pz
        """
        # do some rudimentary parameter checking.
        if tf_type not in ('cur', 'vol'):
            raise NameError("polezero type must be 'cur' or 'vol'")
        if pz_type not in ('pol', 'zer', 'pz'):
            raise NameError("pz_type must be 'pol' or 'zer' or 'pz'")
        self._add_analysis(
            PoleZeroAnalysisParameters(node1, node2, node3, node4, tf_type, pz_type)
        )
    ##############################################
    def noise(self, output_node, ref_node, src, variation, points, start_frequency, stop_frequency, points_per_summary=None):
        """Perform a Pole-Zero analysis of the circuit.
        output_node, ref_node - output node pair.
        src - signal source, typically an ac voltage input.
        variation - must be 'dec' or 'lin' or 'oct' for decade, linear, or octave.
        points, start_frequency, stop_frequency - number of points, start and stop frequencies.
        points_per_summary - if specified, the noise contributions of each noise generator is produced every points_per_summary frequency points.
        See section 15.3.4 of ngspice manual.
        Spice syntax:
        General form:
        .. code:: spice
            .noise v(output <,ref >) src ( dec | lin | oct ) pts fstart fstop <pts_per_summary >
        Examples:
        .. code:: spice
            .noise v(5) VIN dec 10 1kHz 100 MEG
            .noise v(5 ,3) V1 oct 8 1.0 1.0 e6 1
        """
        # do some rudimentary parameter checking.
        # Fixme: mixin
        if variation not in ('dec', 'lin', 'oct'):
            raise NameError("variation must be 'dec' or 'lin' or 'oct'")
        output = 'V({},{})'.format(output_node, ref_node)
        self._add_analysis(
            NoiseAnalysisParameters(output, src, variation, points, start_frequency, stop_frequency, points_per_summary)
        )
    ##############################################
    def transfer_function(self, outvar, insrc):
        """The python arguments to this function should be two strings, outvar and insrc.
        ngspice documentation as follows:
        General form:
        .. code:: spice
            .tf outvar insrc
        Examples:
        .. code:: spice
           .tf v(5, 3) VIN
           .tf i(VLOAD) VIN
        The .tf line defines the small-signal output and input for the dc small-signal
        analysis. outvar is the small signal output variable and insrc is the small-signal input
        source. If this line is included, ngspice computes the dc small-signal value of the transfer
        function (output/input), input resistance, and output resistance. For the first example,
        ngspice would compute the ratio of V(5, 3) to VIN, the small-signal input resistance at VIN,
        and the small signal output resistance measured across nodes 5 and 3
        """
        self._add_analysis(
            TransferFunctionAnalysisParameters(outvar, insrc)
        )
    ##############################################
    def distortion(self, variation, points, start_frequency, stop_frequency, f2overf1=None):
        """Perform a distortion analysis of the circuit.
        variation, points, start_frequency, stop_frequency - typical ac range parameters.
        if f2overf1 is specified, perform a spectral analysis, else perform a harmonic analysis.
        See section 15.3.3 of ngspice manual.
        - harmonic analysis,
          The distof1 parameter of the AC input to the circuit must be specified.
          Second harmonic magnitude and phase are calculated at each circuit node.
        - Spectral analysis,
           The distof2 parameter of the AC input to the circuit must be specified as well as distof1.
           See the ngspice manual.
        Spice syntax:
        General form:
        .. code:: spice
              .disto dec nd fstart fstop <f2overf1 >
              .disto oct no fstart fstop <f2overf1 >
              .disto lin np fstart fstop <f2overf1 >
        Examples:
        .. code:: spice
              .disto dec 10 1kHz 100 MEG
              .disto dec 10 1kHz 100 MEG 0.9
        """
        # do some rudimentary parameter checking.
        if variation not in ('dec', 'lin', 'oct'):
            raise NameError("variation must be 'dec' or 'lin' or 'oct'")
        self._add_analysis(
            DistortionAnalysisParameters(variation, points, start_frequency, stop_frequency, f2overf1)
        )
    ##############################################
    def str_options(self, unit=True):
        # Fixme: use cls settings ???
        if unit:
            _str = str_spice
        else:
            _str = lambda x: str_spice(x, unit)
        netlist = ''
        if self.options:
            for key, value in self._options.items():
                if value is not None:
                    netlist += '.options {} = {}'.format(key, _str(value)) + os.linesep
                else:
                    netlist += '.options {}'.format(key) + os.linesep
        return netlist
    ##############################################
    def __str__(self):
        netlist = self._circuit.str(simulator=self.SIMULATOR)
        netlist += self.str_options()
        if self._initial_condition:
            netlist += '.ic ' + join_dict(self._initial_condition) + os.linesep
        if self._node_set:
            netlist += '.nodeset ' + join_dict(self._node_set) + os.linesep
        if self._saved_nodes:
            # Place 'all' first
            saved_nodes = self._saved_nodes
            if 'all' in saved_nodes:
                all_str = 'all '
                saved_nodes.remove('all')
            else:
                all_str = ''
            netlist += '.save ' + all_str + join_list(saved_nodes) + os.linesep
        for measure_parameters in self._measures:
            netlist += str(measure_parameters) + os.linesep
        for analysis_parameters in self._analyses.values():
            netlist += str(analysis_parameters) + os.linesep
        netlist += '.end' + os.linesep
        return netlist
####################################################################################################
class CircuitSimulator(CircuitSimulation):
    """ This class implements a circuit simulator. Each analysis mode is performed by a method that
    return the measured probes.
    For *ac* and *transient* analyses, the user must specify a list of nodes using the *probes* key
    argument.
    """
    _logger = _module_logger.getChild('CircuitSimulator')
    if ConfigInstall.OS.on_windows:
        DEFAULT_SIMULATOR = 'ngspice-shared'
    else:
        # DEFAULT_SIMULATOR = 'ngspice-subprocess'
        DEFAULT_SIMULATOR = 'ngspice-shared'
        # DEFAULT_SIMULATOR = 'xyce-serial'
        # DEFAULT_SIMULATOR = 'xyce-parallel'
    ##############################################
    @classmethod
    def factory(cls, circuit, *args, **kwargs):
        """Return a :obj:`PySpice.Spice.Simulation.SubprocessCircuitSimulator` or
        :obj:`PySpice.Spice.Simulation.NgSpiceSharedCircuitSimulator` instance depending of the
        value of the *simulator* parameter: ``subprocess`` or ``shared``, respectively. If this
        parameter is not specified then a subprocess simulator is returned.
        """
        if 'simulator' in kwargs:
            simulator = kwargs['simulator']
            del kwargs['simulator']
        else:
            simulator = cls.DEFAULT_SIMULATOR
        sub_cls = None
        if simulator in ('ngspice-subprocess', 'ngspice-shared'):
            if simulator == 'ngspice-subprocess':
                from .NgSpice.Simulation import NgSpiceSubprocessCircuitSimulator
                sub_cls = NgSpiceSubprocessCircuitSimulator
            elif simulator == 'ngspice-shared':
                from .NgSpice.Simulation import NgSpiceSharedCircuitSimulator
                sub_cls = NgSpiceSharedCircuitSimulator
        elif simulator in ('xyce-serial', 'xyce-parallel'):
            from .Xyce.Simulation import XyceCircuitSimulator
            sub_cls = XyceCircuitSimulator
            if simulator == 'xyce-parallel':
                kwargs['parallel'] = True
        if sub_cls is not None:
            return sub_cls(circuit, *args, **kwargs)
        else:
            raise ValueError('Unknown simulator type')
    ##############################################
    def _run(self, analysis_method, *args, **kwargs):
        self.reset_analysis()
        if 'probes' in kwargs:
            self.save(* kwargs.pop('probes'))
        _kwargs = dict(kwargs)
        _kwargs.pop('log_desk', None)
        method = getattr(CircuitSimulation, analysis_method)
        method(self, *args, **_kwargs)
        message = 'desk' + os.linesep + str(self)
        if kwargs.get('log_desk', False):
            self._logger.info(message)
        else:
            self._logger.debug(message)
    ##############################################
    def operating_point(self, *args, **kwargs):
        return self._run('operating_point', *args, **kwargs)
    ##############################################
    def dc(self, *args, **kwargs):
        return self._run('dc', *args, **kwargs)
    ##############################################
    def dc_sensitivity(self, *args, **kwargs):
        return self._run('dc_sensitivity', *args, **kwargs)
    ##############################################
    def ac(self, *args, **kwargs):
        return self._run('ac', *args, **kwargs)
    ##############################################
    def transient(self, *args, **kwargs):
        return self._run('transient', *args, **kwargs)
    ##############################################
    def polezero(self, *args, **kwargs):
        return self._run('polezero', *args, **kwargs)
    ##############################################
    def noise(self, *args, **kwargs):
        return self._run('noise', *args, **kwargs)
    ##############################################
    def distortion(self, *args, **kwargs):
        return self._run('distortion', *args, **kwargs)
    ##############################################
    def transfer_function(self, *args, **kwargs):
        return self._run('transfer_function', *args, **kwargs)
    tf = transfer_function   # shorcut
</file>

<file path="PySpice/Tools/EnumFactory.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
""" This module provides an implementation for enumerate.
The enumerate factory :func:`EnumFactory` builds a enumerate from a list of names and assigns to
these constants a value from 0 to N-1, where N is the number of constants.  For example::
  enum = EnumFactory('Enum1', ('cst1', 'cst2'))
builds a enumerate with *cst1* set to 0 and *cst2* set to 1.
We can get a constant's value using an integer context like::
  int(enum.cst1)
and the constant's name using::
  repr(enum.cst1)
We can test constant equality using::
  enum1.cst == enum2.cst
or with something that understand the *int* protocol::
  enum1.cst == obj
  # equivalent to
  int(enum1.cst) == int(obj)
The number of constants could be retrieved with::
  len(enum)
The enumerate factory :func:`ExplicitEnumFactory` is a variant that permits to specify the values of
the constants::
  enum2 = ExplicitEnumFactory('Enum2', {'cst1':1, 'cst2':3})
We can test if a value is in the enumerate using::
  constant_value in enum2
"""
####################################################################################################
# __all__ = ['EnumFactory', 'ExplicitEnumFactory']
####################################################################################################
class ReadOnlyMetaClass(type):
    """ This meta class implements a class where attributes are read only. """
    ##############################################
    def __setattr__(self, name, value):
        raise NotImplementedError
####################################################################################################
class EnumMetaClass(ReadOnlyMetaClass):
    """ This meta class implements the :func:`len` protocol. """
    ##############################################
    def __len__(self):
        return self._size
    ##############################################
    def __getitem__(self, i):
        return self._index[i]
####################################################################################################
class ExplicitEnumMetaClass(ReadOnlyMetaClass):
    """ This meta class implements the operator ``in``. """
    ##############################################
    def __contains__(self, item):
        return item in self.constants
####################################################################################################
class EnumConstant:
    """ Define an Enum Constant """
    ##############################################
    def __init__(self, name, value):
        self._name = name
        self._value = value
    ##############################################
    def __eq__(self, other):
        return self._value == int(other)
    ##############################################
    def __int__(self):
        return self._value
    ##############################################
    def __hash__(self):
        return self._value
    ##############################################
    def __repr__(self):
        return self._name
####################################################################################################
def EnumFactory(enum_name, enum_tuple):
    """ Return an :class:`EnumMetaClass` instance, where *enum_name* is the class name and
    *enum_tuple* is an iterable of constant's names.
    """
    index = [EnumConstant(name, value) for value, name in enumerate(enum_tuple)]
    obj_dict = {}
    obj_dict['_size'] = len(enum_tuple)
    obj_dict['_index'] = index
    obj_dict.update({str(enum):enum for enum in index})
    return EnumMetaClass(enum_name, (), obj_dict)
####################################################################################################
def ExplicitEnumFactory(enum_name, enum_dict):
    """ Return an :class:`ExplicitEnumMetaClass` instance, where *enum_name* is the class name and
    *enum_dict* is a dict of constant's names and their values.
    """
    obj_dict = {}
    obj_dict['constants'] = list(enum_dict.values())
    for name, value in list(enum_dict.items()):
        obj_dict[name] = EnumConstant(name, value)
    return ExplicitEnumMetaClass(enum_name, (), obj_dict)
</file>

<file path="PySpice/Tools/File.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
# Used by Spice/Library.py
####################################################################################################
import os
import subprocess
####################################################################################################
def file_name_has_extension(file_name, extension):
    return file_name.endswith(extension)
####################################################################################################
def file_extension(filename):
    # index = filename.rfind(os.path.extsep)
    # if index == -1:
    #     return None
    # else:
    #     return filename[index:]
    return os.path.splitext(filename)[1]
####################################################################################################
def run_shasum(filename, algorithm=1, text=False, binary=False, portable=False):
    if algorithm not in (1, 224, 256, 384, 512, 512224, 512256):
        raise ValueError
    args = ['shasum', '--algorithm=' + str(algorithm)]
    if text:
        args.append('--text')
    elif binary:
        args.append('--binary')
    elif portable:
        args.append('--portable')
    args.append(filename)
    output = subprocess.check_output(args)
    shasum = output[:output.find(' ')]
    return shasum
####################################################################################################
class Path:
    ##############################################
    def __init__(self, path):
        self._path = str(path)
    ##############################################
    def __bool__(self):
        return os.path.exists(self._path)
    ##############################################
    def __str__(self):
        return self._path
    ##############################################
    @property
    def path(self):
        return self._path
    ##############################################
    def is_absolut(self):
        return os.path.isabs(self._path)
    ##############################################
    def absolut(self):
        return self.clone_for_path(os.path.abspath(self._path))
    ##############################################
    def normalise(self):
        return self.clone_for_path(os.path.normpath(self._path))
    ##############################################
    def normalise_case(self):
        return self.clone_for_path(os.path.normcase(self._path))
    ##############################################
    def expand_vars_and_user(self):
        return self.clone_for_path(os.path.expandvars(os.path.expanduser(self._path)))
    ##############################################
    def real_path(self):
        return self.clone_for_path(os.path.realpath(self._path))
    ##############################################
    def relative_to(self, directory):
        return self.clone_for_path(os.path.relpath(self._path, str(directory)))
    ##############################################
    def clone_for_path(self, path):
        return self.__class__(path)
    ##############################################
    def split(self):
        return self._path.split(os.path.sep)
    ##############################################
    def directory_part(self):
        return Directory(os.path.dirname(self._path))
    ##############################################
    def filename_part(self):
        return os.path.basename(self._path)
    ##############################################
    def is_directory(self):
        return os.path.isdir(self._path)
    ##############################################
    def is_file(self):
        return os.path.isfile(self._path)
    ##############################################
    @property
    def inode(self):
        return os.stat(self._path).st_ino
    ##############################################
    @property
    def creation_time(self):
        return os.stat(self._path).st_ctime
####################################################################################################
class Directory(Path):
    ##############################################
    def __bool__(self):
        return super().__nonzero__() and self.is_directory()
    ##############################################
    def join_directory(self, directory):
        return self.__class__(os.path.join(self._path, str(directory)))
    ##############################################
    def join_filename(self, filename):
        return File(filename, self._path)
    ##############################################
    def iter_file(self, followlinks=False):
        if self.is_file():
            yield File(self.filename_part(), self.directory_part())
        else:
            for root, directories, files in os.walk(self._path, followlinks=followlinks):
                for filename in files:
                    yield File(filename, root)
    ##############################################
    def iter_directories(self, followlinks=False):
        for root, directories, files in os.walk(self._path, followlinks=followlinks):
            for directory in directories:
                yield Path(os.path.join(root, directory))
####################################################################################################
class File(Path):
    default_shasum_algorithm = 256
    ##############################################
    def __init__(self, filename, path=''):
        super().__init__(os.path.join(str(path), str(filename)))
        self._filename = self.filename_part()
        if not self._filename:
            raise ValueError
        self._directory = self.directory_part()
        self._shasum = None # lazy computation
    ##############################################
    def __bool__(self):
        return super().__nonzero__() and os.path.isfile(self._path)
    ##############################################
    @property
    def directory(self):
        return self._directory
    ##############################################
    @property
    def filename(self):
        return self._filename
    ##############################################
    @property
    def extension(self):
        return file_extension(self._filename)
    ##############################################
    @property
    def shasum(self):
        if self._shasum is None:
            return self.compute_shasum()
        else:
            return self._shasum
    ##############################################
    def compute_shasum(self, algorithm=None):
        if algorithm is None:
            algorithm = self.default_shasum_algorithm
        self._shasum = run_shasum(self._path, algorithm, portable=True)
        return self._shasum
</file>

<file path="PySpice/Tools/Path.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
import os
####################################################################################################
def to_absolute_path(path):
    # Expand ~ . and Remove trailing '/'
    return os.path.abspath(os.path.expanduser(path))
####################################################################################################
def parent_directory_of(file_name, step=1):
    directory = file_name
    for i in range(step):
        directory = os.path.dirname(directory)
    return directory
####################################################################################################
def find(file_name, directories):
    if isinstance(directories, bytes):
        directories = (directories,)
    for directory in directories:
        for directory_path, sub_directories, file_names in os.walk(directory):
            if file_name in file_names:
                return os.path.join(directory_path, file_name)
    raise NameError("File %s not found in directories %s" % (file_name, str(directories)))
</file>

<file path="PySpice/Tools/StringTools.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
__all__ = [
    'join_dict',
    'join_lines'
    'join_list',
    'str_spice',
    'str_spice_list',
]
####################################################################################################
import os
####################################################################################################
from PySpice.Unit.Unit import UnitValue
####################################################################################################
def str_spice(obj, unit=True):
    # Fixme: right place ???
    """Convert an object to a Spice compatible string."""
    if isinstance(obj, UnitValue):
        if unit:
            return obj.str_spice()
        else: # Fixme: ok ???
            return obj.str(spice=False, space=False, unit=False)
    else:
        return str(obj)
####################################################################################################
def str_spice_list(*args):
    return [str_spice(x) for x in args]
####################################################################################################
def join_lines(items, prefix=''):
    return os.linesep.join([prefix + str(item)
                            for item in items
                            if item is not None]) # Fixme: and item
####################################################################################################
def join_list(items):
    # return ' '.join([str_spice(item)
    #                  for item in items
    #                  if item is not None and str_spice(item)])
    values = []
    for item in items:
        if item is not None:
            str_value = str_spice(item)
            if str_value:
                values.append(str_value)
    return ' '.join(values)
####################################################################################################
def join_dict(d):
    return ' '.join(["{}={}".format(key, str_spice(value))
                     for key, value in sorted(d.items())
                     if value is not None])
</file>

<file path="PySpice/Unit/__init__.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
# Note: This module should be outsourced, only code specific to SPICE must remain.
"""This module implements units.
Shortcuts are defined to build unit values easily :
 * for each unit prefix, e.g. :func:`pico`, :func:`nano`, :func:`micro`, :func:`milli`, :func:`kilo`,
   :func:`mega`, :func:`tera`. These shortcuts return unit less values.
 * for each unit and prefix as the concatenation of *u_*, the unit prefix and the
   unit suffix, e.g. :func:`u_pV`, :func:`u_nV`, :func:`u_uV` :func:`u_mV`, :func:`u_V`,
   :func:`u_kV`, :func:`u_MV`, :func:`u_TV`.
Theses unit value constructors accept int, float, object that can be converted to float,
:class:`UnitValue` instance and an iterable on these types.
A shortcut is defined to check an unit value match a particular unit, e.g. :func:`as_V`.  Theses
shortcuts return the value if the unit match else it raises the exception *UnitError*.
A shortcut is defined to access each unit, e.g. :func:`U_V`, :func:`U_A`, :func:`U_s`, :func:`U_Hz`,
:func:`U_Ω`, :func:`U_F`, :func:`U_H.`, as well as for prefixes e.g. :func:`U_mV`.
Some shortcuts have Unicode and ASCII variants:
 * For micro, we have the prefix *μ* and *u*.
 * For Ohm, we have :func:`u_Ω` and :func:`u_Ohm`.
Some examples of usage:
.. code-block:: python3
  foo = kilo(1) # unit less
  resistance_unit = U_Ω
  resistance1 = u_kΩ(1)
  resistance1 = u_kOhm(1) # ASCII variant
  resistance1 = 1@u_kΩ   # using Python 3.5 syntax
  resistance1 = 1 @u_kΩ  # space doesn't matter
  resistance1 = 1 @ u_kΩ #
  resistance2 = as_Ω(resistance1) # check unit
  resistances = u_kΩ(range(1, 11)) # same as [u_kΩ(x) for x in range(1, 11)]
  resistances = range(1, 11)@u_kΩ  # using Python 3.5 syntax
  capacitance = u_uF(200)
  inductance = u_mH(1)
  temperature = u_Degree(25)
  voltage = resistance1 * u_mA(1) # compute unit
  frequency = u_ms(20).frequency
  period = u_Hz(50).period
  pulsation = frequency.pulsation
  pulsation = period.pulsation
.. warning::
   According to the Python `operator precedence
  <https://docs.python.org/3/reference/expressions.html#operator-precedence>`_, division operators
  have a higher priority than the matrix multiplication operator.  In consequence you must had
  parenthesis to perform something like :code:`(10@u_s) / (2@_us)`.
"""
####################################################################################################
import logging
import sys
from . import Unit as _Unit
from . import SiUnits as _SiUnits
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
_version_info = sys.version_info
_has_matmul = _version_info.major * 10 + _version_info.minor >= 35
if not _has_matmul:
    _module_logger.warning("Your Python version doesn't implement @ operator")
####################################################################################################
class UnitValueShorcut:
    ##############################################
    def __init__(self, prefixed_unit):
        self._prefixed_unit = prefixed_unit
    ##############################################
    def _new_value(self, other):
        return self._prefixed_unit.new_value(other)
    ##############################################
    def __call__(self, other):
        """self(other)"""
        return self._new_value(other)
    ##############################################
    def __rmatmul__(self, other):
        """other @ self"""
        return self._new_value(other)
####################################################################################################
def _to_ascii(name):
    ascii_name = name
    for args in (
            ('μ', 'u'),
            ('Ω', 'Ohm'),
            ('°C', 'Degree'),
    ):
        ascii_name = ascii_name.replace(*args)
    return ascii_name
def define_shortcut(name, shortcut) :
    # ° is illegal in Python 3.5
    #  see https://docs.python.org/3/reference/lexical_analysis.html#identifiers
    #      https://www.python.org/dev/peps/pep-3131/
    if '°' not in name:
        globals()[name] = shortcut
    ascii_name = _to_ascii(name)
    if ascii_name != name:
        globals()[ascii_name] = shortcut
####################################################################################################
# Define shortcuts for unit prefixes : ..., micro, milli, kilo, mega, ...
def _build_prefix_shortcut(unit_prefix):
    unit_cls_name = unit_prefix.__class__.__name__
    name = unit_cls_name.lower()
    prefixed_unit = _Unit.PrefixedUnit(power=unit_prefix)
    _Unit.PrefixedUnit.register(prefixed_unit)
    shortcut = lambda value: _Unit.UnitValue(prefixed_unit, value)
    define_shortcut(name, shortcut)
for unit_prefix in _Unit.UnitPrefixMetaclass.prefix_iter():
    if unit_prefix.__class__ != _Unit.ZeroPower:
        _build_prefix_shortcut(unit_prefix) # capture unit_prefix
####################################################################################################
# Fixme: better ???
class FrequencyValue(_Unit.UnitValue, _Unit.FrequencyMixin):
    pass
# Fixme:
class FrequencyValues(_Unit.UnitValues): # , _Unit.FrequencyMixin
    pass
class PeriodValue(_Unit.UnitValue, _Unit.PeriodMixin):
    pass
class PeriodValues(_Unit.UnitValues): # , _Unit.PeriodMixin
    pass
####################################################################################################
# Define unit shortcuts
def _build_unit_type_shortcut(unit):
    name = 'U_' + unit.unit_suffix
    define_shortcut(name, unit)
def _build_as_unit_shortcut(unit):
    name = 'as_' + unit.unit_suffix
    shortcut = unit.validate
    define_shortcut(name, shortcut)
def _exec_body(ns, unit_prefix):
    ns['POWER'] = unit_prefix
def _build_unit_prefix_shortcut(unit, unit_prefix):
    name = 'u_' + str(unit_prefix) + unit.unit_suffix
    if unit.__class__ == _SiUnits.Hertz:
        value_ctor = FrequencyValue
        values_ctor = FrequencyValues
    elif unit.__class__ == _SiUnits.Second:
        value_ctor = PeriodValue
        values_ctor = PeriodValues
    else:
        value_ctor = _Unit.UnitValue
        values_ctor = _Unit.UnitValues
    prefixed_unit = _Unit.PrefixedUnit(unit, unit_prefix, value_ctor, values_ctor)
    _Unit.PrefixedUnit.register(prefixed_unit)
    define_shortcut('U' + name[1:], prefixed_unit)
    shortcut = UnitValueShorcut(prefixed_unit)
    define_shortcut(name, shortcut)
def _build_unit_shortcut(unit):
    _build_as_unit_shortcut(unit)
    _build_unit_type_shortcut(unit)
    for unit_prefix in _Unit.UnitPrefixMetaclass.prefix_iter():
        if unit_prefix.is_defined_in_spice:
            _build_unit_prefix_shortcut(unit, unit_prefix)
for unit in _Unit.UnitMetaclass.unit_iter():
    if unit.unit_suffix and unit.__class__ not in (_SiUnits.Kilogram,):
        # Fixme: kilogram
        _build_unit_shortcut(unit)
####################################################################################################
unit_value = _Unit.UnitValue.simple_value
Frequency = u_Hz
Period = u_s
</file>

<file path="PySpice/Unit/SiUnits.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2017 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
"""This module defines SI prefixes and units.
"""
####################################################################################################
from .Unit import UnitPrefix, SiBaseUnit, Unit
####################################################################################################
# Define SI unit prefixes
class Yotta(UnitPrefix):
    POWER = 24
    PREFIX = 'Y'
    SPICE_PREFIX = None
class Zetta(UnitPrefix):
    POWER = 21
    PREFIX = 'Z'
    SPICE_PREFIX = None
class Exa(UnitPrefix):
    POWER = 18
    PREFIX = 'E'
    SPICE_PREFIX = None
class Peta(UnitPrefix):
    POWER = 15
    PREFIX = 'P'
    SPICE_PREFIX = None
class Tera(UnitPrefix):
    POWER = 12
    PREFIX = 'T'
class Giga(UnitPrefix):
    POWER = 9
    PREFIX = 'G'
class Mega(UnitPrefix):
    POWER = 6
    PREFIX = 'M'
    SPICE_PREFIX = 'Meg'
class Kilo(UnitPrefix):
    POWER = 3
    PREFIX = 'k'
class Hecto(UnitPrefix):
    POWER = 2
    PREFIX = 'h'
    SPICE_PREFIX = None
class Deca(UnitPrefix):
    POWER = 1
    PREFIX = 'da'
    SPICE_PREFIX = None
class Milli(UnitPrefix):
    POWER = -3
    PREFIX = 'm'
class Micro(UnitPrefix):
    POWER = -6
    PREFIX = 'μ'
    SPICE_PREFIX = 'u'
class Nano(UnitPrefix):
    POWER = -9
    PREFIX = 'n'
class Pico(UnitPrefix):
    POWER = -12
    PREFIX = 'p'
class Femto(UnitPrefix):
    POWER = -15
    PREFIX = 'f'
    SPICE_PREFIX = None
class Atto(UnitPrefix):
    POWER = -18
    PREFIX = 'a'
    SPICE_PREFIX = None
class Zepto(UnitPrefix):
    POWER = -21
    PREFIX = 'z'
    SPICE_PREFIX = None
class Yocto(UnitPrefix):
    POWER = -24
    PREFIX = 'y'
    SPICE_PREFIX = None
# Fixme: ngspice defines mil
####################################################################################################
# Define SI units
class Metre(SiBaseUnit):
    UNIT_NAME = 'metre'
    UNIT_SUFFIX = 'm'
    QUANTITY = 'length'
class Kilogram(SiBaseUnit):
    UNIT_NAME = 'kilogram'
    UNIT_SUFFIX = 'kg'
    QUANTITY = 'mass'
class Second(SiBaseUnit):
    UNIT_NAME = 'second'
    UNIT_SUFFIX = 's'
    QUANTITY = 'time'
    IS_SI = True
class Ampere(SiBaseUnit):
    UNIT_NAME = 'ampere'
    UNIT_SUFFIX = 'A'
    QUANTITY = 'electric current'
class Kelvin(SiBaseUnit):
    UNIT_NAME = 'kelvin'
    UNIT_SUFFIX = 'K'
    QUANTITY = 'thermodynamic temperature'
class Mole(SiBaseUnit):
    UNIT_NAME = 'mole'
    UNIT_SUFFIX = 'mol'
    QUANTITY = 'amount of substance'
class Candela(SiBaseUnit):
    UNIT_NAME = 'candela'
    UNIT_SUFFIX = 'cd'
    QUANTITY = 'luminosity intensity'
####################################################################################################
# Define Derived units
class Radian(Unit):
    UNIT_NAME = 'radian'
    UNIT_SUFFIX = 'rad'
    QUANTITY = 'angle'
    SI_UNIT = 'm*m^-1'
    DEFAULT_UNIT = True
class Steradian(Unit):
    UNIT_NAME = 'steradian'
    UNIT_SUFFIX = 'sr'
    QUANTITY = 'solid angle'
    SI_UNIT = 'm^2*m^-2'
    DEFAULT_UNIT = True
class Hertz(Unit):
    UNIT_NAME = 'frequency'
    UNIT_SUFFIX = 'Hz'
    QUANTITY = 'frequency'
    SI_UNIT = 's^-1'
    DEFAULT_UNIT = True
class Newton(Unit):
    UNIT_NAME = 'newton'
    UNIT_SUFFIX = 'N'
    QUANTITY = 'force'
    SI_UNIT = 'kg*m*s^-2'
    DEFAULT_UNIT = True
class Pascal(Unit):
    UNIT_NAME = 'pascal'
    UNIT_SUFFIX = 'Pa'
    QUANTITY = 'pressure'
    SI_UNIT = 'kg*m^-1*s^-2'
    DEFAULT_UNIT = True
    # N/m^2
class Joule(Unit):
    UNIT_NAME = 'joule'
    UNIT_SUFFIX = 'J'
    QUANTITY = 'energy'
    SI_UNIT = 'kg*m^2*s^-2'
    DEFAULT_UNIT = True
    # N*m
class Watt(Unit):
    UNIT_NAME = 'watt'
    UNIT_SUFFIX = 'W'
    QUANTITY = 'power'
    SI_UNIT = 'kg*m^2*s^-3'
    DEFAULT_UNIT = True
    # J/s
class Coulomb(Unit):
    UNIT_NAME = 'coulomb'
    UNIT_SUFFIX = 'C'
    QUANTITY = 'electric charge'
    SI_UNIT = 's*A'
    DEFAULT_UNIT = True
class Volt(Unit):
    UNIT_NAME = 'volt'
    UNIT_SUFFIX = 'V'
    QUANTITY = 'voltage'
    SI_UNIT = 'kg*m^2*s^-3*A^-1'
    DEFAULT_UNIT = True
    # W/A
class Farad(Unit):
    UNIT_NAME = 'farad'
    UNIT_SUFFIX = 'F'
    QUANTITY = 'capacitance'
    SI_UNIT = 'kg^-1*m^-2*s^4*A^2'
    DEFAULT_UNIT = True
    # C/V
class Ohm(Unit):
    UNIT_NAME = 'ohm'
    UNIT_SUFFIX = 'Ω'
    QUANTITY = 'electric resistance, impedance, reactance'
    SI_UNIT = 'kg*m^2*s^-3*A^-2'
    DEFAULT_UNIT = True
    # V/A
class Siemens(Unit):
    UNIT_NAME = 'siemens'
    UNIT_SUFFIX = 'S'
    QUANTITY = 'electrical conductance'
    SI_UNIT = 'kg^-1*m^-2*s^3*A^2'
    DEFAULT_UNIT = True
    # A/V
class Weber(Unit):
    UNIT_NAME = 'weber'
    UNIT_SUFFIX = 'Wb'
    QUANTITY = 'magnetic flux'
    SI_UNIT = 'kg*m^2*s^-2*A^-1'
    DEFAULT_UNIT = True
    # V*s
class Tesla(Unit):
    UNIT_NAME = 'tesla'
    UNIT_SUFFIX = ''
    QUANTITY = 'T'
    SI_UNIT = 'kg*s^-2*A^-1'
    DEFAULT_UNIT = True
    # Wb/m2
class Henry(Unit):
    UNIT_NAME = 'henry'
    UNIT_SUFFIX = 'H'
    QUANTITY = 'inductance'
    SI_UNIT = 'kg*m^2*s^-2*A^-2'
    DEFAULT_UNIT = True
    # Wb/A
class DegreeCelcius(Unit):
    UNIT_NAME = 'degree celcuis'
    UNIT_SUFFIX = '°C'
    QUANTITY = 'temperature relative to 273.15 K'
    SI_UNIT = 'K'
class Lumen(Unit):
    UNIT_NAME = 'lumen'
    UNIT_SUFFIX = 'lm'
    QUANTITY = 'luminous flux'
    SI_UNIT = 'cd'
    # cd*sr
class Lux(Unit):
    UNIT_NAME = 'lux'
    UNIT_SUFFIX = 'lx'
    QUANTITY = 'illuminance'
    SI_UNIT = 'm^-2*cd'
    DEFAULT_UNIT = True
    # lm/m2
class Becquerel(Unit):
    UNIT_NAME = 'becquerel'
    UNIT_SUFFIX = 'Bq'
    QUANTITY = 'radioactivity (decays per unit time)'
    SI_UNIT = 's^-1' # same as Hertz
class Gray(Unit):
    UNIT_NAME = 'gray'
    UNIT_SUFFIX = 'Gy'
    QUANTITY = 'absorbed dose (of ionizing radiation)'
    SI_UNIT = 'm^2*s^-2'
    # J/kg
class Sievert(Unit):
    UNIT_NAME = 'sievert'
    UNIT_SUFFIX = 'Sv'
    QUANTITY = ' equivalent dose (of ionizing radiation)'
    SI_UNIT = 'm^2*s^-2'
class Katal(Unit):
    UNIT_NAME = 'katal'
    UNIT_SUFFIX = 'kat'
    QUANTITY = 'catalytic activity'
    SI_UNIT = 'mol*s^-1'
    DEFAULT_UNIT = True
####################################################################################################
# class Mil(Unit):
#     SCALE = 25.4e-6 # mm
#     SPICE_SUFFIX = 'mil'
</file>

<file path="PySpice/Unit/Unit.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
"""This module implements units.
A shortcut is defined for each unit prefix, e.g. :class:`pico`, :class:`nano`, :class:`micro`,
:class:`milli`, :class:`kilo`, :class:`mega`, :class:`tera`.
"""
# https://numpy.org/doc/stable/user/basics.subclassing.html#basics-subclassing
####################################################################################################
import logging
import collections.abc as collections
import math
# import numbers
import numpy as np
####################################################################################################
from PySpice.Tools.EnumFactory import EnumFactory
####################################################################################################
_module_logger = logging.getLogger(__name__)
####################################################################################################
class UnitPrefixMetaclass(type):
    """Metaclass to register unit prefixes"""
    _prefixes = {} # singletons
    ##############################################
    def __new__(meta, class_name, base_classes, attributes):
        cls = type.__new__(meta, class_name, base_classes, attributes)
        if class_name != 'UnitPrefix':
            meta.register_prefix(cls)
        return cls
    ##############################################
    @classmethod
    def register_prefix(meta, cls):
        power = cls.POWER
        if power is None:
            raise ValueError('Power is None for {}'.format(cls.__name__))
        meta._prefixes[power] = cls()
    ##############################################
    @classmethod
    def prefix_iter(cls):
        return cls._prefixes.values()
    ##############################################
    @classmethod
    def get(cls, power):
        return cls._prefixes[power]
####################################################################################################
class UnitPrefix(metaclass=UnitPrefixMetaclass):
    """This class implements a unit prefix like kilo"""
    POWER = None
    PREFIX = ''
    ##############################################
    def __repr__(self):
        return '{}({}, {})'.format(self.__class__.__name__, self.POWER, self.PREFIX)
    ##############################################
    def __int__(self):
        return self.POWER
    ##############################################
    def __str__(self):
        return self.PREFIX
    ##############################################
    @property
    def power(self):
        return self.POWER
    @property
    def prefix(self):
        return self.PREFIX
    @property
    def is_unit(self):
        return self.POWER == 0
    @property
    def scale(self):
        return 10**self.POWER
    ##############################################
    @property
    def spice_prefix(self):
        if hasattr(self, 'SPICE_PREFIX'):
            return self.SPICE_PREFIX
        else:
            return self.PREFIX
    ##############################################
    @property
    def is_defined_in_spice(self):
        return self.spice_prefix is not None
    ##############################################
    def __eq__(self, other):
        return self.POWER == other.POWER
    ##############################################
    def __ne__(self, other):
        return self.POWER != other.POWER
    ##############################################
    def __lt__(self, other):
        return self.POWER < other.POWER
    ##############################################
    def __gt__(self, other):
        return self.POWER > other.POWER
    ##############################################
    def str(self, spice=False):
        if spice:
            return self.spice_prefix
        else:
            return self.PREFIX
####################################################################################################
class ZeroPower(UnitPrefix):
    POWER = 0
    PREFIX = ''
    SPICE_PREFIX = ''
_zero_power = UnitPrefixMetaclass.get(0)
####################################################################################################
class SiDerivedUnit:
    """This class implements a unit defined as powers of SI base units.
    """
    # SI base units
    BASE_UNITS = (
        'm',
        'kg',
        's',
        'A',
        'K',
        'mol',
        'cd',
    )
    ##############################################
    def __init__(self, string=None, powers=None):
        if powers is not None:
            self._powers = self.new_powers()
            self._powers.update(powers)
        elif string is not None:
            self._powers = self.parse_si(string)
        else:
            self._powers = self.new_powers()
        self._hash = self.to_hash(self._powers)
        self._string = self.to_string(self._powers)
    ##############################################
    @property
    def powers(self):
        return self._powers
    @property
    def hash(self):
        return self._hash
    @property
    def string(self):
        return self._string
    def __str__(self):
        return self._string
    def __repr__(self):
        return '{}({})'.format(self.__class__.__name__, self._string)
    ##############################################
    @classmethod
    def new_powers(cls):
        return {unit: 0 for unit in cls.BASE_UNITS}
    ##############################################
    @classmethod
    def parse_si(cls, string):
        si_powers = cls.new_powers()
        if string:
            for prefixed_units in string.split('*'):
                parts = prefixed_units.split('^')
                unit = parts[0]
                if len(parts) == 1:
                    powers = 1
                else:
                    powers = int(parts[1])
                si_powers[unit] += powers
        return si_powers
    ##############################################
    @classmethod
    def to_hash(cls, powers):
        hash_ = ''
        for unit in cls.BASE_UNITS:
            hash_ += str(powers[unit])
        return hash_
    ##############################################
    @classmethod
    def to_string(cls, si_powers):
        units = []
        for unit in cls.BASE_UNITS:
            powers = si_powers[unit]
            if powers == 1:
                units.append(unit)
            elif powers > 1 or powers < 0:
                units.append('{}^{}'.format(unit, powers))
        return '*'.join(units)
    ##############################################
    # @property
    def is_base_unit(self):
        count = 0
        for powers in self._powers.values():
            if powers == 1:
                count += 1
            elif powers != 0:
                return False
        return count == 1
    ##############################################
    # @property
    def is_unit_less(self):
        return self._hash == '0'*len(self.BASE_UNITS)
    ##############################################
    def __bool__(self):
        return not self.is_unit_less()
    ##############################################
    def clone(self):
        return self.__class__(powers=self._powers)
    ##############################################
    def __eq__(self, other):
        return self._hash == other.hash
    ##############################################
    def __ne__(self, other):
        return self._hash != other.hash
    ##############################################
    def __mul__(self, other):
        powers = {unit: self._powers[unit] + other._powers[unit]
                  for unit in self.BASE_UNITS}
        return self.__class__(powers=powers)
    ##############################################
    def __imul__(self, other):
        for unit in self.BASE_UNITS:
            self._powers[unit] += other.powers[unit]
        self._hash = self.to_hash(self._powers)
        self._string = self.to_string(self._powers)
        return self
    ##############################################
    def __truediv__(self, other):
        powers = {unit: self._powers[unit] - other._powers[unit]
                  for unit in self.BASE_UNITS}
        return self.__class__(powers=powers)
    ##############################################
    def __itruediv__(self, other):
        for unit in self.BASE_UNITS:
            self._powers[unit] -= other.powers[unit]
        self._hash = self.to_hash(self._powers)
        self._string = self.to_string(self._powers)
        return self
    ##############################################
    def power(self, value):
        powers = {unit: self._powers[unit] * value
                  for unit in self.BASE_UNITS}
        return self.__class__(powers=powers)
    ##############################################
    def reciprocal(self):
        return self.power(-1)
    ##############################################
    def sqrt(self):
        return self.power(1/2)
    ##############################################
    def square(self):
        return self.power(2)
    ##############################################
    def cbrt(self):
        return self.power(1/3)
####################################################################################################
class UnitMetaclass(type):
    """Metaclass to register units"""
    _units = {}
    _hash_map = {}
    ##############################################
    def __new__(meta, class_name, base_classes, attributes):
        cls = type.__new__(meta, class_name, base_classes, attributes)
        meta.init_unit(cls)
        meta.register_unit(cls)
        return cls
    ##############################################
    @classmethod
    def init_unit(meta, cls):
        si_unit = cls.SI_UNIT
        if not (isinstance(si_unit, SiDerivedUnit) and si_unit):
            # si_unit is not defined
            if cls.is_base_unit():
                si_unit = SiDerivedUnit(cls.UNIT_SUFFIX)
            else: # str
                si_unit = SiDerivedUnit(si_unit)
            cls.SI_UNIT = si_unit
    ##############################################
    @classmethod
    def register_unit(meta, cls):
        obj = cls()
        meta._units[obj.unit_suffix] = obj
        if obj.si_unit:
            hash_ = obj.si_unit.hash
            if hash_ in meta._hash_map:
                meta._hash_map[hash_].append(obj)
            else:
                meta._hash_map[hash_] = [obj]
    ##############################################
    @classmethod
    def unit_iter(meta):
        return meta._units.values()
    ##############################################
    @classmethod
    def from_prefix(meta, prefix):
        return meta._units__.get(prefix, None)
    ##############################################
    @classmethod
    def from_hash(meta, hash_):
        return meta._hash_map.get(hash_, None)
    ##############################################
    @classmethod
    def from_si_unit(meta, si_unit, unique=True):
        # Fixme:
        #  - handle power of units
        #      unit -> numpy vector, divide and test for identical factor
        #      define unit, format as V^2
        #  - complex unit
        units = meta._hash_map.get(si_unit.hash, None)
        if unique and units is not None:
            if len(units) > 1:
                units = [unit for unit in units if unit.is_default_unit()]
                if len(units) == 1:
                    return units[0]
                else:
                    raise NameError("Unit clash", units)
            else:
                return units[0]
        else:
            return units
####################################################################################################
class UnitError(ValueError):
    pass
####################################################################################################
class Unit(metaclass=UnitMetaclass):
    """This class implements a unit.
    """
    UNIT_NAME = ''
    UNIT_SUFFIX = ''
    QUANTITY = ''
    SI_UNIT = SiDerivedUnit()
    DEFAULT_UNIT = False
    # SPICE_SUFFIX = ''
    _logger = _module_logger.getChild('Unit')
    ##############################################
    def __init__(self, si_unit=None):
        self._unit_name = self.UNIT_NAME
        self._unit_suffix = self.UNIT_SUFFIX
        self._quantity = self.QUANTITY
        if si_unit is None:
            self._si_unit = self.SI_UNIT
        else:
            self._si_unit = si_unit
    ##############################################
    def __repr__(self):
        return '{0}({1})'.format(self.__class__.__name__, str(self))
    ##############################################
    @property
    def unit_name(self):
        return self._unit_name
    @property
    def unit_suffix(self):
        return self._unit_suffix
    @property
    def quantity(self):
        return self._quantity
    @property
    def si_unit(self):
        return self._si_unit
    ##############################################
    @property
    def is_unit_less(self):
        return self._si_unit.is_unit_less()
    ##############################################
    @classmethod
    def is_default_unit(cls):
        return cls.DEFAULT_UNIT
    @classmethod
    def is_base_unit(cls):
        return False
    ##############################################
    def __eq__(self, other):
        """self == other"""
        return self._si_unit == other.si_unit
    ##############################################
    def __ne__(self, other):
        """self != other"""
        # The default __ne__ doesn't negate __eq__ until 3.0.
        return not (self == other)
    ##############################################
    def _equivalent_prefixed_unit(self, si_unit):
        equivalent_unit = PrefixedUnit.from_si_unit(si_unit)
        if equivalent_unit is not None:
            return equivalent_unit
        else:
            return PrefixedUnit(Unit(si_unit))
    ##############################################
    def _equivalent_unit(self, si_unit):
        equivalent_unit = UnitMetaclass.from_si_unit(si_unit)
        if equivalent_unit is not None:
            return equivalent_unit
        else:
            return Unit(si_unit)
    ##############################################
    def _equivalent_unit_or_power(self, si_unit, prefixed_unit):
        if prefixed_unit:
            return self._equivalent_prefixed_unit(si_unit)
        else:
            return self._equivalent_unit(si_unit)
    ##############################################
    def multiply(self, other, prefixed_unit=False):
        si_unit = self._si_unit * other.si_unit
        return self._equivalent_unit_or_power(si_unit, prefixed_unit)
    ##############################################
    def divide(self, other, prefixed_unit=False):
        si_unit = self._si_unit / other.si_unit
        return self._equivalent_unit_or_power(si_unit, prefixed_unit)
    ##############################################
    def power(self, exponent, prefixed_unit=False):
        si_unit = self._si_unit.power(exponent)
        return self._equivalent_unit_or_power(si_unit, prefixed_unit)
    ##############################################
    def reciprocal(self, prefixed_unit=False):
        si_unit = self._si_unit.reciprocal()
        return self._equivalent_unit_or_power(si_unit, prefixed_unit)
    ##############################################
    def sqrt(self, prefixed_unit=False):
        si_unit = self._si_unit.sqrt()
        return self._equivalent_unit_or_power(si_unit, prefixed_unit)
    ##############################################
    def square(self, prefixed_unit=False):
        si_unit = self._si_unit.square()
        return self._equivalent_unit_or_power(si_unit, prefixed_unit)
    ##############################################
    def cbrt(self, prefixed_unit=False):
        si_unit = self._si_unit.cbrt()
        return self._equivalent_unit_or_power(si_unit, prefixed_unit)
    ##############################################
    def __str__(self):
        if self._unit_suffix:
            return self._unit_suffix
        else:
            return str(self._si_unit)
    ##############################################
    def is_same_unit(self, value):
        return value.unit == self
    ##############################################
    def validate(self, value, none=False):
        if none and value is None:
            return None
        if isinstance(value, UnitValue):
            if  self.is_same_unit(value):
                return value
            else:
                raise UnitError
        else:
            prefixed_unit = PrefixedUnit.from_prefixed_unit(self)
            return prefixed_unit.new_value(value)
####################################################################################################
class SiBaseUnit(Unit):
    """This class implements an SI base unit."""
    ##############################################
    @classmethod
    def is_base_unit(cls):
        return True
    ##############################################
    @classmethod
    def is_default_unit(cls):
        return True
####################################################################################################
class PrefixedUnit:
    """This class implements a prefixed unit.
    """
    _unit_map = {} # Prefixed unit singletons
    _prefixed_unit_map = {}
    _value_ctor = None
    _values_ctor = None
    ##############################################
    @classmethod
    def register(cls, prefixed_unit):
        unit = prefixed_unit.unit
        unit_prefix = prefixed_unit.power
        if unit_prefix.is_unit and unit.is_default_unit():
            key = unit.si_unit.hash
            # print('Register', key, prefixed_unit)
            cls._unit_map[key] = prefixed_unit
        if unit.unit_suffix:
            unit_key = str(unit)
        else:
            unit_key = '_'
        power_key = unit_prefix.power
        # print('Register', unit_key, power_key, prefixed_unit)
        if unit_key not in cls._prefixed_unit_map:
            cls._prefixed_unit_map[unit_key] = {}
        cls._prefixed_unit_map[unit_key][power_key] = prefixed_unit
    ##############################################
    @classmethod
    def from_si_unit(cls, si_unit):
        return cls._unit_map.get(si_unit.hash, None)
    ##############################################
    @classmethod
    def from_prefixed_unit(cls, unit, power=0):
        if unit.unit_suffix:
            unit_key = str(unit)
        else:
            if power == 0:
                return _simple_prefixed_unit
            unit_key = '_'
        try:
            return cls._prefixed_unit_map[unit_key][power]
        except KeyError:
            return None
    ##############################################
    def __init__(self, unit=None, power=None, value_ctor=None, values_ctor=None):
        if unit is None:
            self._unit = Unit()
        else:
            self._unit = unit
        if power is None:
            self._power = _zero_power
        else:
            self._power = power
        if value_ctor is not None:
            self._value_ctor = value_ctor
        if values_ctor is not None:
            self._values_ctor = values_ctor
    ##############################################
    def __repr__(self):
        return '{0}({1})'.format(self.__class__.__name__, str(self))
    ##############################################
    @property
    def unit(self):
        return self._unit
    @property
    def power(self):
        return self._power
    @property
    def scale(self):
        return self._power.scale
    ##############################################
    @property
    def is_unit_less(self):
        return self._unit.is_unit_less
    ##############################################
    def clone(self):
        return self.__class__(self._unit, self._power)
    ##############################################
    def is_same_unit(self, other):
        return self._unit == other.unit
    ##############################################
    def check_unit(self, other):
        if not self.is_same_unit(other):
            raise UnitError('{} versus {}'.format(self, other))
    ##############################################
    def is_same_power(self, other):
        return self._power == other.power
    ##############################################
    def __eq__(self, other):
        """self == other"""
        return self.is_same_unit(other) and self.is_same_power(other)
    ##############################################
    def __ne__(self, other):
        """self != other"""
        # The default __ne__ doesn't negate __eq__ until 3.0.
        return not (self == other)
    ##############################################
    def str(self, spice=False, unit=True):
        # Ngspice User Manual Section 2.3.1  Some naming conventions
        #
        # Letters immediately following a number that are not scale factors are ignored, and
        # letters immediately following a scale factor are ignored.
        #
        # Hence, 10, 10V, 10Volts, and 10Hz all represent the same number, and
        # M, MA, MSec, and  MMhos all represent the same scale factor.
        #
        # Note that 1000, 1000.0, 1000Hz, 1e3, 1.0e3, 1kHz, and 1k all represent the same number.
        # >>> WARNING <<<
        #   Note that M or m denote ’milli’, i.e. 10−3 . Suffix meg has to be used for 106.
        #   see SPICE_PREFIX in SiUnits
        # Fixme: unit clash, e.g. mm ???
        string = self._power.str(spice)
        if unit:
            string += str(self._unit)
        if spice:
            # F is interpreted as f = femto
            if string == 'F':
                string = ''
            else:
                # Ngspice don't support utf-8
                # degree symbole can be encoded str(176) in Extended ASCII
                string = string.replace('°', '')  # U+00B0
                string = string.replace('℃', '')  # U+2103
                # U+2109 ℉
                string = string.replace('Ω', 'Ohm')  # U+CEA0
                string = string.replace('μ',   'u')  # U+CEBC
        return string
    ##############################################
    def str_spice(self):
        return self.str(spice=True, unit=True)
    ##############################################
    def __str__(self):
        return self.str(spice=False, unit=True)
    ##############################################
    def new_value(self, value):
        if isinstance(value, np.ndarray):
            return self._values_ctor.from_ndarray(value, self)
        elif isinstance(value, collections.Iterable):
            return [self._value_ctor(self, x) for x in value]
        else:
            return self._value_ctor(self, value)
####################################################################################################
class UnitValue: # numbers.Real
    """This class implements a value with a unit and a power (prefix).
    The value is not converted to float if the value is an int.
    """
    _logger = _module_logger.getChild('UnitValue')
    ##############################################
    @classmethod
    def simple_value(cls, value):
        return cls(_simple_prefixed_unit, value)
    ##############################################
    def __init__(self, prefixed_unit, value):
        self._prefixed_unit = prefixed_unit
        if isinstance(value, UnitValue):
            # Fixme: anonymous ???
            if not self.is_same_unit(value):
                raise UnitError
            if self.is_same_power(value):
                self._value = value.value
            else:
                self._value = self._convert_scalar_value(value)
        elif isinstance(value, int):
            self._value = value # to keep as int
        else:
            self._value = float(value)
    ##############################################
    def __repr__(self):
        return '{0}({1})'.format(self.__class__.__name__, str(self))
    ##############################################
    @property
    def prefixed_unit(self):
        return self._prefixed_unit
    @property
    def unit(self):
        return self._prefixed_unit.unit
    @property
    def power(self):
        return self._prefixed_unit.power
    @property
    def scale(self):
        return self._prefixed_unit.power.scale
    @property
    def value(self):
        return self._value
    ##############################################
    def clone(self):
        return self.__class__(self._prefixed_unit, self._value)
    ##############################################
    def clone_prefixed_unit(self, value):
        return self.__class__(self._prefixed_unit, value)
    ##############################################
    # def to_unit_values(self):
    #     return self._prefixed_unit.new_value(self._value)
    ##############################################
    # def clone_unit(self, value, power):
    #     return self.__class__(PrefixedUnit(self.unit, power), value)
    ##############################################
    def is_same_unit(self, other):
        return self._prefixed_unit.is_same_unit(other.prefixed_unit)
    ##############################################
    def _check_unit(self, other):
        if not self.is_same_unit(other):
            raise UnitError
    ##############################################
    def is_same_power(self, other):
        return self._prefixed_unit.is_same_power(other.prefixed_unit)
    ##############################################
    def __eq__(self, other):
        """self == other"""
        if isinstance(other, UnitValue):
            return self.is_same_unit(other) and float(self) == float(other)
        else:
            return float(self) == float(other)
    ##############################################
    def __ne__(self, other):
        """self != other"""
        # The default __ne__ doesn't negate __eq__ until 3.0.
        return not (self == other)
    ##############################################
    def _convert_value(self, other):
        """Convert the value of other to the power of self."""
        self._check_unit(other)
        if self.is_same_power(other):
            return other.value
        else:
            return other.value * (other.scale / self.scale) # for numerical precision
    ##############################################
    def _convert_scalar_value(self, value):
        return float(value) / self.scale
    ##############################################
    def __int__(self):
        return int(self._value * self.scale)
    ##############################################
    def __float__(self):
        return float(self._value * self.scale)
    ##############################################
    def str(self, spice=False, space=False, unit=True):
        string = str(self._value)
        if space:
            string += ' '
        string += self._prefixed_unit.str(spice, unit)
        return string
    ##############################################
    def str_space(self):
        return self.str(space=True)
    ##############################################
    def str_spice(self):
        return self.str(spice=True, space=False, unit=True)
    ##############################################
    def __str__(self):
        return self.str(spice=False, space=True, unit=True)
    ##############################################
    def __bool__(self):
        """True if self != 0. Called for bool(self)."""
        return self._value != 0
    ##############################################
    def __add__(self, other):
        """self + other"""
        if (isinstance(other, UnitValue)):
            self._check_unit(other)
            new_obj = self.clone()
            new_obj._value += self._convert_value(other)
            return new_obj
        else:
            return float(self) + other
    ##############################################
    def __iadd__(self, other):
        """self += other"""
        self._check_unit(other)
        self._value += self._convert_value(other)
        return self
    ##############################################
    def __radd__(self, other):
        """other + self"""
        return float(self) + other
    ##############################################
    def __neg__(self):
        """-self"""
        return self.clone_prefixed_unit(-self._value)
    ##############################################
    def __pos__(self):
        """+self"""
        return self.clone()
    ##############################################
    def __sub__(self, other):
        """self - other"""
        if (isinstance(other, UnitValue)):
            self._check_unit(other)
            new_obj = self.clone()
            new_obj._value -= self._convert_value(other)
            return new_obj
        else:
            return float(self) - other
    ##############################################
    def __isub__(self, other):
        """self -= other"""
        self._check_unit(other)
        self._value -= self._convert_value(other)
        return self
    ##############################################
    def __rsub__(self, other):
        """other - self"""
        return other - float(self)
    ##############################################
    def __mul__(self, other):
        """self * other"""
        if (isinstance(other, UnitValue)):
            equivalent_unit = self.unit.multiply(other.unit, True)
            value = float(self) * float(other)
            return equivalent_unit.new_value(value)
        else:
            try: # scale value
                scalar = float(other)
                new_obj = self.clone()
                new_obj._value *= scalar
                return new_obj
            except (ValueError, TypeError): # Numpy raises TypeError
                return float(self) * other
    ##############################################
    def __imul__(self, other):
        """self *= other"""
        if (isinstance(other, UnitValue)):
            raise UnitError
        else: # scale value
            # Fixme: right ?
            self._value *= self._convert_value(other)
            return self
    ##############################################
    def __rmul__(self, other):
        """other * self"""
        if (isinstance(other, UnitValue)):
            raise NotImplementedError # Fixme: when ???
        else: # scale value
            return self.__mul__(other)
    ##############################################
    def __floordiv__(self, other):
        """self // other """
        if (isinstance(other, UnitValue)):
            equivalent_unit = self.unit.divide(other.unit, True)
            value = float(self) // float(other)
            return equivalent_unit.new_value(value)
        else:
            try: # scale value
                scalar = float(other)
                new_obj = self.clone()
                new_obj._value //= scalar
                return new_obj
            except (ValueError, TypeError): # Numpy raises TypeError
                return float(self) // other
    ##############################################
    def __ifloordiv__(self, other):
        """self //= other """
        if (isinstance(other, UnitValue)):
            raise NotImplementedError
        else: # scale value
            self._value //= float(other)
            return self
    ##############################################
    def __rfloordiv__(self, other):
        """other // self"""
        if (isinstance(other, UnitValue)):
            raise NotImplementedError # Fixme: when ???
        else: # scale value
            return other // float(self)
    ##############################################
    def __truediv__(self, other):
        """self / other"""
        if (isinstance(other, UnitValue)):
            equivalent_unit = self.unit.divide(other.unit, True)
            value = float(self) / float(other)
            return equivalent_unit.new_value(value)
        else:
            try: # scale value
                scalar = float(other)
                new_obj = self.clone()
                new_obj._value /= scalar
                return new_obj
            except (ValueError, TypeError): # Numpy raises TypeError
                return float(self) / other
    ##############################################
    def __itruediv__(self, other):
        """self /= other"""
        if (isinstance(other, UnitValue)):
            raise NotImplementedError
        else: # scale value
            self._value /= float(other)
            return self
    ##############################################
    def __rtruediv__(self, other):
        """other / self"""
        if (isinstance(other, UnitValue)):
            raise NotImplementedError # Fixme: when ???
        else: # scale value
            return other / float(self)
    ##############################################
    def __pow__(self, exponent):
        """self**exponent; should promote to float or complex when necessary."""
        new_obj = self.clone()
        new_obj._value **= float(exponent)
        return new_obj
    ##############################################
    def __ipow__(self, exponent):
        self._value **= float(exponent)
        return self
    ##############################################
    def __rpow__(self, base):
        """base ** self"""
        raise NotImplementedError
    ##############################################
    def __abs__(self):
        """Returns the Real distance from 0. Called for abs(self)."""
        return self.clone_prefixed_unit(abs(self._value))
    ##############################################
    def __trunc__(self):
        """trunc(self): Truncates self to an Integral.
        Returns an Integral i such that:
          * i>0 iff self>0;
          * abs(i) <= abs(self);
          * for any Integral j satisfying the first two conditions,
            abs(i) >= abs(j) [i.e. i has "maximal" abs among those].
        i.e. "truncate towards 0".
        """
        raise NotImplementedError
    ##############################################
    def __divmod__(self, other):
        """divmod(self, other): The pair (self // other, self % other).
        Sometimes this can be computed faster than the pair of
        operations.
        """
        return (self // other, self % other)
    ##############################################
    def __rdivmod__(self, other):
        """divmod(other, self): The pair (self // other, self % other).
        Sometimes this can be computed faster than the pair of
        operations.
        """
        return (other // self, other % self)
    ##############################################
    def __mod__(self, other):
        """self % other"""
        raise NotImplementedError
    ##############################################
    def __rmod__(self, other):
        """other % self"""
        raise NotImplementedError
    ##############################################
    def __lt__(self, other):
        """self < other
        < on Reals defines a total ordering, except perhaps for NaN.
        """
        return float(self) < float(other)
    ##############################################
    def __le__(self, other):
        """self <= other"""
        return float(self) <= float(other)
    ##############################################
    def __ceil__(self):
        return math.ceil(float(self))
    ##############################################
    def __floor__(self):
        return math.floor(float(self))
    ##############################################
    def __round__(self):
        return round(float(self))
    ##############################################
    def reciprocal(self):
        equivalent_unit = self.unit.reciprocal(prefixed_unit=True)
        reciprocal_value = 1. / float(self)
        return equivalent_unit.new_value(reciprocal_value)
    ##############################################
    def get_prefixed_unit(self, power=0):
        prefixed_unit = PrefixedUnit.from_prefixed_unit(self.unit, power)
        if prefixed_unit is not None:
            return prefixed_unit
        else:
            raise NameError("Prefixed unit not found for {} and power {}".format(self, power))
    ##############################################
    def convert(self, prefixed_unit):
        """Convert the value to another power."""
        self._prefixed_unit.check_unit(prefixed_unit)
        if self._prefixed_unit.is_same_power(prefixed_unit):
            return self
        else:
            value = float(self) / prefixed_unit.scale
            return prefixed_unit.new_value(value)
    ##############################################
    def convert_to_power(self, power=0):
        """Convert the value to another power."""
        if power == 0:
            value = float(self)
        else:
            value = float(self) / 10**power
        return self.get_prefixed_unit(power).new_value(value)
    ##############################################
    def canonise(self):
        # log10(10**n) = n    log10(1) = 0   log10(10**-n) = -n   log10(0) = -oo
        try:
            abs_value = abs(float(self))
            log = math.log(abs_value)/math.log(1000)
            # if abs_value >= 1:
            #     power = 3 * int(log)
            # else:
            #     if log - int(log): # frac
            #         power = 3 * (int(log) -1)
            #     else:
            #         power = 3 * int(log)
            power = int(log)
            if abs_value < 1 and (log - int(log)):
                power -= 1
            power *= 3
            # print('Unit.canonise', self, self._value, int(self._power), '->', float(self), power)
            if power == int(self.power):
                # print('Unit.canonise noting to do for', self)
                return self
            else:
                # print('Unit.canonise convert', self, 'to', power)
                # print('Unit.canonise convert', self, 'to', Unit)
                return self.convert_to_power(power)
        except Exception as e: # Fixme: fallback
            self._logger.warning(e)
            return self
####################################################################################################
class UnitValues(np.ndarray):
    """This class implements a Numpy array with a unit and a power (prefix).
    """
    _logger = _module_logger.getChild('UnitValues')
    CONVERSION = EnumFactory('ConversionType', (
        'NOT_IMPLEMENTED',
        'NO_CONVERSION',
        'FLOAT',
        'UNIT_MATCH',
        'UNIT_MATCH_NO_OUT_CAST',
        'NEW_UNIT'
        ))
    # Reference_documentation:
    #   https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.ndarray.html
    #   https://docs.scipy.org/doc/numpy-1.13.0/user/basics.subclassing.html
    #   https://docs.scipy.org/doc/numpy-1.13.0/reference/ufuncs.html
    UFUNC_MAP = {
        # Math operations
        # --------------------------------------------------
        np.add:          CONVERSION.UNIT_MATCH,
        np.subtract:     CONVERSION.UNIT_MATCH,
        np.multiply:     CONVERSION.NEW_UNIT,
        np.divide:       CONVERSION.NEW_UNIT,
        np.logaddexp:    CONVERSION.FLOAT,
        np.logaddexp2:   CONVERSION.FLOAT,
        np.true_divide:  CONVERSION.NEW_UNIT,
        np.floor_divide: CONVERSION.NEW_UNIT,
        np.negative:     CONVERSION.NO_CONVERSION,
        np.positive:     CONVERSION.NO_CONVERSION,
        np.power:        CONVERSION.NEW_UNIT,
        np.remainder:    CONVERSION.UNIT_MATCH,
        np.mod:          CONVERSION.UNIT_MATCH,
        np.fmod:         CONVERSION.UNIT_MATCH,
        np.divmod:       CONVERSION.UNIT_MATCH,
        np.absolute:     CONVERSION.NO_CONVERSION,
        np.fabs:         CONVERSION.NO_CONVERSION,
        np.rint:         CONVERSION.NO_CONVERSION,
        np.sign:         CONVERSION.NO_CONVERSION,
        np.heaviside:    CONVERSION.NOT_IMPLEMENTED, # !
        np.conj:         CONVERSION.NOT_IMPLEMENTED, # !
        np.exp:          CONVERSION.FLOAT,
        np.exp2:         CONVERSION.FLOAT,
        np.log:          CONVERSION.FLOAT,
        np.log2:         CONVERSION.FLOAT,
        np.log10:        CONVERSION.FLOAT,
        np.expm1:        CONVERSION.FLOAT,
        np.log1p:        CONVERSION.FLOAT,
        np.sqrt:         CONVERSION.NEW_UNIT,
        np.square:       CONVERSION.NEW_UNIT,
        np.cbrt:         CONVERSION.NEW_UNIT,
        np.reciprocal:   CONVERSION.NEW_UNIT,
        # Trigonometric functions
        # --------------------------------------------------
        np.sin:     CONVERSION.FLOAT,
        np.cos:     CONVERSION.FLOAT,
        np.tan:     CONVERSION.FLOAT,
        np.arcsin:  CONVERSION.FLOAT,
        np.arccos:  CONVERSION.FLOAT,
        np.arctan:  CONVERSION.FLOAT,
        np.arctan2: CONVERSION.FLOAT,
        np.hypot:   CONVERSION.FLOAT,
        np.sinh:    CONVERSION.FLOAT,
        np.cosh:    CONVERSION.FLOAT,
        np.tanh:    CONVERSION.FLOAT,
        np.arcsinh: CONVERSION.FLOAT,
        np.arccosh: CONVERSION.FLOAT,
        np.arctanh: CONVERSION.FLOAT,
        np.deg2rad: CONVERSION.FLOAT,
        np.rad2deg: CONVERSION.FLOAT,
        # Bit-twiddling functions
        # --------------------------------------------------
        np.bitwise_and: CONVERSION.NOT_IMPLEMENTED, # Nonsense
        np.bitwise_or:  CONVERSION.NOT_IMPLEMENTED, # Nonsense
        np.bitwise_xor: CONVERSION.NOT_IMPLEMENTED, # Nonsense
        np.invert:      CONVERSION.NOT_IMPLEMENTED, # Nonsense
        np.left_shift:  CONVERSION.NOT_IMPLEMENTED, # Nonsense
        np.right_shift: CONVERSION.NOT_IMPLEMENTED, # Nonsense
        # Comparison functions
        # --------------------------------------------------
        np.greater:       CONVERSION.UNIT_MATCH_NO_OUT_CAST,
        np.greater_equal: CONVERSION.UNIT_MATCH_NO_OUT_CAST,
        np.less:          CONVERSION.UNIT_MATCH_NO_OUT_CAST,
        np.less_equal:    CONVERSION.UNIT_MATCH_NO_OUT_CAST,
        np.not_equal:     CONVERSION.UNIT_MATCH_NO_OUT_CAST,
        np.equal:         CONVERSION.UNIT_MATCH_NO_OUT_CAST,
        np.logical_and:   CONVERSION.UNIT_MATCH,
        np.logical_or:    CONVERSION.UNIT_MATCH,
        np.logical_xor:   CONVERSION.UNIT_MATCH,
        np.logical_not:   CONVERSION.UNIT_MATCH,
        np.maximum:       CONVERSION.UNIT_MATCH,
        np.minimum:       CONVERSION.UNIT_MATCH,
        np.fmax:          CONVERSION.UNIT_MATCH,
        np.fmin:          CONVERSION.UNIT_MATCH,
        # Floating functions
        # --------------------------------------------------
        np.isfinite:  CONVERSION.NOT_IMPLEMENTED, # ! _T
        np.isinf:     CONVERSION.NOT_IMPLEMENTED, # ! _T
        np.isnan:     CONVERSION.NOT_IMPLEMENTED, # ! _T
        np.fabs:      CONVERSION.NOT_IMPLEMENTED, # ! _
        np.signbit:   CONVERSION.NOT_IMPLEMENTED, # ! _T
        np.copysign:  CONVERSION.NOT_IMPLEMENTED, # !
        np.nextafter: CONVERSION.NOT_IMPLEMENTED, # !
        np.spacing:   CONVERSION.NOT_IMPLEMENTED, # !
        np.modf:      CONVERSION.NOT_IMPLEMENTED, # !
        np.ldexp:     CONVERSION.NOT_IMPLEMENTED, # !
        np.frexp:     CONVERSION.NOT_IMPLEMENTED, # !
        np.fmod:      CONVERSION.NOT_IMPLEMENTED, # !
        np.floor:     CONVERSION.NOT_IMPLEMENTED, # !
        np.ceil:      CONVERSION.NO_CONVERSION,
        np.trunc:     CONVERSION.NO_CONVERSION,
        # Statistic functions
        # --------------------------------------------------
        np.mean:      CONVERSION.NO_CONVERSION,
    }
    ##############################################
    @classmethod
    def from_ndarray(cls, array, prefixed_unit):
        # cls._logger.debug('UnitValues.__new__ ' + str((cls, array, prefixed_unit)))
        # obj = cls(prefixed_unit, array.shape, array.dtype) # Fixme: buffer ???
        # obj[...] = array[...]
        obj = array.view(UnitValues)
        obj._prefixed_unit = prefixed_unit
        if isinstance(array, UnitValues):
            return array.convert(prefixed_unit)
        return obj
    ##############################################
    def __new__(cls,
                prefixed_unit,
                shape, dtype=float, buffer=None, offset=0, strides=None, order=None):
        # Called for explicit constructor
        #  obj = UnitValues(prefixed_unit, shape)
        # cls._logger.debug('UnitValues.__new__ ' + str((cls, prefixed_unit, shape, dtype, buffer, offset, strides, order)))
        obj = super(UnitValues, cls).__new__(cls, shape, dtype, buffer, offset, strides, order)
        # obj = np.asarray(input_array).view(cls)
        obj._prefixed_unit = prefixed_unit
        return obj
    ##############################################
    def __array_finalize__(self, obj):
        # self._logger.debug('UnitValues.__new__ ' + '\n  {}'.format(obj))
        # self is a new object resulting from ndarray.__new__(UnitValues, ...)
        # therefore it only has attributes that the ndarray.__new__ constructor gave it
        # i.e. those of a standard ndarray.
        # We could have got to the ndarray.__new__ call in 3 ways:
        # From an explicit constructor - e.g. UnitValues():
        #    obj is None
        #    we are in the middle of the UnitValues.__new__ constructor
        if obj is None:
            return
        # From view casting - e.g arr.view(UnitValues):
        #    obj is arr
        #    type(obj) can be UnitValues
        # From new-from-template - e.g infoarr[:3]
        #    type(obj) is UnitValues
        self._prefixed_unit = getattr(obj, '_prefixed_unit', None) # Fixme: None
    ##############################################
    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
        # - "ufunc" is the ufunc object that was called
        # - "method" is a string indicating how the ufunc was called, either
        #       "__call__" to indicate it was called directly,
        #       or one of its "ufuncs.methods": "reduce", "accumulate",  "reduceat", "outer", or "at".
        # - "inputs" is a tuple of the input arguments to the ufunc
        # - "kwargs" contains any optional or keyword arguments passed to the function.
        #    This includes any *out* arguments, which are always contained in a tuple.
        # ufunc.reduce(a[, axis, dtype, out, keepdims])     Reduces a‘s dimension by one, by applying ufunc along one axis.
        # ufunc.accumulate(array[, axis, dtype, out, ...])  Accumulate the result of applying the operator to all elements.
        # ufunc.reduceat(a, indices[, axis, dtype, out])    Performs a (local) reduce with specified slices over a single axis.
        # ufunc.outer(A, B, **kwargs)                       Apply the ufunc op to all pairs (a, b) with a in A and b in B.
        # ufunc.at(a, indices[, b])                         Performs unbuffered in place operation on operand ‘a’ for elements specified by ‘indices’.
        # self._logger.debug(
        #     '\n  self={}\n  ufunc={}\n  method={}\n  inputs={}\n  kwargs={}'
        #     .format(self, ufunc, method, inputs, kwargs))
        # ufunc=<ufunc 'multiply'>
        # method=__call__
        # inputs=(UnitValues(mV, [0 1 2 3 4 5 6 7 8 9]), 2)
        # ufunc=<ufunc 'sin'>
        # method=__call__
        # inputs=(UnitValues(mV, [0 1 2 3 4 5 6 7 8 9]),)
        # kwargs={}
        # ufunc=<ufunc 'add'>
        # method=__call__
        # inputs=(UnitValues(mV, [0 1 2 3 4 5 6 7 8 9]), UnitValues(mV, [0 1 2 3 4 5 6 7 8 9]))
        # ufunc=<ufunc 'add'>
        # method=reduce
        # inputs=(WaveForm  [10 12 14 16 18 20 22 24 26 28]@mV,)
        prefixed_unit = self._prefixed_unit
        conversion = self.UFUNC_MAP[ufunc]
        self._logger.debug("Conversion for {} is {}".format(ufunc, conversion))
        # e.g. np.mean do an internal call to reduce
        if method != '__call__':
            conversion = self.CONVERSION.NO_CONVERSION
        # Cast inputs to ndarray
        args = []
        if conversion == self.CONVERSION.NO_CONVERSION:
            # should be 1 arg
            args = [( input_.as_ndarray(False) if isinstance(input_, UnitValues) else input_ )
                    for input_ in inputs]
        #
        elif conversion == self.CONVERSION.FLOAT:
            if not prefixed_unit.is_unit_less:
                # raise ValueError("Must be unit less")
                self._logger.warning("Should be unit less")
            args = [( input_.as_ndarray(True) if isinstance(input_, UnitValues) else input_ )
                    for input_ in inputs]
        #
        elif conversion in (self.CONVERSION.UNIT_MATCH, self.CONVERSION.UNIT_MATCH_NO_OUT_CAST):
            # len(inputs) == 2
            other = inputs[1]
            if isinstance(other, (UnitValues, UnitValue)):
                self._check_unit(other)
                args.append(self.as_ndarray())
                nd_other = self._convert_value(other)
                if isinstance(other, UnitValues):
                    nd_other = nd_other.as_ndarray()
                elif isinstance(other, UnitValue):
                    nd_other = float(nd_other)
                args.append(nd_other)
            else:
                raise ValueError
        #
        elif conversion == self.CONVERSION.NEW_UNIT:
            if len(inputs) == 1:
                #! Fixme: power
                if ufunc == np.sqrt:
                    prefixed_unit = self.unit.sqrt(True)
                elif ufunc == np.square:
                    prefixed_unit = self.unit.square(True)
                elif ufunc == np.cbrt:
                    prefixed_unit = self.unit.cbrt(True)
                elif ufunc == np.reciprocal:
                    prefixed_unit = self.unit.reciprocal(True)
                else:
                    raise NotImplementedError
                args.append(self.as_ndarray(True))
            elif len(inputs) == 2:
                other = inputs[1]
                if isinstance(other, (UnitValues, UnitValue)):
                    if ufunc == np.multiply:
                        prefixed_unit = self.unit.multiply(other.unit, True)
                    elif ufunc in (np.divide, np.true_divide, np.floor_divide):
                        prefixed_unit = self.unit.divide(other.unit, True)
                    else:
                        raise NotImplementedError
                    args.append(self.as_ndarray(True))
                    if isinstance(other, UnitValue):
                        args.append(float(other))
                    else:
                        args.append(other.as_ndarray(True))
                elif ufunc in (np.multiply, np.divide, np.true_divide, np.floor_divide, np.power):
                    if ufunc == np.power:
                        prefixed_unit = self.unit.power(other, True)
                    args.append(self.as_ndarray())
                    args.append(other)
                else:
                    raise NotImplementedError
            else:
                raise NotImplementedError
        #
        else: # self.CONVERSION.NOT_IMPLEMENTED
            raise NotImplementedError
        # self._logger.debug("Output unit is {}".format(prefixed_unit))
        # Cast outputs to ndarray
        outputs = kwargs.pop('out', None)
        if outputs:
            out_args = []
            for output in outputs:
                if isinstance(output, UnitValues):
                    out_args.append(output.as_ndarray())
                else:
                    out_args.append(output)
            kwargs['out'] = tuple(out_args)
        else:
            outputs = (None,) * ufunc.nout
        # Call ufunc
        results = super(UnitValues, self).__array_ufunc__(ufunc, method, *args, **kwargs)
        if results is NotImplemented:
            return NotImplemented
        # ensure results is a tuple
        if ufunc.nout == 1:
            results = (results,)
        # Cast results
        if conversion in (self.CONVERSION.FLOAT, self.CONVERSION.UNIT_MATCH_NO_OUT_CAST):
            # Fixme: ok ???
            results = tuple(( result if output is None else output )
                            for result, output in zip(results, outputs))
        else:
            results = tuple(( UnitValues.from_ndarray(np.asarray(result), prefixed_unit) if output is None else output )
                            for result, output in zip(results, outputs))
        # list or scalar
        return results[0] if len(results) == 1 else results
    ##############################################
#   def __array_wrap__(self, out_array, context=None):
#
#       self._logger.debug('\n  self={}\n  out_array={}\n  context={}'.format(self, out_array, context))
#
#       return super(UnitValues, self).__array_wrap__(out_array, context)
    ##############################################
    def as_ndarray(self, scale=False):
        array = self.view(np.ndarray)
        if scale:
            return array * self.scale
        else:
            return array
    ##############################################
    def __getitem__(self, slice_):
        value = super(UnitValues, self).__getitem__(slice_)
        if isinstance(value, UnitValue): # slice
            return value
        else:
            return self._prefixed_unit.new_value(value)
    ##############################################
    def __setitem__(self, slice_, value):
        if isinstance(value, UnitValue):
            self._check_unit(value)
            value = self._convert_value(value).value
        elif isinstance(value, UnitValues):
            self._check_unit(value)
            value = self._convert_value(value)
        super(UnitValues, self).__setitem__(slice_, value)
    ##############################################
    # def __getstate__(self):
    #     # https://docs.python.org/3/library/pickle.html#object.__getstate__
    #     return {
    #         'data': super(UnitValues, self).__getstate__(),
    #         'prefixed_unit': self._prefixed_unit,
    #     }
    ##############################################
    def __reduce__(self):
        # https://docs.python.org/3/library/pickle.html#object.__reduce__
        np_state = super(UnitValues, self).__reduce__()
        # ( <built-in function _reconstruct>,
        #   (<class 'PySpice.Unit.Unit.UnitValues'>, (0,), b'b'),
        #   (1, (1, 1), dtype('float64'), False, b'\x00\x00\x80?\x00\x00\x80?') )
        obj_state = (self._prefixed_unit,) + np_state[2]
        return np_state[:2] + (obj_state,) + np_state[3:]
    ##############################################
    def __setstate__(self, state):
        # https://docs.python.org/3/library/pickle.html#object.__setstate__
        super(UnitValues, self).__setstate__(state[1:])
        self._prefixed_unit = state[0]
    ##############################################
    def __contains__(self, value):
        raise NotImplementedError
    ##############################################
    def __repr__(self):
        # return repr(self.as_ndarray())
        return '{}({})'.format(self.__class__.__name__, str(self))
    ##############################################
    @property
    def prefixed_unit(self):
        return self._prefixed_unit
    @property
    def unit(self):
        return self._prefixed_unit.unit
    @property
    def power(self):
        return self._prefixed_unit.power
    @property
    def scale(self):
        return self._prefixed_unit.power.scale
    ##############################################
    def is_same_unit(self, other):
        return self._prefixed_unit.is_same_unit(other.prefixed_unit)
    ##############################################
    def _check_unit(self, other):
        if not self.is_same_unit(other):
            raise UnitError
    ##############################################
    def is_same_power(self, other):
        return self._prefixed_unit.is_same_power(other.prefixed_unit)
    ##############################################
    def __eq__(self, other):
        """self == other"""
        if isinstance(other, UnitValues):
            return self.is_same_unit(other) and self.as_ndarray() == other.as_ndarray()
        else:
            raise ValueError
    ##############################################
    def _convert_value(self, other):
        """Convert the value of other to the power of self."""
        self._check_unit(other)
        if self.is_same_power(other):
            return other
        else:
            return other * (other.scale / self.scale) # for numerical precision
    ##############################################
    def __str__(self):
        return str(self.as_ndarray()) + '@' + str(self._prefixed_unit)
    ##############################################
    def reciprocal(self):
        equivalent_unit = self.unit.reciprocal(prefixed_unit=True)
        reciprocal_value = 1. / np.as_ndarray(True)
        return self.from_ndarray(reciprocal_value, equivalent_unit)
    ##############################################
    def get_prefixed_unit(self, power=0):
        prefixed_unit = PrefixedUnit.from_prefixed_unit(self.unit, power)
        if prefixed_unit is not None:
            return prefixed_unit
        else:
            raise NameError("Prefixed unit not found for {} and power {}".format(self, power))
    ##############################################
    def convert(self, prefixed_unit):
        """Convert the value to another power."""
        self._prefixed_unit.check_unit(prefixed_unit)
        if self._prefixed_unit.is_same_power(prefixed_unit):
            return self
        else:
            value = self.as_ndarray(True) / prefixed_unit.scale
            return prefixed_unit.new_value(value)
    ##############################################
    def convert_to_power(self, power=0):
        """Convert the value to another power."""
        value = self.as_ndarray(True)
        if power != 0:
            value /= 10**power
        return self.get_prefixed_unit(power).new_value(value)
####################################################################################################
# Reset
PrefixedUnit._value_ctor = UnitValue
PrefixedUnit._values_ctor = UnitValues
_simple_prefixed_unit = PrefixedUnit()
####################################################################################################
class FrequencyMixin:
    """ This class implements a frequency mixin. """
    ##############################################
    @property
    def period(self):
        r""" Return the period :math:`T = \frac{1}{f}`. """
        return self.reciprocal()
    ##############################################
    @property
    def pulsation(self):
        r""" Return the pulsation :math:`\omega = 2\pi f`. """
        # Fixme: UnitValues
        return float(self * 2 * math.pi)
####################################################################################################
class PeriodMixin:
    """ This class implements a period mixin. """
    ##############################################
    @property
    def frequency(self):
        r""" Return the period :math:`f = \frac{1}{T}`. """
        return self.reciprocal()
    ##############################################
    @property
    def pulsation(self):
        r""" Return the pulsation :math:`\omega = \frac{2\pi}{T}`. """
        return self.frequency.pulsation
</file>

<file path="PySpice/__init__.py">
####################################################################################################
#
# PySpice - A Spice Package for Python
# Copyright (C) 2014 Fabrice Salvaire
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
####################################################################################################
####################################################################################################
__version__ = '1.5'
GIT_TAG = 'v1.5'
def show_version():
    print('PySpice Version {}'.format(__version__))
</file>

</files>
